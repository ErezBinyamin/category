#!/usr/bin/python

""" Category

Usage: 
  category init <path> <name>
  category build <path>
  category rebuild <path>
  category subcat [--static] <path> <subcat_path> <subcat_name> <query>
  category query <path> <query> [--json | --name | --src | --edit]
  category serve <path> [(-p <port>)] [(-a <bind_addr>)]

Options:
  -p port (default: 7688)
  -a address to bind (default: 127.0.0.1)
"""

from flask import Flask, send_from_directory
import docopt, yaml, os, subprocess, shlex, select, json, shutil, signal, threading
from src.build import cat_builder
import src.util

def cat_error(*args):
    print("[ERROR]:",*args)
    exit(1)

def config_path(cat_path):
    return os.path.join(cat_path, "category.yaml")

def metadata_path(cat_path):
    return os.path.join(cat_path, "out/metadata.json")

def load_config(cat_path):
    with open(config_path(cat_path)) as f:
        return yaml.load(f)
    
def load_metadata(cat_path):
    with open(metadata_path(cat_path)) as f:
        return json.load(f)

def is_category(cat_path):
    return os.path.exists(config_path(cat_path))

def read_config(cat_path):
    if not is_category(cat_path):
        cat_error(f"Not a category. Run: category init {cat_path}")
    with open(config_path,"r") as f:
        return yaml.load(f)

def cat_init(cat_path, name):
    # In the cat_path folder, create the structure
    # $CAT_PATH/src
    # $CAT_PATH/out
    # $CAT_PATH/category.yaml (with name: <name>)
    if is_category(cat_path):
        cat_error(f"Pre-existing category found in {cat_path}")
    for dirname in ["src","out","out/files"]:
        dir_path = os.path.join(cat_path,dirname)
        if not os.path.exists(dir_path):
            os.mkdir(dir_path)
    with open(config_path(cat_path),"w") as f:
        yaml.dump({"name":name},f)

def cat_build(cat_path):
    cat_builder(os.path.join(cat_path,"src"), os.path.join(cat_path,"out"))

def cat_rebuild(cat_path):
    cat_builder(os.path.join(cat_path,"src"), os.path.join(cat_path,"out"), True)

def cat_subcat(src_path, subcat_path, subcat_name, query, static=False):
    if not is_category(subcat_path):
        cat_init(subcat_path, subcat_name)

    if static:
        # Copy page folder into subcat directory
        index_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","index.html")
        shutil.copy2(index_path, os.path.join(subcat_path,"index.html"))
        static_src_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","static")
        static_dst_path = os.path.join(subcat_path,"static")
        shutil.copytree(static_src_path,static_dst_path)
        
    subcat_js_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","src","components","search","module","subcat.js")
    metadata_path = os.path.join(src_path,"out","metadata.json")
    proc = subprocess.Popen(shlex.split(f"node {subcat_js_path} {metadata_path} '{query}'"),shell=False,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc_output = bytes()
    while proc.poll() == None:
        readx = select.select([proc.stdout.fileno()], [], [])[0]
        if readx:
            proc_output += proc.stdout.read()
    if proc.returncode == 0:
        subcat_nodes = json.loads(proc_output)
        src_out_path = os.path.join(src_path,"out")
        dst_out_path = os.path.join(subcat_path,"out")
        src_out_files_path = os.path.join(src_out_path,"files")
        dst_out_files_path = os.path.join(dst_out_path,"files")
            
        for node_id in subcat_nodes:
            src_file_path = os.path.join(src_out_path, node_id+".html")
            dst_file_path = os.path.join(dst_out_path, node_id+".html")
            src_files_path = os.path.join(src_out_files_path, node_id)
            dst_files_path = os.path.join(dst_out_files_path, node_id)
            # Copy page if it exists:
            if os.path.exists(src_file_path):
                shutil.copy2(src_file_path, dst_file_path)
            # Copy files dir if it exists:
            if os.path.exists(src_files_path):
                shutil.copytree(src_files_path, dst_files_path)

        # Generate metadata.json for subcategory
        src_md_path = os.path.join(src_out_path,"metadata.json")
        dst_md_path = os.path.join(dst_out_path,"metadata.json")
        with open(src_md_path,"r") as f:
            md = json.load(f)
            new_md = src.util.create_subcat(md, subcat_nodes)
            with open(dst_md_path,"w") as f2:
                json.dump(new_md,f2)
                
    elif proc.returncode == 1:
        cat_error(proc_output.decode())

def cat_query(src_path, query, as_src, as_json, as_edit):
    subcat_js_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","src","components","search","module","subcat.js")
    metadata_path = os.path.join(src_path,"out","metadata.json")
    proc = subprocess.Popen(shlex.split(f"node {subcat_js_path} {metadata_path} '{query}'"),shell=False,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc_output = bytes()
    while proc.poll() == None:
        readx = select.select([proc.stdout.fileno()], [], [])[0]
        if readx:
            proc_output += proc.stdout.read()
    if proc.returncode == 0:
        subcat_nodes = json.loads(proc_output)
        cat_nodes = load_metadata(src_path)
        
        if as_src:
            for n in subcat_nodes:
                if 'src' in cat_nodes[n]:
                    node_path = os.path.join(src_path, 'src', cat_nodes[n]['src'])
                    with open(node_path, "r") as f:
                        print(f.read())
        if as_edit:
            to_edit = [n for n in subcat_nodes if 'src' in cat_nodes[n]]
            config = load_config(src_path)
            editor = config.get("editor","/usr/bin/emacs")

            if len(to_edit) == 1:
                node = to_edit[0]
                node_src = os.path.join(src_path,"src",cat_nodes[node].get("src",f"""{cat_nodes[node]["name"]}.md"""))
                if os.path.exists(node_src):
                    print("EDIT",node_src)
                    proc = subprocess.Popen([editor, node_src],shell=False)
                    proc.wait()
                    cat_build(src_path)
                else:
                    return f"Source file {node_src} does not exist"
            elif len(to_edit) == 0:
                print("No nodes found matching query")
            elif len(to_edit) > 1:
                print("Multiple nodes found matching query:")
                output_names = [cat_nodes[x]['name'] for x in subcat_nodes]
                for n in output_names:
                    print(n)
        elif as_json:
            print(json.dumps({x:cat_nodes[x] for x in subcat_nodes}))
        else: # print name is the default
            output_names = [cat_nodes[x]['name'] for x in subcat_nodes]
            for n in output_names:
                print(n)
        
def cat_serve(cat_path, port, bind_addr):
    # Ensure we don't zombify our editors
    signal.signal(signal.SIGCHLD, signal.SIG_IGN);

    # Load the category metadata and configuration
    metadata = load_metadata(cat_path)
    config = load_config(cat_path)
    editor = config.get("editor","/usr/bin/emacs")
    
    if not is_category(cat_path):
        cat_error(f"Not a category. Run: category init {cat_path}")
        
    cat_root = os.path.join(os.path.realpath(cat_path),"out")
    print(f"Serving {cat_root} on port {bind_addr}:{port}...")
    page_root = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page")
    static_root = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","static")
    app = Flask(__name__,static_url_path='')
    
    @app.route('/static/<path:path>')
    def send_static_css(path):
        return send_from_directory(static_root, path)
    
    @app.route('/edit/<node>')
    def edit_file(node):
        node_src = os.path.join(cat_path,"src",metadata[node].get("src",f"""{metadata[node]["name"]}.md"""))
        print("EDIT",node_src)
        def edit_node(cat_path, editor, node_src):
            proc = subprocess.Popen([editor, node_src],shell=False)
            proc.wait()
            cat_build(cat_path)
            return
        if os.path.exists(node_src):
            thread = threading.Thread(target=edit_node, args=(cat_path, editor, node_src))
            thread.start()
            return f"Editor {editor} started"
        else:
            return f"Source file {node_src} does not exist"
    
    @app.route('/out/<path:path>')
    def send_file(path):
        return send_from_directory(cat_root, path)

    @app.route('/node/<path:path>')
    def send_node(path):
        return send_from_directory(page_root,"dist/index.html")
    
    @app.route('/')
    def send_root():
        return send_from_directory(page_root,"dist/index.html")

    app.run(host=bind_addr, port=port, debug=False)
    
if __name__ == "__main__":
    args = docopt.docopt(__doc__)
    if args['init']:
        cat_init(args['<path>'], args['<name>'])
    elif args['build']:
        cat_build(args['<path>'])
    elif args['rebuild']:
        cat_rebuild(args['<path>'])
    elif args['subcat']:
        cat_subcat(args['<path>'],
                   args['<subcat_path>'],
                   args['<subcat_name>'],
                   args['<query>'],
                   args['--static'])
    elif args['query']:
        cat_query(args['<path>'],
                  args['<query>'], as_src=args['--src'], as_json=args['--json'], as_edit=args['--edit'])
    elif args['serve']:
        cat_serve(args['<path>'],
                  args['-p'] if args['-p'] != False else 7688,
                  args['-a'] if args['-a'] != False else "127.0.0.1")
