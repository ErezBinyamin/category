#!/usr/bin/python

""" Category

Usage: 
  category init <path> <name>
  category build <path>
  category rebuild <path>
  category subcat [--static] <path> <subcat_path> <subcat_name> <query>
  category query <path> <query> [--json | --name | --src | --edit | (--pdf <pdf_path>)]
  category serve <path> [(-p <port>)] [(-a <bind_addr>)]
  category n4jimport <path> <un> <pw>

Options:
  -p port (default: 7688)
  -a address to bind (default: 127.0.0.1)
"""

# [<db_url>] [--reset]

from flask import Flask, send_from_directory, send_file
import docopt, yaml, os, subprocess, shlex, select, json, shutil, signal, threading
from neo4j import GraphDatabase
from src.build import cat_builder
import src.util

metadata = {}

nodes_import = """with {md} as metadata
UNWIND keys(metadata) AS node
CREATE (n:Node {nodeid:node, name:metadata[node].name, date:metadata[node].date, index:metadata[node].index})"""

has_edges_import = """with {md} as metadata
UNWIND keys(metadata) AS node
UNWIND keys(metadata[node].edges.has) AS edge
UNWIND metadata[node].edges.has[edge] AS dest
MATCH (src:Node {nodeid:node}),(tgt:Node {nodeid:dest})
MERGE (src)-[:HAS {label:edge}]->(tgt)"""

is_edges_import = """with {md} as metadata
UNWIND keys(metadata) AS node
UNWIND keys(metadata[node].edges.is) AS edge
UNWIND metadata[node].edges.is[edge] AS dest
MATCH (src:Node {nodeid:node}),(tgt:Node {nodeid:dest})
MERGE (src)-[:IS {label:edge}]->(tgt)"""

def n4j_run(tx, q, md):
    tx.run(q, md=md)

def cat_error(*args):
    print("[ERROR]:",*args)
    exit(1)

def config_path(cat_path):
    return os.path.join(cat_path, "category.yaml")

def metadata_path(cat_path):
    return os.path.join(cat_path, "out/metadata.json")

def load_config(cat_path):
    with open(config_path(cat_path)) as f:
        return yaml.load(f, Loader=yaml.SafeLoader)
    
def load_metadata(cat_path):
    with open(metadata_path(cat_path)) as f:
        return json.load(f)

def is_category(cat_path):
    return os.path.exists(config_path(cat_path))

def read_config(cat_path):
    if not is_category(cat_path):
        cat_error(f"Not a category. Run: category init {cat_path}")
    with open(config_path,"r") as f:
        return yaml.load(f, Loader=yaml.SafeLoader)

def cat_n4j_import(cat_path, db_url, un, pw, reset_db=True):
    metadata_path = os.path.join(cat_path,"out","metadata.json")
    with open(metadata_path,"r") as f: s = f.read()
    s = json.loads(s)

    driver = GraphDatabase.driver("bolt://"+db_url, auth=(un, pw))

    with driver.session() as session:
        if reset_db:
            session.read_transaction(n4j_run, "match (n) detach delete n", s)
        session.read_transaction(n4j_run, nodes_import, s)
        session.read_transaction(n4j_run, has_edges_import, s)
        #session.read_transaction(n4j_run, is_edges_import, s)
    
    
def cat_init(cat_path, name):
    # In the cat_path folder, create the structure
    # $CAT_PATH/src
    # $CAT_PATH/out
    # $CAT_PATH/category.yaml (with name: <name>)
    if is_category(cat_path):
        cat_error(f"Pre-existing category found in {cat_path}")
    for dirname in ["src","out","out/files"]:
        dir_path = os.path.join(cat_path,dirname)
        if not os.path.exists(dir_path):
            os.mkdir(dir_path)
    with open(config_path(cat_path),"w") as f:
        yaml.dump({"name":name},f)

def cat_build(cat_path):
    cat_builder(os.path.join(cat_path,"src"), os.path.join(cat_path,"out"))

def cat_rebuild(cat_path):
    cat_builder(os.path.join(cat_path,"src"), os.path.join(cat_path,"out"), True)

def cat_subcat(src_path, subcat_path, subcat_name, query, static=False):
    if not is_category(subcat_path):
        cat_init(subcat_path, subcat_name)

    if static:
        # Copy page folder into subcat directory
        index_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","index.html")
        shutil.copy2(index_path, os.path.join(subcat_path,"index.html"))
        os.symlink(os.path.join(subcat_path,"index.html"), os.path.join(subcat_path,"404.html"))
        static_src_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","static")
        static_dst_path = os.path.join(subcat_path,"static")
        shutil.copytree(static_src_path,static_dst_path)
        
    subcat_js_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","src","components","search","module","subcat.js")
    metadata_path = os.path.join(src_path,"out","metadata.json")
    proc = subprocess.Popen(shlex.split(f"node {subcat_js_path} {metadata_path} '{query}'"),shell=False,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc_output = bytes()
    while proc.poll() == None:
        readx = select.select([proc.stdout.fileno()], [], [])[0]
        if readx:
            proc_output += proc.stdout.read()
    if proc.returncode == 0:
        subcat_nodes = json.loads(proc_output)
        src_out_path = os.path.join(src_path,"out")
        dst_out_path = os.path.join(subcat_path,"out")
        src_out_files_path = os.path.join(src_out_path,"files")
        dst_out_files_path = os.path.join(dst_out_path,"files")
            
        for node_id in subcat_nodes:
            src_file_path = os.path.join(src_out_path, node_id+".html")
            dst_file_path = os.path.join(dst_out_path, node_id+".html")
            src_files_path = os.path.join(src_out_files_path, node_id)
            dst_files_path = os.path.join(dst_out_files_path, node_id)
            # Copy page if it exists:
            if os.path.exists(src_file_path):
                shutil.copy2(src_file_path, dst_file_path)
            # Copy files dir if it exists:
            if os.path.exists(src_files_path):
                shutil.copytree(src_files_path, dst_files_path)

        # Generate metadata.json for subcategory
        src_md_path = os.path.join(src_out_path,"metadata.json")
        dst_md_path = os.path.join(dst_out_path,"metadata.json")
        with open(src_md_path,"r") as f:
            md = json.load(f)
            new_md = src.util.create_subcat(md, subcat_nodes)
            with open(dst_md_path,"w") as f2:
                json.dump(new_md,f2)
                
    elif proc.returncode == 1:
        cat_error(proc_output.decode())

def cat_query(src_path, query, as_src, as_json, as_edit, pdf_path=None):
    subcat_js_path = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","src","components","search","module","subcat.js")
    metadata_path = os.path.join(src_path,"out","metadata.json")
    #print(f"node {subcat_js_path} {metadata_path} '{query}'")
    proc = subprocess.Popen(shlex.split(f"node {subcat_js_path} {metadata_path} '{query}'"),shell=False,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc_output = bytes()
    while proc.returncode is None:
        proc.poll()
        readx = select.select([proc.stdout], [], [])[0]
        if proc.stdout in readx:
            new_data = proc.stdout.read()
            proc_output += new_data
    if proc.returncode == 0:
        #print(len(proc_output))
        subcat_nodes = json.loads(proc_output)
        cat_nodes = load_metadata(src_path)
        
        if as_src:
            for n in subcat_nodes:
                if 'src' in cat_nodes[n]:
                    node_path = os.path.join(src_path, 'src', cat_nodes[n]['src'])
                    with open(node_path, "r") as f:
                        print(f.read())
        if as_edit:
            to_edit = [n for n in subcat_nodes if 'src' in cat_nodes[n]]
            config = load_config(src_path)
            editor = config.get("editor","/usr/bin/emacs")

            if len(to_edit) == 1:
                node = to_edit[0]
                node_src = os.path.join(src_path,"src",cat_nodes[node].get("src",f"""{cat_nodes[node]["name"]}.md"""))
                if os.path.exists(node_src):
                    print("EDIT",node_src)
                    proc = subprocess.Popen([editor, node_src],shell=False)
                    proc.wait()
                    cat_build(src_path)
                else:
                    return f"Source file {node_src} does not exist"
            elif len(to_edit) == 0:
                print("No nodes found matching query")
            elif len(to_edit) > 1:
                print("Multiple nodes found matching query:")
                output_names = [cat_nodes[x]['name'] for x in subcat_nodes]
                for n in output_names:
                    print(n)
        elif as_json:
            print(json.dumps({x:cat_nodes[x] for x in subcat_nodes}))
        elif pdf_path != None:
            to_print = [n for n in subcat_nodes if 'src' in cat_nodes[n]]
            if len(to_print) == 1:
                node = to_print[0]
                node_src = os.path.join(src_path,"src",cat_nodes[node].get("src",f"""{cat_nodes[node]["name"]}.md"""))
                src_folder = os.path.dirname(node_src)
                dst_path = os.path.join(os.getcwd(), pdf_path)
                spo = subprocess.check_output(f"pandoc {node_src} -o {dst_path}",shell=True,stderr=subprocess.STDOUT,env={e:os.environ[e] for e in os.environ},cwd=src_folder)
                print(spo)
            elif len(to_print) == 0:
                print("No nodes found matching query")
            elif len(to_print) > 1:
                print("Multiple nodes found matching query:")
                output_names = [cat_nodes[x]['name'] for x in subcat_nodes]
                for n in output_names:
                    print(n)
        else: # print name is the default
            output_names = [cat_nodes[x]['name'] for x in subcat_nodes]
            for n in output_names:
                print(n)
        
def cat_serve(cat_path, port, bind_addr):
    global metadata
    # Ensure we don't zombify our editors
    signal.signal(signal.SIGCHLD, signal.SIG_IGN);

    # Load the category metadata and configuration
    metadata = load_metadata(cat_path)
    config = load_config(cat_path)
    editor = config.get("editor","/usr/bin/emacs")
    
    if not is_category(cat_path):
        cat_error(f"Not a category. Run: category init {cat_path}")
        
    cat_root = os.path.join(os.path.realpath(cat_path),"out")
    print(f"Serving {cat_root} on port {bind_addr}:{port}...")
    page_root = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page")
    static_root = os.path.join(os.path.realpath(os.path.dirname(__file__)),"page","dist","static")
    app = Flask(__name__,static_url_path='')
    
    @app.route('/static/<path:path>')
    def send_static_css(path):
        return send_from_directory(static_root, path)
    
    @app.route('/edit/<node>')
    def edit_file(node):
        global metadata
        node_src = os.path.join(cat_path,"src",metadata[node].get("src",f"""{metadata[node]["name"]}.md"""))
        print("EDIT",node_src)
        def edit_node(cat_path, editor, node_src):
            global metadata
            proc = subprocess.Popen([editor, node_src],shell=False)
            proc.wait()
            cat_build(cat_path)
            metadata = load_metadata(cat_path)
            return
        if os.path.exists(node_src):
            thread = threading.Thread(target=edit_node, args=(cat_path, editor, node_src))
            thread.start()
            return f"Editor {editor} started"
        else:
            return f"Source file {node_src} does not exist"

    @app.route('/new')
    def new_file():
        global metadata
        print("NEW")
        def new_node(cat_path, editor):
            global metadata
            proc = subprocess.Popen([editor, '--execute', '(insert "``` info\nname: \ndate: \n```\n\n")'],shell=False,cwd=os.path.join(cat_path,'src'))
            proc.wait()
            cat_build(cat_path)
            metadata = load_metadata(cat_path)
            return
        thread = threading.Thread(target=new_node, args=(cat_path, editor))
        thread.start()
        return f"Editor {editor} started"

    @app.route('/print/<node>')
    def print_file(node):
        global metadata
        print("PRINT")
        node_src = os.path.join(cat_path,"src",metadata[node].get("src",f"""{metadata[node]["name"]}.md"""))
        dst_path = os.path.join(cat_path,"out","node.pdf")
        if os.path.exists(dst_path):
            os.remove(dst_path)
        cmd = f"/bin/bash -c 'pandoc {node_src} -o {dst_path}'"
        src_folder = os.path.dirname(node_src)
        print(node_src,dst_path)
        #pandoc_output = pypandoc.convert_file(node_src, "pdf", outputfile=dst_path)
        pandoc_output = subprocess.check_output(shlex.split(cmd),shell=False,env={"PATH":"/usr/bin"},cwd=src_folder)
        if os.path.exists(dst_path):
            return send_file(dst_path, f"""{metadata[node]["name"]}.pdf""")
        else:
            print(pandoc_output)
            return pandoc_output
    
    @app.route('/out/<path:path>')
    def send_output_file(path):
        return send_from_directory(cat_root, path)

    @app.route('/node/<path:path>')
    def send_node(path):
        return send_from_directory(page_root,"dist/index.html")
    
    @app.route('/')
    def send_root():
        return send_from_directory(page_root,"dist/index.html")

    app.run(host=bind_addr, port=port, debug=False)
    
if __name__ == "__main__":
    args = docopt.docopt(__doc__)
    if args['init']:
        cat_init(args['<path>'], args['<name>'])
    elif args['build']:
        cat_build(args['<path>'])
    elif args['rebuild']:
        cat_rebuild(args['<path>'])
    elif args['subcat']:
        cat_subcat(args['<path>'],
                   args['<subcat_path>'],
                   args['<subcat_name>'],
                   args['<query>'],
                   args['--static'])
    elif args['query']:
        cat_query(args['<path>'],
                  args['<query>'], as_src=args['--src'], as_json=args['--json'], as_edit=args['--edit'], pdf_path=args['<pdf_path>'])
    elif args['serve']:
        cat_serve(args['<path>'],
                  args['-p'] if args['-p'] != False else 7688,
                  args['-a'] if args['-a'] != False else "127.0.0.1")
    elif args['n4jimport']:
        cat_n4j_import(args['<path>'],
                       "localhost:7687",
                       args['<un>'],
                       args['<pw>'],
                       True)
