(function () {
  'use strict';

  /*!
   * Vue.js v2.6.10
   * (c) 2014-2019 Evan You
   * Released under the MIT License.
   */
  /*  */

  var emptyObject = Object.freeze({});

  // These helpers produce better VM code in JS engines due to their
  // explicitness and function inlining.
  function isUndef (v) {
    return v === undefined || v === null
  }

  function isDef (v) {
    return v !== undefined && v !== null
  }

  function isTrue (v) {
    return v === true
  }

  function isFalse (v) {
    return v === false
  }

  /**
   * Check if value is primitive.
   */
  function isPrimitive (value) {
    return (
      typeof value === 'string' ||
      typeof value === 'number' ||
      // $flow-disable-line
      typeof value === 'symbol' ||
      typeof value === 'boolean'
    )
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject (obj) {
    return obj !== null && typeof obj === 'object'
  }

  /**
   * Get the raw type string of a value, e.g., [object Object].
   */
  var _toString = Object.prototype.toString;

  function toRawType (value) {
    return _toString.call(value).slice(8, -1)
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject (obj) {
    return _toString.call(obj) === '[object Object]'
  }

  function isRegExp (v) {
    return _toString.call(v) === '[object RegExp]'
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex (val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val)
  }

  function isPromise (val) {
    return (
      isDef(val) &&
      typeof val.then === 'function' &&
      typeof val.catch === 'function'
    )
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString (val) {
    return val == null
      ? ''
      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
        ? JSON.stringify(val, null, 2)
        : String(val)
  }

  /**
   * Convert an input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap (
    str,
    expectsLowerCase
  ) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase
      ? function (val) { return map[val.toLowerCase()]; }
      : function (val) { return map[val]; }
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if an attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array.
   */
  function remove (arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1)
      }
    }
  }

  /**
   * Check whether an object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key)
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached (fn) {
    var cache = Object.create(null);
    return (function cachedFn (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str))
    })
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase()
  });

  /**
   * Simple bind polyfill for environments that do not support it,
   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
   * since native bind is now performant enough in most browsers.
   * But removing it would mean breaking code that was able to run in
   * PhantomJS 1.x, so this must be kept for backward compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind (fn, ctx) {
    function boundFn (a) {
      var l = arguments.length;
      return l
        ? l > 1
          ? fn.apply(ctx, arguments)
          : fn.call(ctx, a)
        : fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
  }

  function nativeBind (fn, ctx) {
    return fn.bind(ctx)
  }

  var bind = Function.prototype.bind
    ? nativeBind
    : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray (list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret
  }

  /**
   * Mix properties into target object.
   */
  function extend (to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject (arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res
  }

  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */
  function noop (a, b, c) {}

  /**
   * Always return false.
   */
  var no = function (a, b, c) { return false; };

  /* eslint-enable no-unused-vars */

  /**
   * Return the same value.
   */
  var identity = function (_) { return _; };

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual (a, b) {
    if (a === b) { return true }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i])
          })
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime()
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key])
          })
        } else {
          /* istanbul ignore next */
          return false
        }
      } catch (e) {
        /* istanbul ignore next */
        return false
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b)
    } else {
      return false
    }
  }

  /**
   * Return the first index at which a loosely equal value can be
   * found in the array (if value is a plain object, the array must
   * contain an object of the same shape), or -1 if it is not present.
   */
  function looseIndexOf (arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) { return i }
    }
    return -1
  }

  /**
   * Ensure a function is called only once.
   */
  function once (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    }
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
  ];

  var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch'
  ];

  /*  */



  var config = ({
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "production" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "production" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  });

  /*  */

  /**
   * unicode letters used for parsing html tags, component names and property paths.
   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
   */
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  /**
   * Check if a string starts with $ or _
   */
  function isReserved (str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F
  }

  /**
   * Define a property.
   */
  function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
  function parsePath (path) {
    if (bailRE.test(path)) {
      return
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) { return }
        obj = obj[segments[i]];
      }
      return obj
    }
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = ({}).watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', ({
        get: function get () {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      })); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function () {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative (Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
  }

  var hasSymbol =
    typeof Symbol !== 'undefined' && isNative(Symbol) &&
    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/(function () {
      function Set () {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has (key) {
        return this.set[key] === true
      };
      Set.prototype.add = function add (key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear () {
        this.set = Object.create(null);
      };

      return Set;
    }());
  }

  /*  */

  var warn = noop;

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // The current target watcher being evaluated.
  // This is globally unique because only one watcher
  // can be evaluated at a time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget (target) {
    targetStack.push(target);
    Dep.target = target;
  }

  function popTarget () {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }

  /*  */

  var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
  ) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance
  };

  Object.defineProperties( VNode.prototype, prototypeAccessors );

  var createEmptyVNode = function (text) {
    if ( text === void 0 ) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node
  };

  function createTextVNode (val) {
    return new VNode(undefined, undefined, undefined, String(val))
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode (vnode) {
    var cloned = new VNode(
      vnode.tag,
      vnode.data,
      // #7975
      // clone children array to avoid mutating original in case of cloning
      // a child.
      vnode.children && vnode.children.slice(),
      vnode.text,
      vnode.elm,
      vnode.context,
      vnode.componentOptions,
      vnode.asyncFactory
    );
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
  ];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break
        case 'splice':
          inserted = args.slice(2);
          break
      }
      if (inserted) { ob.observeArray(inserted); }
      // notify change
      ob.dep.notify();
      return result
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving (value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment a target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment (target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment a target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment (target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe (value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (
      shouldObserve &&
      !isServerRendering() &&
      (Array.isArray(value) || isPlainObject(value)) &&
      Object.isExtensible(value) &&
      !value._isVue
    ) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive$$1 (
    obj,
    key,
    val,
    customSetter,
    shallow
  ) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return
        }
        // #7981: for accessor properties without setter
        if (getter && !setter) { return }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set (target, key, val) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      return val
    }
    if (!ob) {
      target[key] = val;
      return val
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del (target, key) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      return
    }
    if (!hasOwn(target, key)) {
      return
    }
    delete target[key];
    if (!ob) {
      return
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData (to, from) {
    if (!from) { return to }
    var key, toVal, fromVal;

    var keys = hasSymbol
      ? Reflect.ownKeys(from)
      : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      // in case the object is already observed...
      if (key === '__ob__') { continue }
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (
        toVal !== fromVal &&
        isPlainObject(toVal) &&
        isPlainObject(fromVal)
      ) {
        mergeData(toVal, fromVal);
      }
    }
    return to
  }

  /**
   * Data
   */
  function mergeDataOrFn (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal
      }
      if (!parentVal) {
        return childVal
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn () {
        return mergeData(
          typeof childVal === 'function' ? childVal.call(this, this) : childVal,
          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
        )
      }
    } else {
      return function mergedInstanceDataFn () {
        // instance merge
        var instanceData = typeof childVal === 'function'
          ? childVal.call(vm, vm)
          : childVal;
        var defaultData = typeof parentVal === 'function'
          ? parentVal.call(vm, vm)
          : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData)
        } else {
          return defaultData
        }
      }
    }
  }

  strats.data = function (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {

        return parentVal
      }
      return mergeDataOrFn(parentVal, childVal)
    }

    return mergeDataOrFn(parentVal, childVal, vm)
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook (
    parentVal,
    childVal
  ) {
    var res = childVal
      ? parentVal
        ? parentVal.concat(childVal)
        : Array.isArray(childVal)
          ? childVal
          : [childVal]
      : parentVal;
    return res
      ? dedupeHooks(res)
      : res
  }

  function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets (
    parentVal,
    childVal,
    vm,
    key
  ) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      return extend(res, childVal)
    } else {
      return res
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    /* istanbul ignore if */
    if (!childVal) { return Object.create(parentVal || null) }
    if (!parentVal) { return childVal }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent
        ? parent.concat(child)
        : Array.isArray(child) ? child : [child];
    }
    return ret
  };

  /**
   * Other object hashes.
   */
  strats.props =
  strats.methods =
  strats.inject =
  strats.computed = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    if (childVal && "production" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) { extend(ret, childVal); }
    return ret
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val)
          ? val
          : { type: val };
      }
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val };
      }
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives (options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        if (typeof def$$1 === 'function') {
          dirs[key] = { bind: def$$1, update: def$$1 };
        }
      }
    }
  }

  function assertObjectType (name, value, vm) {
    if (!isPlainObject(value)) {
      warn(
        "Invalid value for option \"" + name + "\": expected an Object, " +
        "but got " + (toRawType(value)) + ".",
        vm
      );
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions (
    parent,
    child,
    vm
  ) {

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child);
    normalizeInject(child);
    normalizeDirectives(child);

    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField (key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset (
    options,
    type,
    id,
    warnMissing
  ) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) { return assets[id] }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    return res
  }

  /*  */



  function validateProp (
    key,
    propOptions,
    propsData,
    vm
  ) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    return value
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue (vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined
    }
    var def = prop.default;
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData &&
      vm.$options.propsData[key] === undefined &&
      vm._props[key] !== undefined
    ) {
      return vm._props[key]
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function'
      ? def.call(vm)
      : def
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType (fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ''
  }

  function isSameType (a, b) {
    return getType(a) === getType(b)
  }

  function getTypeIndex (type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i
      }
    }
    return -1
  }

  /*  */

  function handleError (err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        while ((cur = cur.$parent)) {
          var hooks = cur.$options.errorCaptured;
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) { return }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }

  function invokeWithErrorHandling (
    handler,
    context,
    args,
    vm,
    info
  ) {
    var res;
    try {
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
        // issue #9511
        // avoid catch triggering multiple times when nested calls
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res
  }

  function globalHandleError (err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info)
      } catch (e) {
        // if the user intentionally throws the original error in the handler,
        // do not log it twice
        if (e !== err) {
          logError(e);
        }
      }
    }
    logError(err);
  }

  function logError (err, vm, info) {
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }

  /*  */

  var isUsingMicroTask = false;

  var callbacks = [];
  var pending = false;

  function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using microtasks.
  // In 2.5 we used (macro) tasks (in combination with microtasks).
  // However, it has subtle problems when state is changed right before repaint
  // (e.g. #6813, out-in transitions).
  // Also, using (macro) tasks in event handler would cause some weird behaviors
  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
  // So we now use microtasks everywhere, again.
  // A major drawback of this tradeoff is that there are some scenarios
  // where microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690, which have workarounds)
  // or even between bubbling of the same event (#6566).
  var timerFunc;

  // The nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function () {
      p.then(flushCallbacks);
      // In problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  } else {
    // Fallback to setTimeout.
    timerFunc = function () {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse (val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse (val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
      return
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) { _traverse(val[i], seen); }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) { _traverse(val[keys[i]], seen); }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    }
  });

  function createFnInvoker (fns, vm) {
    function invoker () {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // return handler return value for single handlers
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
      }
    }
    invoker.fns = fns;
    return invoker
  }

  function updateListeners (
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
  ) {
    var name, def$$1, cur, old, event;
    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) ; else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }
        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook (def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook () {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData (
    data,
    Ctor,
    tag
  ) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        checkProp(res, props, key, altKey, true) ||
        checkProp(res, attrs, key, altKey, false);
      }
    }
    return res
  }

  function checkProp (
    res,
    hash,
    key,
    altKey,
    preserve
  ) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true
      }
    }
    return false
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children)
      }
    }
    return children
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren (children) {
    return isPrimitive(children)
      ? [createTextVNode(children)]
      : Array.isArray(children)
        ? normalizeArrayChildren(children)
        : undefined
  }

  function isTextNode (node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment)
  }

  function normalizeArrayChildren (children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') { continue }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + (c[0]).text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) &&
            isDef(c.tag) &&
            isUndef(c.key) &&
            isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res
  }

  /*  */

  function initProvide (vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function'
        ? provide.call(vm)
        : provide;
    }
  }

  function initInjections (vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key]);
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject (inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // #6574 in case the inject object is observed...
        if (key === '__ob__') { continue }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function'
              ? provideDefault.call(vm)
              : provideDefault;
          }
        }
      }
      return result
    }
  }

  /*  */



  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots (
    children,
    context
  ) {
    if (!children || !children.length) {
      return {}
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) &&
        data && data.slot != null
      ) {
        var name = data.slot;
        var slot = (slots[name] || (slots[name] = []));
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots
  }

  function isWhitespace (node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' '
  }

  /*  */

  function normalizeScopedSlots (
    slots,
    normalSlots,
    prevSlots
  ) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      // fast path 1: child component re-render only, parent did not change
      return slots._normalized
    } else if (
      isStable &&
      prevSlots &&
      prevSlots !== emptyObject &&
      key === prevSlots.$key &&
      !hasNormalSlots &&
      !prevSlots.$hasNormal
    ) {
      // fast path 2: stable scoped slots w/ no normal slots to proxy,
      // only need to normalize once
      return prevSlots
    } else {
      res = {};
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== '$') {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    // expose normal slots on scopedSlots
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
      (slots)._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res
  }

  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res)
        ? [res] // single vnode
        : normalizeChildren(res);
      return res && (
        res.length === 0 ||
        (res.length === 1 && res[0].isComment) // #9658
      ) ? undefined
        : res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized
  }

  function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList (
    val,
    render
  ) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    (ret)._isVList = true;
    return ret
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot (
    name,
    fallback,
    props,
    bindObject
  ) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) { // scoped slot
      props = props || {};
      if (bindObject) {
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      nodes = this.$slots[name] || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes)
    } else {
      return nodes
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter (id) {
    return resolveAsset(this.$options, 'filters', id) || identity
  }

  /*  */

  function isKeyNotMatch (expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1
    } else {
      return expect !== actual
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes (
    eventKeyCode,
    key,
    builtInKeyCode,
    eventKeyName,
    builtInKeyName
  ) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName)
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode)
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps (
    data,
    tag,
    value,
    asProp,
    isSync
  ) {
    if (value) {
      if (!isObject(value)) ; else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function ( key ) {
          if (
            key === 'class' ||
            key === 'style' ||
            isReservedAttribute(key)
          ) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key)
              ? data.domProps || (data.domProps = {})
              : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key);
          var hyphenatedKey = hyphenate(key);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on[("update:" + key)] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop( key );
      }
    }
    return data
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic (
    index,
    isInFor
  ) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(
      this._renderProxy,
      null,
      this // for render fns generated for functional component templates
    );
    markStatic(tree, ("__static__" + index), false);
    return tree
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce (
    tree,
    index,
    key
  ) {
    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
    return tree
  }

  function markStatic (
    tree,
    key,
    isOnce
  ) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], (key + "_" + i), isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode (node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners (data, value) {
    if (value) {
      if (!isPlainObject(value)) ; else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data
  }

  /*  */

  function resolveScopedSlots (
    fns, // see flow/vnode
    res,
    // the following are added in 2.6
    hasDynamicKeys,
    contentHashKey
  ) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      (res).$key = contentHashKey;
    }
    return res
  }

  /*  */

  function bindDynamicKeys (baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      }
    }
    return baseObj
  }

  // helper to dynamically append modifier runtime markers to event names.
  // ensure only append when value is already string, otherwise it will be cast
  // to string and cause the type check to miss.
  function prependModifier (value, symbol) {
    return typeof value === 'string' ? symbol + value : value
  }

  /*  */

  function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
  }

  /*  */

  function FunctionalRenderContext (
    data,
    props,
    children,
    parent,
    Ctor
  ) {
    var this$1 = this;

    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(
          data.scopedSlots,
          this$1.$slots = resolveSlots(children, parent)
        );
      }
      return this$1.$slots
    };

    Object.defineProperty(this, 'scopedSlots', ({
      enumerable: true,
      get: function get () {
        return normalizeScopedSlots(data.scopedSlots, this.slots())
      }
    }));

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode
      };
    } else {
      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent (
    Ctor,
    propsData,
    data,
    contextVm,
    children
  ) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
      if (isDef(data.props)) { mergeProps(props, data.props); }
    }

    var renderContext = new FunctionalRenderContext(
      data,
      props,
      children,
      contextVm,
      Ctor
    );

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
      }
      return res
    }
  }

  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone
  }

  function mergeProps (to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  /*  */

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch (oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(
        child,
        options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
      );
    },

    insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy (vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
  ) {
    if (isUndef(Ctor)) {
      return
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      return
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children)
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );

    return vnode
  }

  function createComponentInstanceForVnode (
    vnode, // we know it's MountedComponentVNode but flow doesn't
    parent // activeInstance in lifecycle state
  ) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options)
  }

  function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1 (f1, f2) {
    var merged = function (a, b) {
      // flow complains about extra args which is why we use any
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel (options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input'
    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (
        Array.isArray(existing)
          ? existing.indexOf(callback) === -1
          : existing !== callback
      ) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement (
    context,
    tag,
    data,
    children,
    normalizationType,
    alwaysNormalize
  ) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType)
  }

  function _createElement (
    context,
    tag,
    data,
    children,
    normalizationType
  ) {
    if (isDef(data) && isDef((data).__ob__)) {
      return createEmptyVNode()
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode()
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) &&
      typeof children[0] === 'function'
    ) {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(
          config.parsePlatformTagName(tag), data, children,
          undefined, undefined, context
        );
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(
          tag, data, children,
          undefined, undefined, context
        );
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode
    } else if (isDef(vnode)) {
      if (isDef(ns)) { applyNS(vnode, ns); }
      if (isDef(data)) { registerDeepBindings(data); }
      return vnode
    } else {
      return createEmptyVNode()
    }
  }

  function applyNS (vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (
          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings (data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender (vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin (Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this)
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
          _parentVnode.data.scopedSlots,
          vm.$slots,
          vm.$scopedSlots
        );
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        // There's no need to maintain a stack becaues all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      // if the returned array contains only a single node, allow it
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode
    };
  }

  /*  */

  function ensureCtor (comp, base) {
    if (
      comp.__esModule ||
      (hasSymbol && comp[Symbol.toStringTag] === 'Module')
    ) {
      comp = comp.default;
    }
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }

  function createAsyncPlaceholder (
    factory,
    data,
    context,
    children,
    tag
  ) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node
  }

  function resolveAsyncComponent (
    factory,
    baseCtor
  ) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp
    }

    if (isDef(factory.resolved)) {
      return factory.resolved
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      // already pending
      factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp
    }

    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;
      var timerLoading = null;
      var timerTimeout = null

      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

      var forceRender = function (renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          (owners[i]).$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
          if (timerLoading !== null) {
            clearTimeout(timerLoading);
            timerLoading = null;
          }
          if (timerTimeout !== null) {
            clearTimeout(timerTimeout);
            timerTimeout = null;
          }
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });

      var reject = once(function (reason) {
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              timerLoading = setTimeout(function () {
                timerLoading = null;
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            timerTimeout = setTimeout(function () {
              timerTimeout = null;
              if (isUndef(factory.resolved)) {
                reject(
                   null
                );
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }

  /*  */

  function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
  }

  /*  */

  function getFirstComponentChild (children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents (vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add (event, fn) {
    target.$on(event, fn);
  }

  function remove$1 (event, fn) {
    target.$off(event, fn);
  }

  function createOnceHandler (event, fn) {
    var _target = target;
    return function onceHandler () {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    }
  }

  function updateComponentListeners (
    vm,
    listeners,
    oldListeners
  ) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin (Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on () {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm
    };

    Vue.prototype.$off = function (event, fn) {
      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm
      }
      if (!fn) {
        vm._events[event] = null;
        return vm
      }
      // specific handler
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break
        }
      }
      return vm
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      return vm
    };
  }

  /*  */

  var activeInstance = null;

  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    }
  }

  function initLifecycle (vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin (Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent (
    vm,
    el,
    hydrating
  ) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, {
      before: function before () {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm
  }

  function updateChildComponent (
    vm,
    propsData,
    listeners,
    parentVnode,
    renderChildren
  ) {

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.

    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(
      (newScopedSlots && !newScopedSlots.$stable) ||
      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
    );

    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(
      renderChildren ||               // has new static slots
      vm.$options._renderChildren ||  // has old static slots
      hasDynamicScopedSlot
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) { // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }
  }

  function isInInactiveTree (vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) { return true }
    }
    return false
  }

  function activateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return
      }
    } else if (vm._directInactive) {
      return
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook (vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    waiting = flushing = false;
  }

  // Async edge case #6566 requires saving the timestamp when event listeners are
  // attached. However, calling performance.now() has a perf overhead especially
  // if the page has thousands of event listeners. Instead, we take a timestamp
  // every time the scheduler flushes and use that for all event listeners
  // attached during that flush.
  var currentFlushTimestamp = 0;

  // Async edge case fix requires storing an event listener's attach timestamp.
  var getNow = Date.now;

  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  // All IE versions use low-res event timestamps, and have problematic clock
  // implementations (#9632)
  if (inBrowser && !isIE) {
    var performance = window.performance;
    if (
      performance &&
      typeof performance.now === 'function' &&
      getNow() > document.createEvent('Event').timeStamp
    ) {
      // if the event timestamp, although evaluated AFTER the Date.now(), is
      // smaller than it, it means the event is using a hi-res timestamp,
      // and we need to use the hi-res version for event listener timestamps as
      // well.
      getNow = function () { return performance.now(); };
    }
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) { return a.id - b.id; });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks (queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent (vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks (queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */



  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
  ) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression =  '';
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend () {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy (target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter () {
      return this[sourceKey][key]
    };
    sharedPropertyDefinition.set = function proxySetter (val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps (vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function ( key ) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        defineReactive$$1(props, key, value);
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop( key );
    toggleObserving(true);
  }

  function initData (vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
      ? getData(data, vm)
      : data || {};
    if (!isPlainObject(data)) {
      data = {};
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      if (props && hasOwn(props, key)) ; else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData (data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm)
    } catch (e) {
      handleError(e, vm, "data()");
      return {}
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed (vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(
          vm,
          getter || noop,
          noop,
          computedWatcherOptions
        );
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      }
    }
  }

  function defineComputed (
    target,
    key,
    userDef
  ) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache
        ? createComputedGetter(key)
        : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get
        ? shouldCache && userDef.cache !== false
          ? createComputedGetter(key)
          : createGetterInvoker(userDef.get)
        : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter (key) {
    return function computedGetter () {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value
      }
    }
  }

  function createGetterInvoker(fn) {
    return function computedGetter () {
      return fn.call(this, this)
    }
  }

  function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }

  function initWatch (vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher (
    vm,
    expOrFn,
    handler,
    options
  ) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
  }

  function stateMixin (Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () { return this._data };
    var propsDef = {};
    propsDef.get = function () { return this._props };
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (
      expOrFn,
      cb,
      options
    ) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        try {
          cb.call(vm, watcher.value);
        } catch (error) {
          handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
        }
      }
      return function unwatchFn () {
        watcher.teardown();
      }
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin (Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(
          resolveConstructorOptions(vm.constructor),
          options || {},
          vm
        );
      }
      /* istanbul ignore else */
      {
        vm._renderProxy = vm;
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent (vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions (Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options
  }

  function resolveModifiedOptions (Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) { modified = {}; }
        modified[key] = latest[key];
      }
    }
    return modified
  }

  function Vue$1 (options) {
    this._init(options);
  }

  initMixin(Vue$1);
  stateMixin(Vue$1);
  eventsMixin(Vue$1);
  lifecycleMixin(Vue$1);
  renderMixin(Vue$1);

  /*  */

  function initUse (Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
      if (installedPlugins.indexOf(plugin) > -1) {
        return this
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this
    };
  }

  /*  */

  function initMixin$1 (Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this
    };
  }

  /*  */

  function initExtend (Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId]
      }

      var name = extendOptions.name || Super.options.name;

      var Sub = function VueComponent (options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(
        Super.options,
        extendOptions
      );
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub
    };
  }

  function initProps$1 (Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1 (Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters (Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (
        id,
        definition
      ) {
        if (!definition) {
          return this.options[type + 's'][id]
        } else {
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition
        }
      };
    });
  }

  /*  */



  function getComponentName (opts) {
    return opts && (opts.Ctor.options.name || opts.tag)
  }

  function matches (pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1
    } else if (isRegExp(pattern)) {
      return pattern.test(name)
    }
    /* istanbul ignore next */
    return false
  }

  function pruneCache (keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry (
    cache,
    key,
    keys,
    current
  ) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created () {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed () {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted () {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) { return matches(val, name); });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) { return !matches(val, name); });
      });
    },

    render: function render () {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
          // not included
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
          : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || (slot && slot[0])
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI (Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
      observe(obj);
      return obj
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue$1);

  Object.defineProperty(Vue$1.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue$1.prototype, '$ssrContext', {
    get: function get () {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue$1, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue$1.version = '2.6.10';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function (tag, type, attr) {
    return (
      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
      (attr === 'selected' && tag === 'option') ||
      (attr === 'checked' && tag === 'input') ||
      (attr === 'muted' && tag === 'video')
    )
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
      ? 'false'
      // allow arbitrary string value for contenteditable
      : key === 'contenteditable' && isValidContentEditableValue(value)
        ? value
        : 'true'
  };

  var isBooleanAttr = makeMap(
    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,translate,' +
    'truespeed,typemustmatch,visible'
  );

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : ''
  };

  var isFalsyAttrValue = function (val) {
    return val == null || val === false
  };

  /*  */

  function genClassForVnode (vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class)
  }

  function mergeClassData (child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class)
        ? [child.class, parent.class]
        : parent.class
    }
  }

  function renderClass (
    staticClass,
    dynamicClass
  ) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass))
    }
    /* istanbul ignore next */
    return ''
  }

  function concat (a, b) {
    return a ? b ? (a + ' ' + b) : a : (b || '')
  }

  function stringifyClass (value) {
    if (Array.isArray(value)) {
      return stringifyArray(value)
    }
    if (isObject(value)) {
      return stringifyObject(value)
    }
    if (typeof value === 'string') {
      return value
    }
    /* istanbul ignore next */
    return ''
  }

  function stringifyArray (value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) { res += ' '; }
        res += stringified;
      }
    }
    return res
  }

  function stringifyObject (value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) { res += ' '; }
        res += key;
      }
    }
    return res
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap(
    'html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot'
  );

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap(
    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
    true
  );

  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag)
  };

  function getTagNamespace (tag) {
    if (isSVG(tag)) {
      return 'svg'
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math'
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement (tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true
    }
    if (isReservedTag(tag)) {
      return false
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag]
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return (unknownElementCache[tag] = (
        el.constructor === window.HTMLUnknownElement ||
        el.constructor === window.HTMLElement
      ))
    } else {
      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query (el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        return document.createElement('div')
      }
      return selected
    } else {
      return el
    }
  }

  /*  */

  function createElement$1 (tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm
  }

  function createElementNS (namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName)
  }

  function createTextNode (text) {
    return document.createTextNode(text)
  }

  function createComment (text) {
    return document.createComment(text)
  }

  function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild (node, child) {
    node.removeChild(child);
  }

  function appendChild (node, child) {
    node.appendChild(child);
  }

  function parentNode (node) {
    return node.parentNode
  }

  function nextSibling (node) {
    return node.nextSibling
  }

  function tagName (node) {
    return node.tagName
  }

  function setTextContent (node, text) {
    node.textContent = text;
  }

  function setStyleScope (node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create (_, vnode) {
      registerRef(vnode);
    },
    update: function update (oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy (vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef (vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) { return }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode (a, b) {
    return (
      a.key === b.key && (
        (
          a.tag === b.tag &&
          a.isComment === b.isComment &&
          isDef(a.data) === isDef(b.data) &&
          sameInputType(a, b)
        ) || (
          isTrue(a.isAsyncPlaceholder) &&
          a.asyncFactory === b.asyncFactory &&
          isUndef(b.asyncFactory.error)
        )
      )
    )
  }

  function sameInputType (a, b) {
    if (a.tag !== 'input') { return true }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
  }

  function createKeyToOldIdx (children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) { map[key] = i; }
    }
    return map
  }

  function createPatchFunction (backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt (elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
    }

    function createRmCb (childElm, listeners) {
      function remove$$1 () {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1
    }

    function removeNode (el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {

        vnode.elm = vnode.ns
          ? nodeOps.createElementNS(vnode.ns, tag)
          : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }

    function initComponent (vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert (parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren (vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable (vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag)
    }

    function invokeCreateHooks (vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) { i.create(emptyNode, vnode); }
        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope (vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) &&
        i !== vnode.context &&
        i !== vnode.fnContext &&
        isDef(i = i.$options._scopeId)
      ) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook (vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else { // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook (vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
          idxInOld = isDef(newStartVnode.key)
            ? oldKeyToIdx[newStartVnode.key]
            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) { // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function findIdxInOld (node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) { return i }
      }
    }

    function patchVnode (
      oldVnode,
      vnode,
      insertedVnodeQueue,
      ownerArray,
      index,
      removeOnly
    ) {
      if (oldVnode === vnode) {
        return
      }

      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // clone reused vnode
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) &&
        isTrue(oldVnode.isStatic) &&
        vnode.key === oldVnode.key &&
        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
      ) {
        vnode.componentInstance = oldVnode.componentInstance;
        return
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
      }
    }

    function invokeInsertHook (vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || (data && data.pre);
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                return false
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                return false
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true
    }

    return function patch (oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
        return
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm = nodeOps.parentNode(oldElm);

          // create new node
          createElm(
            vnode,
            insertedVnodeQueue,
            // extremely rare edge case: do not insert if old element is in a
            // leaving transition. Only happens when combining transition +
            // keep-alive + HOCs. (#4590)
            oldElm._leaveCb ? null : parentElm,
            nodeOps.nextSibling(oldElm)
          );

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm)) {
            removeVnodes(parentElm, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm
    }
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives (vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives (oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update (oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function () {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1 (
    dirs,
    vm
  ) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name);
    }
    // $flow-disable-line
    return res
  }

  function getRawDirName (dir) {
    return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
  }

  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
      }
    }
  }

  var baseModules = [
    ref,
    directives
  ];

  /*  */

  function updateAttrs (oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr (el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED'
          ? 'true'
          : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr (el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (
        isIE && !isIE9 &&
        el.tagName === 'TEXTAREA' &&
        key === 'placeholder' && value !== '' && !el.__ieph
      ) {
        var blocker = function (e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass (oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (
      isUndef(data.staticClass) &&
      isUndef(data.class) && (
        isUndef(oldData) || (
          isUndef(oldData.staticClass) &&
          isUndef(oldData.class)
        )
      )
    ) {
      return
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  /*  */

  /*  */

  /*  */

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents (on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler$1 (event, handler, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler () {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    }
  }

  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
  // implementation and does not fire microtasks in between event propagation, so
  // safe to exclude.
  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

  function add$1 (
    name,
    handler,
    capture,
    passive
  ) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;
      handler = original._wrapper = function (e) {
        if (
          // no bubbling, should always fire.
          // this is just a safety net in case event.timeStamp is unreliable in
          // certain weird environments...
          e.target === e.currentTarget ||
          // event is fired after handler attachment
          e.timeStamp >= attachedTimestamp ||
          // bail for environments that have buggy event.timeStamp implementations
          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
          // #9681 QtWebEngine event.timeStamp is negative value
          e.timeStamp <= 0 ||
          // #9448 bail if event is fired in another document in a multi-page
          // electron/nw.js app, since event.timeStamp will be using a different
          // starting reference
          e.target.ownerDocument !== document
        ) {
          return original.apply(this, arguments)
        }
      };
    }
    target$1.addEventListener(
      name,
      handler,
      supportsPassive
        ? { capture: capture, passive: passive }
        : capture
    );
  }

  function remove$2 (
    name,
    handler,
    capture,
    _target
  ) {
    (_target || target$1).removeEventListener(
      name,
      handler._wrapper || handler,
      capture
    );
  }

  function updateDOMListeners (oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  var svgContainer;

  function updateDOMProps (oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (!(key in props)) {
        elm[key] = '';
      }
    }

    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) { vnode.children.length = 0; }
        if (cur === oldProps[key]) { continue }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value' && elm.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        // IE doesn't support innerHTML for SVG elements
        svgContainer = svgContainer || document.createElement('div');
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;
        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }
        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecesarry `checked` update.
        cur !== oldProps[key]
      ) {
        // some property updates can throw
        // e.g. `value` on <progress> w/ non-finite value
        try {
          elm[key] = cur;
        } catch (e) {}
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue (elm, checkVal) {
    return (!elm.composing && (
      elm.tagName === 'OPTION' ||
      isNotInFocusAndDirty(elm, checkVal) ||
      isDirtyWithModifiers(elm, checkVal)
    ))
  }

  function isNotInFocusAndDirty (elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try { notInFocus = document.activeElement !== elm; } catch (e) {}
    return notInFocus && elm.value !== checkVal
  }

  function isDirtyWithModifiers (elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal)
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim()
      }
    }
    return value !== newVal
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData (data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle
      ? extend(data.staticStyle, style)
      : style
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding (bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle)
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle)
    }
    return bindingStyle
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle (vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (
          childNode && childNode.data &&
          (styleData = normalizeStyleData(childNode.data))
        ) {
          extend(res, styleData);
        }
      }
    }

    if ((styleData = normalizeStyleData(vnode.data))) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while ((parentNode = parentNode.parent)) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && (prop in emptyStyle)) {
      return prop
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name
      }
    }
  });

  function updateStyle (oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) &&
      isUndef(oldData.staticStyle) && isUndef(oldData.style)
    ) {
      return
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__)
      ? extend({}, style)
      : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  var whitespaceRE = /\s+/;

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition (def$$1) {
    if (!def$$1) {
      return
    }
    /* istanbul ignore else */
    if (typeof def$$1 === 'object') {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }
      extend(res, def$$1);
      return res
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1)
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: (name + "-enter"),
      enterToClass: (name + "-enter-to"),
      enterActiveClass: (name + "-enter-active"),
      leaveClass: (name + "-leave"),
      leaveToClass: (name + "-leave-to"),
      leaveActiveClass: (name + "-leave-active")
    }
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
      window.onwebkittransitionend !== undefined
    ) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
      window.onwebkitanimationend !== undefined
    ) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser
    ? window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : setTimeout
    : /* istanbul ignore next */ function (fn) { return fn(); };

  function nextFrame (fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass (el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass (el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds (
    el,
    expectedType,
    cb
  ) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) { return cb() }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function (e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo (el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0
        ? transitionTimeout > animationTimeout
          ? TRANSITION
          : ANIMATION
        : null;
      propCount = type
        ? type === TRANSITION
          ? transitionDurations.length
          : animationDurations.length
        : 0;
    }
    var hasTransform =
      type === TRANSITION &&
      transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    }
  }

  function getTimeout (delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i])
    }))
  }

  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
  // in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
  // as a floor function) causing unexpected behaviors
  function toMs (s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000
  }

  /*  */

  function enter (vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      context = transitionNode.context;
      transitionNode = transitionNode.parent;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return
    }

    var startClass = isAppear && appearClass
      ? appearClass
      : enterClass;
    var activeClass = isAppear && appearActiveClass
      ? appearActiveClass
      : enterActiveClass;
    var toClass = isAppear && appearToClass
      ? appearToClass
      : enterToClass;

    var beforeEnterHook = isAppear
      ? (beforeAppear || beforeEnter)
      : beforeEnter;
    var enterHook = isAppear
      ? (typeof appear === 'function' ? appear : enter)
      : enter;
    var afterEnterHook = isAppear
      ? (afterAppear || afterEnter)
      : afterEnter;
    var enterCancelledHook = isAppear
      ? (appearCancelled || enterCancelled)
      : enterCancelled;

    var explicitEnterDuration = toNumber(
      isObject(duration)
        ? duration.enter
        : duration
    );

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode &&
          pendingNode.tag === vnode.tag &&
          pendingNode.elm._leaveCb
        ) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave (vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm()
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(
      isObject(duration)
        ? duration.leave
        : duration
    );

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave () {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return
      }
      // record leaving element
      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  function isValidDuration (val) {
    return typeof val === 'number' && !isNaN(val)
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength (fn) {
    if (isUndef(fn)) {
      return false
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(
        Array.isArray(invokerFns)
          ? invokerFns[0]
          : invokerFns
      )
    } else {
      return (fn._length || fn.length) > 1
    }
  }

  function _enter (_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1 (vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
  ];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted (el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated (el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple
            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected (el, binding, vm) {
    actuallySetSelected(el, binding);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding);
      }, 0);
    }
  }

  function actuallySetSelected (el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      return
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption (value, options) {
    return options.every(function (o) { return !looseEqual(o, value); })
  }

  function getValue (option) {
    return '_value' in option
      ? option._value
      : option.value
  }

  function onCompositionStart (e) {
    e.target.composing = true;
  }

  function onCompositionEnd (e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) { return }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger (el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode (vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
      ? locateNode(vnode.componentInstance._vnode)
      : vnode
  }

  var show = {
    bind: function bind (el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay =
        el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update (el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) { return }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind (
      el,
      binding,
      vnode,
      oldVnode,
      isDestroy
    ) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show
  };

  /*  */

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild (vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children))
    } else {
      return vnode
    }
  }

  function extractTransitionData (comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data
  }

  function placeholder (h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      })
    }
  }

  function hasParentTransition (vnode) {
    while ((vnode = vnode.parent)) {
      if (vnode.data.transition) {
        return true
      }
    }
  }

  function isSameChild (child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag
  }

  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

  var isVShowDirective = function (d) { return d.name === 'show'; };

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render (h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(isNotTextNode);
      /* istanbul ignore if */
      if (!children.length) {
        return
      }

      var mode = this.mode;

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild
      }

      if (this._leaving) {
        return placeholder(h, rawChild)
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + (this._uid) + "-";
      child.key = child.key == null
        ? child.isComment
          ? id + 'comment'
          : id + child.tag
        : isPrimitive(child.key)
          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
          : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }

      if (
        oldChild &&
        oldChild.data &&
        !isSameChild(child, oldChild) &&
        !isAsyncPlaceholder(oldChild) &&
        // #6687 component root is a comment node
        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
      ) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild)
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild
          }
          var delayedLeave;
          var performLeave = function () { delayedLeave(); };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
        }
      }

      return rawChild
    }
  };

  /*  */

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    beforeMount: function beforeMount () {
      var this$1 = this;

      var update = this._update;
      this._update = function (vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1);
        // force removing pass
        this$1.__patch__(
          this$1._vnode,
          this$1.kept,
          false, // hydrating
          true // removeOnly (!important, avoids unnecessary moves)
        );
        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },

    render: function render (h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c
            ;(c.data || (c.data = {})).transition = transitionData;
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children)
    },

    updated: function updated () {
      var children = this.prevChildren;
      var moveClass = this.moveClass || ((this.name || 'v') + '-move');
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
            if (e && e.target !== el) {
              return
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove (el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return (this._hasMove = info.hasTransform)
      }
    }
  };

  function callPendingCbs (c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition (c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation (c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue$1.config.mustUseProp = mustUseProp;
  Vue$1.config.isReservedTag = isReservedTag;
  Vue$1.config.isReservedAttr = isReservedAttr;
  Vue$1.config.getTagNamespace = getTagNamespace;
  Vue$1.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue$1.options.directives, platformDirectives);
  extend(Vue$1.options.components, platformComponents);

  // install platform patch function
  Vue$1.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue$1.prototype.$mount = function (
    el,
    hydrating
  ) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue$1);
        }
      }
    }, 0);
  }

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent;

  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  function createInjector(context) {
    return function (id, style) {
      return addStyle(id, style);
    };
  }
  var HEAD;
  var styles = {};

  function addStyle(id, css) {
    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: new Set(),
      styles: []
    });

    if (!style.ids.has(id)) {
      style.ids.add(id);
      var code = css.source;

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (!style.element) {
        style.element = document.createElement('style');
        style.element.type = 'text/css';
        if (css.media) style.element.setAttribute('media', css.media);

        if (HEAD === undefined) {
          HEAD = document.head || document.getElementsByTagName('head')[0];
        }

        HEAD.appendChild(style.element);
      }

      if ('styleSheet' in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
      } else {
        var index = style.ids.size - 1;
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) style.element.removeChild(nodes[index]);
        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
      }
    }
  }

  var browser = createInjector;

  /* script */

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "container-full-width", attrs: { id: "cafeapp" } },
      [
        _c("div", { staticClass: "row", attrs: { id: "main" } }, [
          _c("div", { staticClass: "col-md-10 offset-md-1" }, [
            _c("div", { attrs: { id: "main_col" } }, [_c("router-view")], 1)
          ])
        ])
      ]
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = function (inject) {
      if (!inject) return
      inject("data-v-512b0576_0", { source: "\n#cafeapp {\n    font-family: 'Avenir', Helvetica, Arial, sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    color: #2c3e50;\n    margin-top: 5px;\n}\n#sidebar{\n   padding:5px;\n}\n#main{\n    height:100%;\n}\n#graph{\n    width: 100%;\n    height:100vh;\n    border: 1px solid black;\n}\n#query_input{\n    width:100%;\n}\n#main_col{\n}\nblockquote {\n    border-left: 4px solid #ccc;\n    padding-left: 1em;\n    color: #777;\n}\n\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/App.vue"],"names":[],"mappings":";AAmBA;IACA,mDAAA;IACA,mCAAA;IACA,kCAAA;IACA,cAAA;IACA,eAAA;AACA;AAEA;GACA,WAAA;AACA;AACA;IACA,WAAA;AACA;AAEA;IACA,WAAA;IACA,YAAA;IACA,uBAAA;AACA;AAEA;IACA,UAAA;AACA;AAEA;AACA;AAEA;IACA,2BAAA;IACA,iBAAA;IACA,WAAA;AACA","file":"App.vue","sourcesContent":["<template>\n    <div id=\"cafeapp\" class=\"container-full-width\">\n\t<div id=\"main\" class=\"row\">\n\t    <div class=\"col-md-10 offset-md-1\">\n\t\t<div id=\"main_col\">\n\t\t    <router-view></router-view>\n\t\t</div>\n\t    </div>\n\t    \n\t    <!-- <div class=\"col-md-3\">\n\t\t <node-filter />\n\t\t <history-display />\n\t\t </div> -->\n\t    \n\t</div>\n    </div>\n</template>\n\n<style>\n #cafeapp {\n     font-family: 'Avenir', Helvetica, Arial, sans-serif;\n     -webkit-font-smoothing: antialiased;\n     -moz-osx-font-smoothing: grayscale;\n     color: #2c3e50;\n     margin-top: 5px;\n }\n\n #sidebar{\n    padding:5px;\n }\n #main{\n     height:100%;\n }\n\n #graph{\n     width: 100%;\n     height:100vh;\n     border: 1px solid black;\n }\n\n #query_input{\n     width:100%;\n }\n\n #main_col{\n }\n\n blockquote {\n     border-left: 4px solid #ccc;\n     padding-left: 1em;\n     color: #777;\n }\n \n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject SSR */
    

    
    var App = normalizeComponent_1(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      {},
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      browser,
      undefined
    );

  /*!
    * vue-router v3.1.2
    * (c) 2019 Evan You
    * @license MIT
    */

  function isError (err) {
    return Object.prototype.toString.call(err).indexOf('Error') > -1
  }

  function isExtendedError (constructor, err) {
    return (
      err instanceof constructor ||
      // _name is to support IE9 too
      (err && (err.name === constructor.name || err._name === constructor._name))
    )
  }

  function extend$1 (a, b) {
    for (var key in b) {
      a[key] = b[key];
    }
    return a
  }

  var View = {
    name: 'RouterView',
    functional: true,
    props: {
      name: {
        type: String,
        default: 'default'
      }
    },
    render: function render (_, ref) {
      var props = ref.props;
      var children = ref.children;
      var parent = ref.parent;
      var data = ref.data;

      // used by devtools to display a router-view badge
      data.routerView = true;

      // directly use parent context's createElement() function
      // so that components rendered by router-view can resolve named slots
      var h = parent.$createElement;
      var name = props.name;
      var route = parent.$route;
      var cache = parent._routerViewCache || (parent._routerViewCache = {});

      // determine current view depth, also check to see if the tree
      // has been toggled inactive but kept-alive.
      var depth = 0;
      var inactive = false;
      while (parent && parent._routerRoot !== parent) {
        var vnodeData = parent.$vnode && parent.$vnode.data;
        if (vnodeData) {
          if (vnodeData.routerView) {
            depth++;
          }
          if (vnodeData.keepAlive && parent._inactive) {
            inactive = true;
          }
        }
        parent = parent.$parent;
      }
      data.routerViewDepth = depth;

      // render previous view if the tree is inactive and kept-alive
      if (inactive) {
        return h(cache[name], data, children)
      }

      var matched = route.matched[depth];
      // render empty node if no matched route
      if (!matched) {
        cache[name] = null;
        return h()
      }

      var component = cache[name] = matched.components[name];

      // attach instance registration hook
      // this will be called in the instance's injected lifecycle hooks
      data.registerRouteInstance = function (vm, val) {
        // val could be undefined for unregistration
        var current = matched.instances[name];
        if (
          (val && current !== vm) ||
          (!val && current === vm)
        ) {
          matched.instances[name] = val;
        }
      }

      // also register instance in prepatch hook
      // in case the same component instance is reused across different routes
      ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
        matched.instances[name] = vnode.componentInstance;
      };

      // register instance in init hook
      // in case kept-alive component be actived when routes changed
      data.hook.init = function (vnode) {
        if (vnode.data.keepAlive &&
          vnode.componentInstance &&
          vnode.componentInstance !== matched.instances[name]
        ) {
          matched.instances[name] = vnode.componentInstance;
        }
      };

      // resolve props
      var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
      if (propsToPass) {
        // clone to prevent mutation
        propsToPass = data.props = extend$1({}, propsToPass);
        // pass non-declared props as attrs
        var attrs = data.attrs = data.attrs || {};
        for (var key in propsToPass) {
          if (!component.props || !(key in component.props)) {
            attrs[key] = propsToPass[key];
            delete propsToPass[key];
          }
        }
      }

      return h(component, data, children)
    }
  };

  function resolveProps (route, config) {
    switch (typeof config) {
      case 'undefined':
        return
      case 'object':
        return config
      case 'function':
        return config(route)
      case 'boolean':
        return config ? route.params : undefined
    }
  }

  /*  */

  var encodeReserveRE = /[!'()*]/g;
  var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
  var commaRE = /%2C/g;

  // fixed encodeURIComponent which is more conformant to RFC3986:
  // - escapes [!'()*]
  // - preserve commas
  var encode = function (str) { return encodeURIComponent(str)
    .replace(encodeReserveRE, encodeReserveReplacer)
    .replace(commaRE, ','); };

  var decode = decodeURIComponent;

  function resolveQuery (
    query,
    extraQuery,
    _parseQuery
  ) {
    if ( extraQuery === void 0 ) extraQuery = {};

    var parse = _parseQuery || parseQuery;
    var parsedQuery;
    try {
      parsedQuery = parse(query || '');
    } catch (e) {
      parsedQuery = {};
    }
    for (var key in extraQuery) {
      parsedQuery[key] = extraQuery[key];
    }
    return parsedQuery
  }

  function parseQuery (query) {
    var res = {};

    query = query.trim().replace(/^(\?|#|&)/, '');

    if (!query) {
      return res
    }

    query.split('&').forEach(function (param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = decode(parts.shift());
      var val = parts.length > 0
        ? decode(parts.join('='))
        : null;

      if (res[key] === undefined) {
        res[key] = val;
      } else if (Array.isArray(res[key])) {
        res[key].push(val);
      } else {
        res[key] = [res[key], val];
      }
    });

    return res
  }

  function stringifyQuery (obj) {
    var res = obj ? Object.keys(obj).map(function (key) {
      var val = obj[key];

      if (val === undefined) {
        return ''
      }

      if (val === null) {
        return encode(key)
      }

      if (Array.isArray(val)) {
        var result = [];
        val.forEach(function (val2) {
          if (val2 === undefined) {
            return
          }
          if (val2 === null) {
            result.push(encode(key));
          } else {
            result.push(encode(key) + '=' + encode(val2));
          }
        });
        return result.join('&')
      }

      return encode(key) + '=' + encode(val)
    }).filter(function (x) { return x.length > 0; }).join('&') : null;
    return res ? ("?" + res) : ''
  }

  /*  */

  var trailingSlashRE = /\/?$/;

  function createRoute (
    record,
    location,
    redirectedFrom,
    router
  ) {
    var stringifyQuery$$1 = router && router.options.stringifyQuery;

    var query = location.query || {};
    try {
      query = clone(query);
    } catch (e) {}

    var route = {
      name: location.name || (record && record.name),
      meta: (record && record.meta) || {},
      path: location.path || '/',
      hash: location.hash || '',
      query: query,
      params: location.params || {},
      fullPath: getFullPath(location, stringifyQuery$$1),
      matched: record ? formatMatch(record) : []
    };
    if (redirectedFrom) {
      route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
    }
    return Object.freeze(route)
  }

  function clone (value) {
    if (Array.isArray(value)) {
      return value.map(clone)
    } else if (value && typeof value === 'object') {
      var res = {};
      for (var key in value) {
        res[key] = clone(value[key]);
      }
      return res
    } else {
      return value
    }
  }

  // the starting route that represents the initial state
  var START = createRoute(null, {
    path: '/'
  });

  function formatMatch (record) {
    var res = [];
    while (record) {
      res.unshift(record);
      record = record.parent;
    }
    return res
  }

  function getFullPath (
    ref,
    _stringifyQuery
  ) {
    var path = ref.path;
    var query = ref.query; if ( query === void 0 ) query = {};
    var hash = ref.hash; if ( hash === void 0 ) hash = '';

    var stringify = _stringifyQuery || stringifyQuery;
    return (path || '/') + stringify(query) + hash
  }

  function isSameRoute (a, b) {
    if (b === START) {
      return a === b
    } else if (!b) {
      return false
    } else if (a.path && b.path) {
      return (
        a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
        a.hash === b.hash &&
        isObjectEqual(a.query, b.query)
      )
    } else if (a.name && b.name) {
      return (
        a.name === b.name &&
        a.hash === b.hash &&
        isObjectEqual(a.query, b.query) &&
        isObjectEqual(a.params, b.params)
      )
    } else {
      return false
    }
  }

  function isObjectEqual (a, b) {
    if ( a === void 0 ) a = {};
    if ( b === void 0 ) b = {};

    // handle null value #1566
    if (!a || !b) { return a === b }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false
    }
    return aKeys.every(function (key) {
      var aVal = a[key];
      var bVal = b[key];
      // check nested equality
      if (typeof aVal === 'object' && typeof bVal === 'object') {
        return isObjectEqual(aVal, bVal)
      }
      return String(aVal) === String(bVal)
    })
  }

  function isIncludedRoute (current, target) {
    return (
      current.path.replace(trailingSlashRE, '/').indexOf(
        target.path.replace(trailingSlashRE, '/')
      ) === 0 &&
      (!target.hash || current.hash === target.hash) &&
      queryIncludes(current.query, target.query)
    )
  }

  function queryIncludes (current, target) {
    for (var key in target) {
      if (!(key in current)) {
        return false
      }
    }
    return true
  }

  /*  */

  function resolvePath (
    relative,
    base,
    append
  ) {
    var firstChar = relative.charAt(0);
    if (firstChar === '/') {
      return relative
    }

    if (firstChar === '?' || firstChar === '#') {
      return base + relative
    }

    var stack = base.split('/');

    // remove trailing segment if:
    // - not appending
    // - appending to trailing slash (last segment is empty)
    if (!append || !stack[stack.length - 1]) {
      stack.pop();
    }

    // resolve relative path
    var segments = relative.replace(/^\//, '').split('/');
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment === '..') {
        stack.pop();
      } else if (segment !== '.') {
        stack.push(segment);
      }
    }

    // ensure leading slash
    if (stack[0] !== '') {
      stack.unshift('');
    }

    return stack.join('/')
  }

  function parsePath$1 (path) {
    var hash = '';
    var query = '';

    var hashIndex = path.indexOf('#');
    if (hashIndex >= 0) {
      hash = path.slice(hashIndex);
      path = path.slice(0, hashIndex);
    }

    var queryIndex = path.indexOf('?');
    if (queryIndex >= 0) {
      query = path.slice(queryIndex + 1);
      path = path.slice(0, queryIndex);
    }

    return {
      path: path,
      query: query,
      hash: hash
    }
  }

  function cleanPath (path) {
    return path.replace(/\/\//g, '/')
  }

  var isarray = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };

  /**
   * Expose `pathToRegexp`.
   */
  var pathToRegexp_1 = pathToRegexp;
  var parse_1 = parse;
  var compile_1 = compile;
  var tokensToFunction_1 = tokensToFunction;
  var tokensToRegExp_1 = tokensToRegExp;

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
  ].join('|'), 'g');

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string}  str
   * @param  {Object=} options
   * @return {!Array}
   */
  function parse (str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = options && options.delimiter || '/';
    var res;

    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1];
        continue
      }

      var next = str[index];
      var prefix = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path);
        path = '';
      }

      var partial = prefix != null && next != null && next !== prefix;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = res[2] || defaultDelimiter;
      var pattern = capture || group;

      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
      });
    }

    // Match any characters still remaining.
    if (index < str.length) {
      path += str.substr(index);
    }

    // If the path exists, push it onto the end.
    if (path) {
      tokens.push(path);
    }

    return tokens
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @param  {Object=}            options
   * @return {!function(Object=, Object=)}
   */
  function compile (str, options) {
    return tokensToFunction(parse(str, options))
  }

  /**
   * Prettier encoding of URI path segments.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeURIComponentPretty (str) {
    return encodeURI(str).replace(/[\/?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }

  /**
   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeAsterisk (str) {
    return encodeURI(str).replace(/[?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length);

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (obj, opts) {
      var path = '';
      var data = obj || {};
      var options = opts || {};
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;

          continue
        }

        var value = data[token.name];
        var segment;

        if (value == null) {
          if (token.optional) {
            // Prepend partial segment prefixes.
            if (token.partial) {
              path += token.prefix;
            }

            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined')
          }
        }

        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
          }

          if (value.length === 0) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty')
            }
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue
        }

        segment = token.asterisk ? encodeAsterisk(value) : encode(value);

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
        }

        path += token.prefix + segment;
      }

      return path
    }
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1')
  }

  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {!RegExp} re
   * @param  {Array}   keys
   * @return {!RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys;
    return re
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i'
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {!Array}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }

    return attachKeys(path, keys)
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array}   keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

    return attachKeys(regexp, keys)
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {!Array}  keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    return tokensToRegExp(parse(path, options), keys, options)
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}          tokens
   * @param  {(Array|Object)=} keys
   * @param  {Object=}         options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, keys, options) {
    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys || options);
      keys = [];
    }

    options = options || {};

    var strict = options.strict;
    var end = options.end !== false;
    var route = '';

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
      } else {
        var prefix = escapeString(token.prefix);
        var capture = '(?:' + token.pattern + ')';

        keys.push(token);

        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*';
        }

        if (token.optional) {
          if (!token.partial) {
            capture = '(?:' + prefix + '(' + capture + '))?';
          } else {
            capture = prefix + '(' + capture + ')?';
          }
        } else {
          capture = prefix + '(' + capture + ')';
        }

        route += capture;
      }
    }

    var delimiter = escapeString(options.delimiter || '/');
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
    }

    if (end) {
      route += '$';
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
    }

    return attachKeys(new RegExp('^' + route, flags(options)), keys)
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {(Array|Object)=}       keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys || options);
      keys = [];
    }

    options = options || {};

    if (path instanceof RegExp) {
      return regexpToRegexp(path, /** @type {!Array} */ (keys))
    }

    if (isarray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
    }

    return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
  }
  pathToRegexp_1.parse = parse_1;
  pathToRegexp_1.compile = compile_1;
  pathToRegexp_1.tokensToFunction = tokensToFunction_1;
  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

  /*  */

  // $flow-disable-line
  var regexpCompileCache = Object.create(null);

  function fillParams (
    path,
    params,
    routeMsg
  ) {
    params = params || {};
    try {
      var filler =
        regexpCompileCache[path] ||
        (regexpCompileCache[path] = pathToRegexp_1.compile(path));

      // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
      if (params.pathMatch) { params[0] = params.pathMatch; }

      return filler(params, { pretty: true })
    } catch (e) {
      return ''
    } finally {
      // delete the 0 if it was added
      delete params[0];
    }
  }

  /*  */

  function normalizeLocation (
    raw,
    current,
    append,
    router
  ) {
    var next = typeof raw === 'string' ? { path: raw } : raw;
    // named target
    if (next._normalized) {
      return next
    } else if (next.name) {
      return extend$1({}, raw)
    }

    // relative params
    if (!next.path && next.params && current) {
      next = extend$1({}, next);
      next._normalized = true;
      var params = extend$1(extend$1({}, current.params), next.params);
      if (current.name) {
        next.name = current.name;
        next.params = params;
      } else if (current.matched.length) {
        var rawPath = current.matched[current.matched.length - 1].path;
        next.path = fillParams(rawPath, params, ("path " + (current.path)));
      }
      return next
    }

    var parsedPath = parsePath$1(next.path || '');
    var basePath = (current && current.path) || '/';
    var path = parsedPath.path
      ? resolvePath(parsedPath.path, basePath, append || next.append)
      : basePath;

    var query = resolveQuery(
      parsedPath.query,
      next.query,
      router && router.options.parseQuery
    );

    var hash = next.hash || parsedPath.hash;
    if (hash && hash.charAt(0) !== '#') {
      hash = "#" + hash;
    }

    return {
      _normalized: true,
      path: path,
      query: query,
      hash: hash
    }
  }

  /*  */

  // work around weird flow bug
  var toTypes = [String, Object];
  var eventTypes = [String, Array];

  var noop$1 = function () {};

  var Link = {
    name: 'RouterLink',
    props: {
      to: {
        type: toTypes,
        required: true
      },
      tag: {
        type: String,
        default: 'a'
      },
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      event: {
        type: eventTypes,
        default: 'click'
      }
    },
    render: function render (h) {
      var this$1 = this;

      var router = this.$router;
      var current = this.$route;
      var ref = router.resolve(
        this.to,
        current,
        this.append
      );
      var location = ref.location;
      var route = ref.route;
      var href = ref.href;

      var classes = {};
      var globalActiveClass = router.options.linkActiveClass;
      var globalExactActiveClass = router.options.linkExactActiveClass;
      // Support global empty active class
      var activeClassFallback =
        globalActiveClass == null ? 'router-link-active' : globalActiveClass;
      var exactActiveClassFallback =
        globalExactActiveClass == null
          ? 'router-link-exact-active'
          : globalExactActiveClass;
      var activeClass =
        this.activeClass == null ? activeClassFallback : this.activeClass;
      var exactActiveClass =
        this.exactActiveClass == null
          ? exactActiveClassFallback
          : this.exactActiveClass;

      var compareTarget = route.redirectedFrom
        ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)
        : route;

      classes[exactActiveClass] = isSameRoute(current, compareTarget);
      classes[activeClass] = this.exact
        ? classes[exactActiveClass]
        : isIncludedRoute(current, compareTarget);

      var handler = function (e) {
        if (guardEvent(e)) {
          if (this$1.replace) {
            router.replace(location, noop$1);
          } else {
            router.push(location, noop$1);
          }
        }
      };

      var on = { click: guardEvent };
      if (Array.isArray(this.event)) {
        this.event.forEach(function (e) {
          on[e] = handler;
        });
      } else {
        on[this.event] = handler;
      }

      var data = { class: classes };

      var scopedSlot =
        !this.$scopedSlots.$hasNormal &&
        this.$scopedSlots.default &&
        this.$scopedSlots.default({
          href: href,
          route: route,
          navigate: handler,
          isActive: classes[activeClass],
          isExactActive: classes[exactActiveClass]
        });

      if (scopedSlot) {
        if (scopedSlot.length === 1) {
          return scopedSlot[0]
        } else if (scopedSlot.length > 1 || !scopedSlot.length) {
          return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)
        }
      }

      if (this.tag === 'a') {
        data.on = on;
        data.attrs = { href: href };
      } else {
        // find the first <a> child and apply listener and href
        var a = findAnchor(this.$slots.default);
        if (a) {
          // in case the <a> is a static node
          a.isStatic = false;
          var aData = (a.data = extend$1({}, a.data));
          aData.on = on;
          var aAttrs = (a.data.attrs = extend$1({}, a.data.attrs));
          aAttrs.href = href;
        } else {
          // doesn't have <a> child, apply listener to self
          data.on = on;
        }
      }

      return h(this.tag, data, this.$slots.default)
    }
  };

  function guardEvent (e) {
    // don't redirect with control keys
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
    // don't redirect when preventDefault called
    if (e.defaultPrevented) { return }
    // don't redirect on right click
    if (e.button !== undefined && e.button !== 0) { return }
    // don't redirect if `target="_blank"`
    if (e.currentTarget && e.currentTarget.getAttribute) {
      var target = e.currentTarget.getAttribute('target');
      if (/\b_blank\b/i.test(target)) { return }
    }
    // this may be a Weex event which doesn't have this method
    if (e.preventDefault) {
      e.preventDefault();
    }
    return true
  }

  function findAnchor (children) {
    if (children) {
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        if (child.tag === 'a') {
          return child
        }
        if (child.children && (child = findAnchor(child.children))) {
          return child
        }
      }
    }
  }

  var _Vue;

  function install (Vue) {
    if (install.installed && _Vue === Vue) { return }
    install.installed = true;

    _Vue = Vue;

    var isDef = function (v) { return v !== undefined; };

    var registerInstance = function (vm, callVal) {
      var i = vm.$options._parentVnode;
      if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
        i(vm, callVal);
      }
    };

    Vue.mixin({
      beforeCreate: function beforeCreate () {
        if (isDef(this.$options.router)) {
          this._routerRoot = this;
          this._router = this.$options.router;
          this._router.init(this);
          Vue.util.defineReactive(this, '_route', this._router.history.current);
        } else {
          this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
        }
        registerInstance(this, this);
      },
      destroyed: function destroyed () {
        registerInstance(this);
      }
    });

    Object.defineProperty(Vue.prototype, '$router', {
      get: function get () { return this._routerRoot._router }
    });

    Object.defineProperty(Vue.prototype, '$route', {
      get: function get () { return this._routerRoot._route }
    });

    Vue.component('RouterView', View);
    Vue.component('RouterLink', Link);

    var strats = Vue.config.optionMergeStrategies;
    // use the same hook merging strategy for route hooks
    strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
  }

  /*  */

  var inBrowser$1 = typeof window !== 'undefined';

  /*  */

  function createRouteMap (
    routes,
    oldPathList,
    oldPathMap,
    oldNameMap
  ) {
    // the path list is used to control path matching priority
    var pathList = oldPathList || [];
    // $flow-disable-line
    var pathMap = oldPathMap || Object.create(null);
    // $flow-disable-line
    var nameMap = oldNameMap || Object.create(null);

    routes.forEach(function (route) {
      addRouteRecord(pathList, pathMap, nameMap, route);
    });

    // ensure wildcard routes are always at the end
    for (var i = 0, l = pathList.length; i < l; i++) {
      if (pathList[i] === '*') {
        pathList.push(pathList.splice(i, 1)[0]);
        l--;
        i--;
      }
    }

    return {
      pathList: pathList,
      pathMap: pathMap,
      nameMap: nameMap
    }
  }

  function addRouteRecord (
    pathList,
    pathMap,
    nameMap,
    route,
    parent,
    matchAs
  ) {
    var path = route.path;
    var name = route.name;

    var pathToRegexpOptions =
      route.pathToRegexpOptions || {};
    var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

    if (typeof route.caseSensitive === 'boolean') {
      pathToRegexpOptions.sensitive = route.caseSensitive;
    }

    var record = {
      path: normalizedPath,
      regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
      components: route.components || { default: route.component },
      instances: {},
      name: name,
      parent: parent,
      matchAs: matchAs,
      redirect: route.redirect,
      beforeEnter: route.beforeEnter,
      meta: route.meta || {},
      props:
        route.props == null
          ? {}
          : route.components
            ? route.props
            : { default: route.props }
    };

    if (route.children) {
      route.children.forEach(function (child) {
        var childMatchAs = matchAs
          ? cleanPath((matchAs + "/" + (child.path)))
          : undefined;
        addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
      });
    }

    if (!pathMap[record.path]) {
      pathList.push(record.path);
      pathMap[record.path] = record;
    }

    if (route.alias !== undefined) {
      var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
      for (var i = 0; i < aliases.length; ++i) {
        var alias = aliases[i];

        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(
          pathList,
          pathMap,
          nameMap,
          aliasRoute,
          parent,
          record.path || '/' // matchAs
        );
      }
    }

    if (name) {
      if (!nameMap[name]) {
        nameMap[name] = record;
      }
    }
  }

  function compileRouteRegex (
    path,
    pathToRegexpOptions
  ) {
    var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
    return regex
  }

  function normalizePath (
    path,
    parent,
    strict
  ) {
    if (!strict) { path = path.replace(/\/$/, ''); }
    if (path[0] === '/') { return path }
    if (parent == null) { return path }
    return cleanPath(((parent.path) + "/" + path))
  }

  /*  */



  function createMatcher (
    routes,
    router
  ) {
    var ref = createRouteMap(routes);
    var pathList = ref.pathList;
    var pathMap = ref.pathMap;
    var nameMap = ref.nameMap;

    function addRoutes (routes) {
      createRouteMap(routes, pathList, pathMap, nameMap);
    }

    function match (
      raw,
      currentRoute,
      redirectedFrom
    ) {
      var location = normalizeLocation(raw, currentRoute, false, router);
      var name = location.name;

      if (name) {
        var record = nameMap[name];
        if (!record) { return _createRoute(null, location) }
        var paramNames = record.regex.keys
          .filter(function (key) { return !key.optional; })
          .map(function (key) { return key.name; });

        if (typeof location.params !== 'object') {
          location.params = {};
        }

        if (currentRoute && typeof currentRoute.params === 'object') {
          for (var key in currentRoute.params) {
            if (!(key in location.params) && paramNames.indexOf(key) > -1) {
              location.params[key] = currentRoute.params[key];
            }
          }
        }

        location.path = fillParams(record.path, location.params);
        return _createRoute(record, location, redirectedFrom)
      } else if (location.path) {
        location.params = {};
        for (var i = 0; i < pathList.length; i++) {
          var path = pathList[i];
          var record$1 = pathMap[path];
          if (matchRoute(record$1.regex, location.path, location.params)) {
            return _createRoute(record$1, location, redirectedFrom)
          }
        }
      }
      // no match
      return _createRoute(null, location)
    }

    function redirect (
      record,
      location
    ) {
      var originalRedirect = record.redirect;
      var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location, null, router))
        : originalRedirect;

      if (typeof redirect === 'string') {
        redirect = { path: redirect };
      }

      if (!redirect || typeof redirect !== 'object') {
        return _createRoute(null, location)
      }

      var re = redirect;
      var name = re.name;
      var path = re.path;
      var query = location.query;
      var hash = location.hash;
      var params = location.params;
      query = re.hasOwnProperty('query') ? re.query : query;
      hash = re.hasOwnProperty('hash') ? re.hash : hash;
      params = re.hasOwnProperty('params') ? re.params : params;

      if (name) {
        // resolved named direct
        var targetRecord = nameMap[name];
        return match({
          _normalized: true,
          name: name,
          query: query,
          hash: hash,
          params: params
        }, undefined, location)
      } else if (path) {
        // 1. resolve relative redirect
        var rawPath = resolveRecordPath(path, record);
        // 2. resolve params
        var resolvedPath = fillParams(rawPath, params);
        // 3. rematch with existing query and hash
        return match({
          _normalized: true,
          path: resolvedPath,
          query: query,
          hash: hash
        }, undefined, location)
      } else {
        return _createRoute(null, location)
      }
    }

    function alias (
      record,
      location,
      matchAs
    ) {
      var aliasedPath = fillParams(matchAs, location.params);
      var aliasedMatch = match({
        _normalized: true,
        path: aliasedPath
      });
      if (aliasedMatch) {
        var matched = aliasedMatch.matched;
        var aliasedRecord = matched[matched.length - 1];
        location.params = aliasedMatch.params;
        return _createRoute(aliasedRecord, location)
      }
      return _createRoute(null, location)
    }

    function _createRoute (
      record,
      location,
      redirectedFrom
    ) {
      if (record && record.redirect) {
        return redirect(record, redirectedFrom || location)
      }
      if (record && record.matchAs) {
        return alias(record, location, record.matchAs)
      }
      return createRoute(record, location, redirectedFrom, router)
    }

    return {
      match: match,
      addRoutes: addRoutes
    }
  }

  function matchRoute (
    regex,
    path,
    params
  ) {
    var m = path.match(regex);

    if (!m) {
      return false
    } else if (!params) {
      return true
    }

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = regex.keys[i - 1];
      var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
      if (key) {
        // Fix #1994: using * with props: true generates a param named 0
        params[key.name || 'pathMatch'] = val;
      }
    }

    return true
  }

  function resolveRecordPath (path, record) {
    return resolvePath(path, record.parent ? record.parent.path : '/', true)
  }

  /*  */

  var positionStore = Object.create(null);

  function setupScroll () {
    // Fix for #1585 for Firefox
    // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
    // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
    // window.location.protocol + '//' + window.location.host
    // location.host contains the port and location.hostname doesn't
    var protocolAndPath = window.location.protocol + '//' + window.location.host;
    var absolutePath = window.location.href.replace(protocolAndPath, '');
    window.history.replaceState({ key: getStateKey() }, '', absolutePath);
    window.addEventListener('popstate', function (e) {
      saveScrollPosition();
      if (e.state && e.state.key) {
        setStateKey(e.state.key);
      }
    });
  }

  function handleScroll (
    router,
    to,
    from,
    isPop
  ) {
    if (!router.app) {
      return
    }

    var behavior = router.options.scrollBehavior;
    if (!behavior) {
      return
    }

    // wait until re-render finishes before scrolling
    router.app.$nextTick(function () {
      var position = getScrollPosition();
      var shouldScroll = behavior.call(
        router,
        to,
        from,
        isPop ? position : null
      );

      if (!shouldScroll) {
        return
      }

      if (typeof shouldScroll.then === 'function') {
        shouldScroll
          .then(function (shouldScroll) {
            scrollToPosition((shouldScroll), position);
          })
          .catch(function (err) {
          });
      } else {
        scrollToPosition(shouldScroll, position);
      }
    });
  }

  function saveScrollPosition () {
    var key = getStateKey();
    if (key) {
      positionStore[key] = {
        x: window.pageXOffset,
        y: window.pageYOffset
      };
    }
  }

  function getScrollPosition () {
    var key = getStateKey();
    if (key) {
      return positionStore[key]
    }
  }

  function getElementPosition (el, offset) {
    var docEl = document.documentElement;
    var docRect = docEl.getBoundingClientRect();
    var elRect = el.getBoundingClientRect();
    return {
      x: elRect.left - docRect.left - offset.x,
      y: elRect.top - docRect.top - offset.y
    }
  }

  function isValidPosition (obj) {
    return isNumber(obj.x) || isNumber(obj.y)
  }

  function normalizePosition (obj) {
    return {
      x: isNumber(obj.x) ? obj.x : window.pageXOffset,
      y: isNumber(obj.y) ? obj.y : window.pageYOffset
    }
  }

  function normalizeOffset (obj) {
    return {
      x: isNumber(obj.x) ? obj.x : 0,
      y: isNumber(obj.y) ? obj.y : 0
    }
  }

  function isNumber (v) {
    return typeof v === 'number'
  }

  var hashStartsWithNumberRE = /^#\d/;

  function scrollToPosition (shouldScroll, position) {
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
      // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
      var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
        ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
        : document.querySelector(shouldScroll.selector);

      if (el) {
        var offset =
          shouldScroll.offset && typeof shouldScroll.offset === 'object'
            ? shouldScroll.offset
            : {};
        offset = normalizeOffset(offset);
        position = getElementPosition(el, offset);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  }

  /*  */

  var supportsPushState = inBrowser$1 && (function () {
    var ua = window.navigator.userAgent;

    if (
      (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
      ua.indexOf('Mobile Safari') !== -1 &&
      ua.indexOf('Chrome') === -1 &&
      ua.indexOf('Windows Phone') === -1
    ) {
      return false
    }

    return window.history && 'pushState' in window.history
  })();

  // use User Timing api (if present) for more accurate key precision
  var Time = inBrowser$1 && window.performance && window.performance.now
    ? window.performance
    : Date;

  var _key = genKey();

  function genKey () {
    return Time.now().toFixed(3)
  }

  function getStateKey () {
    return _key
  }

  function setStateKey (key) {
    _key = key;
  }

  function pushState (url, replace) {
    saveScrollPosition();
    // try...catch the pushState call to get around Safari
    // DOM Exception 18 where it limits to 100 pushState calls
    var history = window.history;
    try {
      if (replace) {
        history.replaceState({ key: _key }, '', url);
      } else {
        _key = genKey();
        history.pushState({ key: _key }, '', url);
      }
    } catch (e) {
      window.location[replace ? 'replace' : 'assign'](url);
    }
  }

  function replaceState (url) {
    pushState(url, true);
  }

  /*  */

  function runQueue (queue, fn, cb) {
    var step = function (index) {
      if (index >= queue.length) {
        cb();
      } else {
        if (queue[index]) {
          fn(queue[index], function () {
            step(index + 1);
          });
        } else {
          step(index + 1);
        }
      }
    };
    step(0);
  }

  /*  */

  function resolveAsyncComponents (matched) {
    return function (to, from, next) {
      var hasAsync = false;
      var pending = 0;
      var error = null;

      flatMapComponents(matched, function (def, _, match, key) {
        // if it's a function and doesn't have cid attached,
        // assume it's an async component resolve function.
        // we are not using Vue's default async resolving mechanism because
        // we want to halt the navigation until the incoming component has been
        // resolved.
        if (typeof def === 'function' && def.cid === undefined) {
          hasAsync = true;
          pending++;

          var resolve = once$1(function (resolvedDef) {
            if (isESModule(resolvedDef)) {
              resolvedDef = resolvedDef.default;
            }
            // save resolved on async factory in case it's used elsewhere
            def.resolved = typeof resolvedDef === 'function'
              ? resolvedDef
              : _Vue.extend(resolvedDef);
            match.components[key] = resolvedDef;
            pending--;
            if (pending <= 0) {
              next();
            }
          });

          var reject = once$1(function (reason) {
            var msg = "Failed to resolve async component " + key + ": " + reason;
            if (!error) {
              error = isError(reason)
                ? reason
                : new Error(msg);
              next(error);
            }
          });

          var res;
          try {
            res = def(resolve, reject);
          } catch (e) {
            reject(e);
          }
          if (res) {
            if (typeof res.then === 'function') {
              res.then(resolve, reject);
            } else {
              // new syntax in Vue 2.3
              var comp = res.component;
              if (comp && typeof comp.then === 'function') {
                comp.then(resolve, reject);
              }
            }
          }
        }
      });

      if (!hasAsync) { next(); }
    }
  }

  function flatMapComponents (
    matched,
    fn
  ) {
    return flatten(matched.map(function (m) {
      return Object.keys(m.components).map(function (key) { return fn(
        m.components[key],
        m.instances[key],
        m, key
      ); })
    }))
  }

  function flatten (arr) {
    return Array.prototype.concat.apply([], arr)
  }

  var hasSymbol$1 =
    typeof Symbol === 'function' &&
    typeof Symbol.toStringTag === 'symbol';

  function isESModule (obj) {
    return obj.__esModule || (hasSymbol$1 && obj[Symbol.toStringTag] === 'Module')
  }

  // in Webpack 2, require.ensure now also returns a Promise
  // so the resolve/reject functions may get called an extra time
  // if the user uses an arrow function shorthand that happens to
  // return that Promise.
  function once$1 (fn) {
    var called = false;
    return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (called) { return }
      called = true;
      return fn.apply(this, args)
    }
  }

  var NavigationDuplicated = /*@__PURE__*/(function (Error) {
    function NavigationDuplicated () {
      Error.call(this, 'Navigating to current location is not allowed');
      this.name = this._name = 'NavigationDuplicated';
    }

    if ( Error ) NavigationDuplicated.__proto__ = Error;
    NavigationDuplicated.prototype = Object.create( Error && Error.prototype );
    NavigationDuplicated.prototype.constructor = NavigationDuplicated;

    return NavigationDuplicated;
  }(Error));

  // support IE9
  NavigationDuplicated._name = 'NavigationDuplicated';

  /*  */

  var History = function History (router, base) {
    this.router = router;
    this.base = normalizeBase(base);
    // start with a route object that stands for "nowhere"
    this.current = START;
    this.pending = null;
    this.ready = false;
    this.readyCbs = [];
    this.readyErrorCbs = [];
    this.errorCbs = [];
  };

  History.prototype.listen = function listen (cb) {
    this.cb = cb;
  };

  History.prototype.onReady = function onReady (cb, errorCb) {
    if (this.ready) {
      cb();
    } else {
      this.readyCbs.push(cb);
      if (errorCb) {
        this.readyErrorCbs.push(errorCb);
      }
    }
  };

  History.prototype.onError = function onError (errorCb) {
    this.errorCbs.push(errorCb);
  };

  History.prototype.transitionTo = function transitionTo (
    location,
    onComplete,
    onAbort
  ) {
      var this$1 = this;

    var route = this.router.match(location, this.current);
    this.confirmTransition(
      route,
      function () {
        this$1.updateRoute(route);
        onComplete && onComplete(route);
        this$1.ensureURL();

        // fire ready cbs once
        if (!this$1.ready) {
          this$1.ready = true;
          this$1.readyCbs.forEach(function (cb) {
            cb(route);
          });
        }
      },
      function (err) {
        if (onAbort) {
          onAbort(err);
        }
        if (err && !this$1.ready) {
          this$1.ready = true;
          this$1.readyErrorCbs.forEach(function (cb) {
            cb(err);
          });
        }
      }
    );
  };

  History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
      var this$1 = this;

    var current = this.current;
    var abort = function (err) {
      // after merging https://github.com/vuejs/vue-router/pull/2771 we
      // When the user navigates through history through back/forward buttons
      // we do not want to throw the error. We only throw it if directly calling
      // push/replace. That's why it's not included in isError
      if (!isExtendedError(NavigationDuplicated, err) && isError(err)) {
        if (this$1.errorCbs.length) {
          this$1.errorCbs.forEach(function (cb) {
            cb(err);
          });
        } else {
          console.error(err);
        }
      }
      onAbort && onAbort(err);
    };
    if (
      isSameRoute(route, current) &&
      // in the case the route map has been dynamically appended to
      route.matched.length === current.matched.length
    ) {
      this.ensureURL();
      return abort(new NavigationDuplicated(route))
    }

    var ref = resolveQueue(
      this.current.matched,
      route.matched
    );
      var updated = ref.updated;
      var deactivated = ref.deactivated;
      var activated = ref.activated;

    var queue = [].concat(
      // in-component leave guards
      extractLeaveGuards(deactivated),
      // global before hooks
      this.router.beforeHooks,
      // in-component update hooks
      extractUpdateHooks(updated),
      // in-config enter guards
      activated.map(function (m) { return m.beforeEnter; }),
      // async components
      resolveAsyncComponents(activated)
    );

    this.pending = route;
    var iterator = function (hook, next) {
      if (this$1.pending !== route) {
        return abort()
      }
      try {
        hook(route, current, function (to) {
          if (to === false || isError(to)) {
            // next(false) -> abort navigation, ensure current URL
            this$1.ensureURL(true);
            abort(to);
          } else if (
            typeof to === 'string' ||
            (typeof to === 'object' &&
              (typeof to.path === 'string' || typeof to.name === 'string'))
          ) {
            // next('/') or next({ path: '/' }) -> redirect
            abort();
            if (typeof to === 'object' && to.replace) {
              this$1.replace(to);
            } else {
              this$1.push(to);
            }
          } else {
            // confirm transition and pass on the value
            next(to);
          }
        });
      } catch (e) {
        abort(e);
      }
    };

    runQueue(queue, iterator, function () {
      var postEnterCbs = [];
      var isValid = function () { return this$1.current === route; };
      // wait until async components are resolved before
      // extracting in-component enter guards
      var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
      var queue = enterGuards.concat(this$1.router.resolveHooks);
      runQueue(queue, iterator, function () {
        if (this$1.pending !== route) {
          return abort()
        }
        this$1.pending = null;
        onComplete(route);
        if (this$1.router.app) {
          this$1.router.app.$nextTick(function () {
            postEnterCbs.forEach(function (cb) {
              cb();
            });
          });
        }
      });
    });
  };

  History.prototype.updateRoute = function updateRoute (route) {
    var prev = this.current;
    this.current = route;
    this.cb && this.cb(route);
    this.router.afterHooks.forEach(function (hook) {
      hook && hook(route, prev);
    });
  };

  function normalizeBase (base) {
    if (!base) {
      if (inBrowser$1) {
        // respect <base> tag
        var baseEl = document.querySelector('base');
        base = (baseEl && baseEl.getAttribute('href')) || '/';
        // strip full URL origin
        base = base.replace(/^https?:\/\/[^\/]+/, '');
      } else {
        base = '/';
      }
    }
    // make sure there's the starting slash
    if (base.charAt(0) !== '/') {
      base = '/' + base;
    }
    // remove trailing slash
    return base.replace(/\/$/, '')
  }

  function resolveQueue (
    current,
    next
  ) {
    var i;
    var max = Math.max(current.length, next.length);
    for (i = 0; i < max; i++) {
      if (current[i] !== next[i]) {
        break
      }
    }
    return {
      updated: next.slice(0, i),
      activated: next.slice(i),
      deactivated: current.slice(i)
    }
  }

  function extractGuards (
    records,
    name,
    bind,
    reverse
  ) {
    var guards = flatMapComponents(records, function (def, instance, match, key) {
      var guard = extractGuard(def, name);
      if (guard) {
        return Array.isArray(guard)
          ? guard.map(function (guard) { return bind(guard, instance, match, key); })
          : bind(guard, instance, match, key)
      }
    });
    return flatten(reverse ? guards.reverse() : guards)
  }

  function extractGuard (
    def,
    key
  ) {
    if (typeof def !== 'function') {
      // extend now so that global mixins are applied.
      def = _Vue.extend(def);
    }
    return def.options[key]
  }

  function extractLeaveGuards (deactivated) {
    return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
  }

  function extractUpdateHooks (updated) {
    return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
  }

  function bindGuard (guard, instance) {
    if (instance) {
      return function boundRouteGuard () {
        return guard.apply(instance, arguments)
      }
    }
  }

  function extractEnterGuards (
    activated,
    cbs,
    isValid
  ) {
    return extractGuards(
      activated,
      'beforeRouteEnter',
      function (guard, _, match, key) {
        return bindEnterGuard(guard, match, key, cbs, isValid)
      }
    )
  }

  function bindEnterGuard (
    guard,
    match,
    key,
    cbs,
    isValid
  ) {
    return function routeEnterGuard (to, from, next) {
      return guard(to, from, function (cb) {
        if (typeof cb === 'function') {
          cbs.push(function () {
            // #750
            // if a router-view is wrapped with an out-in transition,
            // the instance may not have been registered at this time.
            // we will need to poll for registration until current route
            // is no longer valid.
            poll(cb, match.instances, key, isValid);
          });
        }
        next(cb);
      })
    }
  }

  function poll (
    cb, // somehow flow cannot infer this is a function
    instances,
    key,
    isValid
  ) {
    if (
      instances[key] &&
      !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
    ) {
      cb(instances[key]);
    } else if (isValid()) {
      setTimeout(function () {
        poll(cb, instances, key, isValid);
      }, 16);
    }
  }

  /*  */

  var HTML5History = /*@__PURE__*/(function (History$$1) {
    function HTML5History (router, base) {
      var this$1 = this;

      History$$1.call(this, router, base);

      var expectScroll = router.options.scrollBehavior;
      var supportsScroll = supportsPushState && expectScroll;

      if (supportsScroll) {
        setupScroll();
      }

      var initLocation = getLocation(this.base);
      window.addEventListener('popstate', function (e) {
        var current = this$1.current;

        // Avoiding first `popstate` event dispatched in some browsers but first
        // history route not updated since async guard at the same time.
        var location = getLocation(this$1.base);
        if (this$1.current === START && location === initLocation) {
          return
        }

        this$1.transitionTo(location, function (route) {
          if (supportsScroll) {
            handleScroll(router, route, current, true);
          }
        });
      });
    }

    if ( History$$1 ) HTML5History.__proto__ = History$$1;
    HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
    HTML5History.prototype.constructor = HTML5History;

    HTML5History.prototype.go = function go (n) {
      window.history.go(n);
    };

    HTML5History.prototype.push = function push (location, onComplete, onAbort) {
      var this$1 = this;

      var ref = this;
      var fromRoute = ref.current;
      this.transitionTo(location, function (route) {
        pushState(cleanPath(this$1.base + route.fullPath));
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      }, onAbort);
    };

    HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
      var this$1 = this;

      var ref = this;
      var fromRoute = ref.current;
      this.transitionTo(location, function (route) {
        replaceState(cleanPath(this$1.base + route.fullPath));
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      }, onAbort);
    };

    HTML5History.prototype.ensureURL = function ensureURL (push) {
      if (getLocation(this.base) !== this.current.fullPath) {
        var current = cleanPath(this.base + this.current.fullPath);
        push ? pushState(current) : replaceState(current);
      }
    };

    HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
      return getLocation(this.base)
    };

    return HTML5History;
  }(History));

  function getLocation (base) {
    var path = decodeURI(window.location.pathname);
    if (base && path.indexOf(base) === 0) {
      path = path.slice(base.length);
    }
    return (path || '/') + window.location.search + window.location.hash
  }

  /*  */

  var HashHistory = /*@__PURE__*/(function (History$$1) {
    function HashHistory (router, base, fallback) {
      History$$1.call(this, router, base);
      // check history fallback deeplinking
      if (fallback && checkFallback(this.base)) {
        return
      }
      ensureSlash();
    }

    if ( History$$1 ) HashHistory.__proto__ = History$$1;
    HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
    HashHistory.prototype.constructor = HashHistory;

    // this is delayed until the app mounts
    // to avoid the hashchange listener being fired too early
    HashHistory.prototype.setupListeners = function setupListeners () {
      var this$1 = this;

      var router = this.router;
      var expectScroll = router.options.scrollBehavior;
      var supportsScroll = supportsPushState && expectScroll;

      if (supportsScroll) {
        setupScroll();
      }

      window.addEventListener(
        supportsPushState ? 'popstate' : 'hashchange',
        function () {
          var current = this$1.current;
          if (!ensureSlash()) {
            return
          }
          this$1.transitionTo(getHash(), function (route) {
            if (supportsScroll) {
              handleScroll(this$1.router, route, current, true);
            }
            if (!supportsPushState) {
              replaceHash(route.fullPath);
            }
          });
        }
      );
    };

    HashHistory.prototype.push = function push (location, onComplete, onAbort) {
      var this$1 = this;

      var ref = this;
      var fromRoute = ref.current;
      this.transitionTo(
        location,
        function (route) {
          pushHash(route.fullPath);
          handleScroll(this$1.router, route, fromRoute, false);
          onComplete && onComplete(route);
        },
        onAbort
      );
    };

    HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
      var this$1 = this;

      var ref = this;
      var fromRoute = ref.current;
      this.transitionTo(
        location,
        function (route) {
          replaceHash(route.fullPath);
          handleScroll(this$1.router, route, fromRoute, false);
          onComplete && onComplete(route);
        },
        onAbort
      );
    };

    HashHistory.prototype.go = function go (n) {
      window.history.go(n);
    };

    HashHistory.prototype.ensureURL = function ensureURL (push) {
      var current = this.current.fullPath;
      if (getHash() !== current) {
        push ? pushHash(current) : replaceHash(current);
      }
    };

    HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
      return getHash()
    };

    return HashHistory;
  }(History));

  function checkFallback (base) {
    var location = getLocation(base);
    if (!/^\/#/.test(location)) {
      window.location.replace(cleanPath(base + '/#' + location));
      return true
    }
  }

  function ensureSlash () {
    var path = getHash();
    if (path.charAt(0) === '/') {
      return true
    }
    replaceHash('/' + path);
    return false
  }

  function getHash () {
    // We can't use window.location.hash here because it's not
    // consistent across browsers - Firefox will pre-decode it!
    var href = window.location.href;
    var index = href.indexOf('#');
    // empty path
    if (index < 0) { return '' }

    href = href.slice(index + 1);
    // decode the hash but not the search or hash
    // as search(query) is already decoded
    // https://github.com/vuejs/vue-router/issues/2708
    var searchIndex = href.indexOf('?');
    if (searchIndex < 0) {
      var hashIndex = href.indexOf('#');
      if (hashIndex > -1) {
        href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex);
      } else { href = decodeURI(href); }
    } else {
      if (searchIndex > -1) {
        href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex);
      }
    }

    return href
  }

  function getUrl (path) {
    var href = window.location.href;
    var i = href.indexOf('#');
    var base = i >= 0 ? href.slice(0, i) : href;
    return (base + "#" + path)
  }

  function pushHash (path) {
    if (supportsPushState) {
      pushState(getUrl(path));
    } else {
      window.location.hash = path;
    }
  }

  function replaceHash (path) {
    if (supportsPushState) {
      replaceState(getUrl(path));
    } else {
      window.location.replace(getUrl(path));
    }
  }

  /*  */

  var AbstractHistory = /*@__PURE__*/(function (History$$1) {
    function AbstractHistory (router, base) {
      History$$1.call(this, router, base);
      this.stack = [];
      this.index = -1;
    }

    if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
    AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
    AbstractHistory.prototype.constructor = AbstractHistory;

    AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
      var this$1 = this;

      this.transitionTo(
        location,
        function (route) {
          this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
          this$1.index++;
          onComplete && onComplete(route);
        },
        onAbort
      );
    };

    AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
      var this$1 = this;

      this.transitionTo(
        location,
        function (route) {
          this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
          onComplete && onComplete(route);
        },
        onAbort
      );
    };

    AbstractHistory.prototype.go = function go (n) {
      var this$1 = this;

      var targetIndex = this.index + n;
      if (targetIndex < 0 || targetIndex >= this.stack.length) {
        return
      }
      var route = this.stack[targetIndex];
      this.confirmTransition(
        route,
        function () {
          this$1.index = targetIndex;
          this$1.updateRoute(route);
        },
        function (err) {
          if (isExtendedError(NavigationDuplicated, err)) {
            this$1.index = targetIndex;
          }
        }
      );
    };

    AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
      var current = this.stack[this.stack.length - 1];
      return current ? current.fullPath : '/'
    };

    AbstractHistory.prototype.ensureURL = function ensureURL () {
      // noop
    };

    return AbstractHistory;
  }(History));

  /*  */



  var VueRouter = function VueRouter (options) {
    if ( options === void 0 ) options = {};

    this.app = null;
    this.apps = [];
    this.options = options;
    this.beforeHooks = [];
    this.resolveHooks = [];
    this.afterHooks = [];
    this.matcher = createMatcher(options.routes || [], this);

    var mode = options.mode || 'hash';
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
    if (this.fallback) {
      mode = 'hash';
    }
    if (!inBrowser$1) {
      mode = 'abstract';
    }
    this.mode = mode;

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base);
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback);
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base);
        break
    }
  };

  var prototypeAccessors$1 = { currentRoute: { configurable: true } };

  VueRouter.prototype.match = function match (
    raw,
    current,
    redirectedFrom
  ) {
    return this.matcher.match(raw, current, redirectedFrom)
  };

  prototypeAccessors$1.currentRoute.get = function () {
    return this.history && this.history.current
  };

  VueRouter.prototype.init = function init (app /* Vue component instance */) {
      var this$1 = this;

    this.apps.push(app);

    // set up app destroyed handler
    // https://github.com/vuejs/vue-router/issues/2639
    app.$once('hook:destroyed', function () {
      // clean out app from this.apps array once destroyed
      var index = this$1.apps.indexOf(app);
      if (index > -1) { this$1.apps.splice(index, 1); }
      // ensure we still have a main app or null if no apps
      // we do not release the router so it can be reused
      if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }
    });

    // main app previously initialized
    // return as we don't need to set up new history listener
    if (this.app) {
      return
    }

    this.app = app;

    var history = this.history;

    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation());
    } else if (history instanceof HashHistory) {
      var setupHashListener = function () {
        history.setupListeners();
      };
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      );
    }

    history.listen(function (route) {
      this$1.apps.forEach(function (app) {
        app._route = route;
      });
    });
  };

  VueRouter.prototype.beforeEach = function beforeEach (fn) {
    return registerHook(this.beforeHooks, fn)
  };

  VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
    return registerHook(this.resolveHooks, fn)
  };

  VueRouter.prototype.afterEach = function afterEach (fn) {
    return registerHook(this.afterHooks, fn)
  };

  VueRouter.prototype.onReady = function onReady (cb, errorCb) {
    this.history.onReady(cb, errorCb);
  };

  VueRouter.prototype.onError = function onError (errorCb) {
    this.history.onError(errorCb);
  };

  VueRouter.prototype.push = function push (location, onComplete, onAbort) {
      var this$1 = this;

    // $flow-disable-line
    if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        this$1.history.push(location, resolve, reject);
      })
    } else {
      this.history.push(location, onComplete, onAbort);
    }
  };

  VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
      var this$1 = this;

    // $flow-disable-line
    if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        this$1.history.replace(location, resolve, reject);
      })
    } else {
      this.history.replace(location, onComplete, onAbort);
    }
  };

  VueRouter.prototype.go = function go (n) {
    this.history.go(n);
  };

  VueRouter.prototype.back = function back () {
    this.go(-1);
  };

  VueRouter.prototype.forward = function forward () {
    this.go(1);
  };

  VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
    var route = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute;
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(function (m) {
      return Object.keys(m.components).map(function (key) {
        return m.components[key]
      })
    }))
  };

  VueRouter.prototype.resolve = function resolve (
    to,
    current,
    append
  ) {
    current = current || this.history.current;
    var location = normalizeLocation(
      to,
      current,
      append,
      this
    );
    var route = this.match(location, current);
    var fullPath = route.redirectedFrom || route.fullPath;
    var base = this.history.base;
    var href = createHref(base, fullPath, this.mode);
    return {
      location: location,
      route: route,
      href: href,
      // for backwards compat
      normalizedTo: location,
      resolved: route
    }
  };

  VueRouter.prototype.addRoutes = function addRoutes (routes) {
    this.matcher.addRoutes(routes);
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation());
    }
  };

  Object.defineProperties( VueRouter.prototype, prototypeAccessors$1 );

  function registerHook (list, fn) {
    list.push(fn);
    return function () {
      var i = list.indexOf(fn);
      if (i > -1) { list.splice(i, 1); }
    }
  }

  function createHref (base, fullPath, mode) {
    var path = mode === 'hash' ? '#' + fullPath : fullPath;
    return base ? cleanPath(base + '/' + path) : path
  }

  VueRouter.install = install;
  VueRouter.version = '3.1.2';

  if (inBrowser$1 && window.Vue) {
    window.Vue.use(VueRouter);
  }

  /**
   * vuex v3.1.1
   * (c) 2019 Evan You
   * @license MIT
   */
  function applyMixin (Vue) {
    var version = Number(Vue.version.split('.')[0]);

    if (version >= 2) {
      Vue.mixin({ beforeCreate: vuexInit });
    } else {
      // override init and inject vuex init procedure
      // for 1.x backwards compatibility.
      var _init = Vue.prototype._init;
      Vue.prototype._init = function (options) {
        if ( options === void 0 ) options = {};

        options.init = options.init
          ? [vuexInit].concat(options.init)
          : vuexInit;
        _init.call(this, options);
      };
    }

    /**
     * Vuex init hook, injected into each instances init hooks list.
     */

    function vuexInit () {
      var options = this.$options;
      // store injection
      if (options.store) {
        this.$store = typeof options.store === 'function'
          ? options.store()
          : options.store;
      } else if (options.parent && options.parent.$store) {
        this.$store = options.parent.$store;
      }
    }
  }

  var target$2 = typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
      ? global
      : {};
  var devtoolHook = target$2.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  function devtoolPlugin (store) {
    if (!devtoolHook) { return }

    store._devtoolHook = devtoolHook;

    devtoolHook.emit('vuex:init', store);

    devtoolHook.on('vuex:travel-to-state', function (targetState) {
      store.replaceState(targetState);
    });

    store.subscribe(function (mutation, state) {
      devtoolHook.emit('vuex:mutation', mutation, state);
    });
  }

  /**
   * Get the first item that pass the test
   * by second argument function
   *
   * @param {Array} list
   * @param {Function} f
   * @return {*}
   */

  /**
   * forEach for object
   */
  function forEachValue (obj, fn) {
    Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
  }

  function isObject$1 (obj) {
    return obj !== null && typeof obj === 'object'
  }

  function isPromise$1 (val) {
    return val && typeof val.then === 'function'
  }

  function partial (fn, arg) {
    return function () {
      return fn(arg)
    }
  }

  // Base data struct for store's module, package with some attribute and method
  var Module = function Module (rawModule, runtime) {
    this.runtime = runtime;
    // Store some children item
    this._children = Object.create(null);
    // Store the origin module object which passed by programmer
    this._rawModule = rawModule;
    var rawState = rawModule.state;

    // Store the origin module's state
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
  };

  var prototypeAccessors$2 = { namespaced: { configurable: true } };

  prototypeAccessors$2.namespaced.get = function () {
    return !!this._rawModule.namespaced
  };

  Module.prototype.addChild = function addChild (key, module) {
    this._children[key] = module;
  };

  Module.prototype.removeChild = function removeChild (key) {
    delete this._children[key];
  };

  Module.prototype.getChild = function getChild (key) {
    return this._children[key]
  };

  Module.prototype.update = function update (rawModule) {
    this._rawModule.namespaced = rawModule.namespaced;
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions;
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations;
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters;
    }
  };

  Module.prototype.forEachChild = function forEachChild (fn) {
    forEachValue(this._children, fn);
  };

  Module.prototype.forEachGetter = function forEachGetter (fn) {
    if (this._rawModule.getters) {
      forEachValue(this._rawModule.getters, fn);
    }
  };

  Module.prototype.forEachAction = function forEachAction (fn) {
    if (this._rawModule.actions) {
      forEachValue(this._rawModule.actions, fn);
    }
  };

  Module.prototype.forEachMutation = function forEachMutation (fn) {
    if (this._rawModule.mutations) {
      forEachValue(this._rawModule.mutations, fn);
    }
  };

  Object.defineProperties( Module.prototype, prototypeAccessors$2 );

  var ModuleCollection = function ModuleCollection (rawRootModule) {
    // register root module (Vuex.Store options)
    this.register([], rawRootModule, false);
  };

  ModuleCollection.prototype.get = function get (path) {
    return path.reduce(function (module, key) {
      return module.getChild(key)
    }, this.root)
  };

  ModuleCollection.prototype.getNamespace = function getNamespace (path) {
    var module = this.root;
    return path.reduce(function (namespace, key) {
      module = module.getChild(key);
      return namespace + (module.namespaced ? key + '/' : '')
    }, '')
  };

  ModuleCollection.prototype.update = function update$1 (rawRootModule) {
    update([], this.root, rawRootModule);
  };

  ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
      var this$1 = this;
      if ( runtime === void 0 ) runtime = true;

    var newModule = new Module(rawModule, runtime);
    if (path.length === 0) {
      this.root = newModule;
    } else {
      var parent = this.get(path.slice(0, -1));
      parent.addChild(path[path.length - 1], newModule);
    }

    // register nested modules
    if (rawModule.modules) {
      forEachValue(rawModule.modules, function (rawChildModule, key) {
        this$1.register(path.concat(key), rawChildModule, runtime);
      });
    }
  };

  ModuleCollection.prototype.unregister = function unregister (path) {
    var parent = this.get(path.slice(0, -1));
    var key = path[path.length - 1];
    if (!parent.getChild(key).runtime) { return }

    parent.removeChild(key);
  };

  function update (path, targetModule, newModule) {

    // update target module
    targetModule.update(newModule);

    // update nested modules
    if (newModule.modules) {
      for (var key in newModule.modules) {
        if (!targetModule.getChild(key)) {
          return
        }
        update(
          path.concat(key),
          targetModule.getChild(key),
          newModule.modules[key]
        );
      }
    }
  }

  var Vue$2; // bind on install

  var Store = function Store (options) {
    var this$1 = this;
    if ( options === void 0 ) options = {};

    // Auto install if it is not done yet and `window` has `Vue`.
    // To allow users to avoid auto-installation in some cases,
    // this code should be placed here. See #731
    if (!Vue$2 && typeof window !== 'undefined' && window.Vue) {
      install$1(window.Vue);
    }

    var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
    var strict = options.strict; if ( strict === void 0 ) strict = false;

    // store internal state
    this._committing = false;
    this._actions = Object.create(null);
    this._actionSubscribers = [];
    this._mutations = Object.create(null);
    this._wrappedGetters = Object.create(null);
    this._modules = new ModuleCollection(options);
    this._modulesNamespaceMap = Object.create(null);
    this._subscribers = [];
    this._watcherVM = new Vue$2();

    // bind commit and dispatch to self
    var store = this;
    var ref = this;
    var dispatch = ref.dispatch;
    var commit = ref.commit;
    this.dispatch = function boundDispatch (type, payload) {
      return dispatch.call(store, type, payload)
    };
    this.commit = function boundCommit (type, payload, options) {
      return commit.call(store, type, payload, options)
    };

    // strict mode
    this.strict = strict;

    var state = this._modules.root.state;

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    installModule(this, state, [], this._modules.root);

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    resetStoreVM(this, state);

    // apply plugins
    plugins.forEach(function (plugin) { return plugin(this$1); });

    var useDevtools = options.devtools !== undefined ? options.devtools : Vue$2.config.devtools;
    if (useDevtools) {
      devtoolPlugin(this);
    }
  };

  var prototypeAccessors$1$1 = { state: { configurable: true } };

  prototypeAccessors$1$1.state.get = function () {
    return this._vm._data.$$state
  };

  prototypeAccessors$1$1.state.set = function (v) {
  };

  Store.prototype.commit = function commit (_type, _payload, _options) {
      var this$1 = this;

    // check object-style commit
    var ref = unifyObjectStyle(_type, _payload, _options);
      var type = ref.type;
      var payload = ref.payload;

    var mutation = { type: type, payload: payload };
    var entry = this._mutations[type];
    if (!entry) {
      return
    }
    this._withCommit(function () {
      entry.forEach(function commitIterator (handler) {
        handler(payload);
      });
    });
    this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });
  };

  Store.prototype.dispatch = function dispatch (_type, _payload) {
      var this$1 = this;

    // check object-style dispatch
    var ref = unifyObjectStyle(_type, _payload);
      var type = ref.type;
      var payload = ref.payload;

    var action = { type: type, payload: payload };
    var entry = this._actions[type];
    if (!entry) {
      return
    }

    try {
      this._actionSubscribers
        .filter(function (sub) { return sub.before; })
        .forEach(function (sub) { return sub.before(action, this$1.state); });
    } catch (e) {
    }

    var result = entry.length > 1
      ? Promise.all(entry.map(function (handler) { return handler(payload); }))
      : entry[0](payload);

    return result.then(function (res) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1.state); });
      } catch (e) {
      }
      return res
    })
  };

  Store.prototype.subscribe = function subscribe (fn) {
    return genericSubscribe(fn, this._subscribers)
  };

  Store.prototype.subscribeAction = function subscribeAction (fn) {
    var subs = typeof fn === 'function' ? { before: fn } : fn;
    return genericSubscribe(subs, this._actionSubscribers)
  };

  Store.prototype.watch = function watch (getter, cb, options) {
      var this$1 = this;
    return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
  };

  Store.prototype.replaceState = function replaceState (state) {
      var this$1 = this;

    this._withCommit(function () {
      this$1._vm._data.$$state = state;
    });
  };

  Store.prototype.registerModule = function registerModule (path, rawModule, options) {
      if ( options === void 0 ) options = {};

    if (typeof path === 'string') { path = [path]; }

    this._modules.register(path, rawModule);
    installModule(this, this.state, path, this._modules.get(path), options.preserveState);
    // reset store to update getters...
    resetStoreVM(this, this.state);
  };

  Store.prototype.unregisterModule = function unregisterModule (path) {
      var this$1 = this;

    if (typeof path === 'string') { path = [path]; }

    this._modules.unregister(path);
    this._withCommit(function () {
      var parentState = getNestedState(this$1.state, path.slice(0, -1));
      Vue$2.delete(parentState, path[path.length - 1]);
    });
    resetStore(this);
  };

  Store.prototype.hotUpdate = function hotUpdate (newOptions) {
    this._modules.update(newOptions);
    resetStore(this, true);
  };

  Store.prototype._withCommit = function _withCommit (fn) {
    var committing = this._committing;
    this._committing = true;
    fn();
    this._committing = committing;
  };

  Object.defineProperties( Store.prototype, prototypeAccessors$1$1 );

  function genericSubscribe (fn, subs) {
    if (subs.indexOf(fn) < 0) {
      subs.push(fn);
    }
    return function () {
      var i = subs.indexOf(fn);
      if (i > -1) {
        subs.splice(i, 1);
      }
    }
  }

  function resetStore (store, hot) {
    store._actions = Object.create(null);
    store._mutations = Object.create(null);
    store._wrappedGetters = Object.create(null);
    store._modulesNamespaceMap = Object.create(null);
    var state = store.state;
    // init all modules
    installModule(store, state, [], store._modules.root, true);
    // reset vm
    resetStoreVM(store, state, hot);
  }

  function resetStoreVM (store, state, hot) {
    var oldVm = store._vm;

    // bind store public getters
    store.getters = {};
    var wrappedGetters = store._wrappedGetters;
    var computed = {};
    forEachValue(wrappedGetters, function (fn, key) {
      // use computed to leverage its lazy-caching mechanism
      // direct inline function use will lead to closure preserving oldVm.
      // using partial to return function with only arguments preserved in closure enviroment.
      computed[key] = partial(fn, store);
      Object.defineProperty(store.getters, key, {
        get: function () { return store._vm[key]; },
        enumerable: true // for local getters
      });
    });

    // use a Vue instance to store the state tree
    // suppress warnings just in case the user has added
    // some funky global mixins
    var silent = Vue$2.config.silent;
    Vue$2.config.silent = true;
    store._vm = new Vue$2({
      data: {
        $$state: state
      },
      computed: computed
    });
    Vue$2.config.silent = silent;

    // enable strict mode for new vm
    if (store.strict) {
      enableStrictMode(store);
    }

    if (oldVm) {
      if (hot) {
        // dispatch changes in all subscribed watchers
        // to force getter re-evaluation for hot reloading.
        store._withCommit(function () {
          oldVm._data.$$state = null;
        });
      }
      Vue$2.nextTick(function () { return oldVm.$destroy(); });
    }
  }

  function installModule (store, rootState, path, module, hot) {
    var isRoot = !path.length;
    var namespace = store._modules.getNamespace(path);

    // register in namespace map
    if (module.namespaced) {
      store._modulesNamespaceMap[namespace] = module;
    }

    // set state
    if (!isRoot && !hot) {
      var parentState = getNestedState(rootState, path.slice(0, -1));
      var moduleName = path[path.length - 1];
      store._withCommit(function () {
        Vue$2.set(parentState, moduleName, module.state);
      });
    }

    var local = module.context = makeLocalContext(store, namespace, path);

    module.forEachMutation(function (mutation, key) {
      var namespacedType = namespace + key;
      registerMutation(store, namespacedType, mutation, local);
    });

    module.forEachAction(function (action, key) {
      var type = action.root ? key : namespace + key;
      var handler = action.handler || action;
      registerAction(store, type, handler, local);
    });

    module.forEachGetter(function (getter, key) {
      var namespacedType = namespace + key;
      registerGetter(store, namespacedType, getter, local);
    });

    module.forEachChild(function (child, key) {
      installModule(store, rootState, path.concat(key), child, hot);
    });
  }

  /**
   * make localized dispatch, commit, getters and state
   * if there is no namespace, just use root ones
   */
  function makeLocalContext (store, namespace, path) {
    var noNamespace = namespace === '';

    var local = {
      dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
        var args = unifyObjectStyle(_type, _payload, _options);
        var payload = args.payload;
        var options = args.options;
        var type = args.type;

        if (!options || !options.root) {
          type = namespace + type;
        }

        return store.dispatch(type, payload)
      },

      commit: noNamespace ? store.commit : function (_type, _payload, _options) {
        var args = unifyObjectStyle(_type, _payload, _options);
        var payload = args.payload;
        var options = args.options;
        var type = args.type;

        if (!options || !options.root) {
          type = namespace + type;
        }

        store.commit(type, payload, options);
      }
    };

    // getters and state object must be gotten lazily
    // because they will be changed by vm update
    Object.defineProperties(local, {
      getters: {
        get: noNamespace
          ? function () { return store.getters; }
          : function () { return makeLocalGetters(store, namespace); }
      },
      state: {
        get: function () { return getNestedState(store.state, path); }
      }
    });

    return local
  }

  function makeLocalGetters (store, namespace) {
    var gettersProxy = {};

    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });

    return gettersProxy
  }

  function registerMutation (store, type, handler, local) {
    var entry = store._mutations[type] || (store._mutations[type] = []);
    entry.push(function wrappedMutationHandler (payload) {
      handler.call(store, local.state, payload);
    });
  }

  function registerAction (store, type, handler, local) {
    var entry = store._actions[type] || (store._actions[type] = []);
    entry.push(function wrappedActionHandler (payload, cb) {
      var res = handler.call(store, {
        dispatch: local.dispatch,
        commit: local.commit,
        getters: local.getters,
        state: local.state,
        rootGetters: store.getters,
        rootState: store.state
      }, payload, cb);
      if (!isPromise$1(res)) {
        res = Promise.resolve(res);
      }
      if (store._devtoolHook) {
        return res.catch(function (err) {
          store._devtoolHook.emit('vuex:error', err);
          throw err
        })
      } else {
        return res
      }
    });
  }

  function registerGetter (store, type, rawGetter, local) {
    if (store._wrappedGetters[type]) {
      return
    }
    store._wrappedGetters[type] = function wrappedGetter (store) {
      return rawGetter(
        local.state, // local state
        local.getters, // local getters
        store.state, // root state
        store.getters // root getters
      )
    };
  }

  function enableStrictMode (store) {
    store._vm.$watch(function () { return this._data.$$state }, function () {
    }, { deep: true, sync: true });
  }

  function getNestedState (state, path) {
    return path.length
      ? path.reduce(function (state, key) { return state[key]; }, state)
      : state
  }

  function unifyObjectStyle (type, payload, options) {
    if (isObject$1(type) && type.type) {
      options = payload;
      payload = type;
      type = type.type;
    }

    return { type: type, payload: payload, options: options }
  }

  function install$1 (_Vue) {
    if (Vue$2 && _Vue === Vue$2) {
      return
    }
    Vue$2 = _Vue;
    applyMixin(Vue$2);
  }

  /**
   * Reduce the code which written in Vue.js for getting the state.
   * @param {String} [namespace] - Module's namespace
   * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
   * @param {Object}
   */
  var mapState = normalizeNamespace(function (namespace, states) {
    var res = {};
    normalizeMap(states).forEach(function (ref) {
      var key = ref.key;
      var val = ref.val;

      res[key] = function mappedState () {
        var state = this.$store.state;
        var getters = this.$store.getters;
        if (namespace) {
          var module = getModuleByNamespace(this.$store, 'mapState', namespace);
          if (!module) {
            return
          }
          state = module.context.state;
          getters = module.context.getters;
        }
        return typeof val === 'function'
          ? val.call(this, state, getters)
          : state[val]
      };
      // mark vuex getter for devtools
      res[key].vuex = true;
    });
    return res
  });

  /**
   * Reduce the code which written in Vue.js for committing the mutation
   * @param {String} [namespace] - Module's namespace
   * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
   * @return {Object}
   */
  var mapMutations = normalizeNamespace(function (namespace, mutations) {
    var res = {};
    normalizeMap(mutations).forEach(function (ref) {
      var key = ref.key;
      var val = ref.val;

      res[key] = function mappedMutation () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // Get the commit method from store
        var commit = this.$store.commit;
        if (namespace) {
          var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
          if (!module) {
            return
          }
          commit = module.context.commit;
        }
        return typeof val === 'function'
          ? val.apply(this, [commit].concat(args))
          : commit.apply(this.$store, [val].concat(args))
      };
    });
    return res
  });

  /**
   * Reduce the code which written in Vue.js for getting the getters
   * @param {String} [namespace] - Module's namespace
   * @param {Object|Array} getters
   * @return {Object}
   */
  var mapGetters = normalizeNamespace(function (namespace, getters) {
    var res = {};
    normalizeMap(getters).forEach(function (ref) {
      var key = ref.key;
      var val = ref.val;

      // The namespace has been mutated by normalizeNamespace
      val = namespace + val;
      res[key] = function mappedGetter () {
        if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
          return
        }
        return this.$store.getters[val]
      };
      // mark vuex getter for devtools
      res[key].vuex = true;
    });
    return res
  });

  /**
   * Reduce the code which written in Vue.js for dispatch the action
   * @param {String} [namespace] - Module's namespace
   * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
   * @return {Object}
   */
  var mapActions = normalizeNamespace(function (namespace, actions) {
    var res = {};
    normalizeMap(actions).forEach(function (ref) {
      var key = ref.key;
      var val = ref.val;

      res[key] = function mappedAction () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // get dispatch function from store
        var dispatch = this.$store.dispatch;
        if (namespace) {
          var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
          if (!module) {
            return
          }
          dispatch = module.context.dispatch;
        }
        return typeof val === 'function'
          ? val.apply(this, [dispatch].concat(args))
          : dispatch.apply(this.$store, [val].concat(args))
      };
    });
    return res
  });

  /**
   * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
   * @param {String} namespace
   * @return {Object}
   */
  var createNamespacedHelpers = function (namespace) { return ({
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  }); };

  /**
   * Normalize the map
   * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
   * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
   * @param {Array|Object} map
   * @return {Object}
   */
  function normalizeMap (map) {
    return Array.isArray(map)
      ? map.map(function (key) { return ({ key: key, val: key }); })
      : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
  }

  /**
   * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
   * @param {Function} fn
   * @return {Function}
   */
  function normalizeNamespace (fn) {
    return function (namespace, map) {
      if (typeof namespace !== 'string') {
        map = namespace;
        namespace = '';
      } else if (namespace.charAt(namespace.length - 1) !== '/') {
        namespace += '/';
      }
      return fn(namespace, map)
    }
  }

  /**
   * Search a special module from store by namespace. if module not exist, print error message.
   * @param {Object} store
   * @param {String} helper
   * @param {String} namespace
   * @return {Object}
   */
  function getModuleByNamespace (store, helper, namespace) {
    var module = store._modulesNamespaceMap[namespace];
    return module
  }

  var index_esm = {
    Store: Store,
    install: install$1,
    version: '3.1.1',
    mapState: mapState,
    mapMutations: mapMutations,
    mapGetters: mapGetters,
    mapActions: mapActions,
    createNamespacedHelpers: createNamespacedHelpers
  };

  //
   
   var script = {
       name: 'home',
       computed: mapState([
  	 'nodes'
       ]),
       methods: {
  	 new_node: function(event){
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     fetch('/new', fetch_params).then(function(response){
  		 response.text().then(function(data){
  		     console.log(data);
  		 });
  	     });
  	 }
       }
   };

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__$1 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "home" },
      [
        _c("div", { staticClass: "snippet_header" }, [
          _c("span", { staticClass: "snippet_title" }, [_vm._v("Category")]),
          _c(
            "span",
            {
              staticClass: "close_x",
              on: {
                click: function($event) {
                  return _vm.new_node()
                }
              }
            },
            [_c("span", { staticClass: "fas fa-plus" })]
          )
        ]),
        _c("search", { attrs: { initquery: "*", nodes: _vm.nodes } })
      ],
      1
    )
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

    /* style */
    const __vue_inject_styles__$1 = function (inject) {
      if (!inject) return
      inject("data-v-e1784cac_0", { source: "\n.snippet_header[data-v-e1784cac]{\n    border-radius: 10px;\n    padding: 5px;\n    width: 100%;\n    margin-bottom: 10px;\n}\n.snippet_title[data-v-e1784cac]{\n    font-size: 20pt;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/views/Home.vue"],"names":[],"mappings":";AA2CA;IACA,mBAAA;IACA,YAAA;IACA,WAAA;IACA,mBAAA;AACA;AAEA;IACA,eAAA;AACA","file":"Home.vue","sourcesContent":["<template>\n  <div class=\"home\">\n      <div class=\"snippet_header\">\n\t  <span class=\"snippet_title\">Category</span>\n\t  <span v-on:click=\"new_node()\" class=\"close_x\"><span class=\"fas fa-plus\"></span></span>\n\t</div>\n\n\t<search initquery=\"*\" :nodes=\"nodes\" />\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\n import { mapState } from 'vuex'\n \n export default {\n     name: 'home',\n     computed: mapState([\n\t 'nodes'\n     ]),\n     methods: {\n\t new_node: function(event){\n\t     var self = this;\n\t     var fetch_headers = new Headers();\n\t     fetch_headers.append('pragma', 'no-cache');\n\t     fetch_headers.append('cache-control', 'no-cache');\n\t     \n\t     var fetch_params = {\n\t\t method: 'GET',\n\t\t headers: fetch_headers,\n\t     };\n\t     fetch('/new', fetch_params).then(function(response){\n\t\t response.text().then(function(data){\n\t\t     console.log(data);\n\t\t });\n\t     });\n\t }\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n .snippet_header{\n     border-radius: 10px;\n     padding: 5px;\n     width: 100%;\n     margin-bottom: 10px;\n }\n\n .snippet_title{\n     font-size: 20pt;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$1 = "data-v-e1784cac";
    /* module identifier */
    const __vue_module_identifier__$1 = undefined;
    /* functional template */
    const __vue_is_functional_template__$1 = false;
    /* style inject SSR */
    

    
    var Home = normalizeComponent_1(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      browser,
      undefined
    );

  //

   var script$1 = {
       name: 'Node',
       data() {
  	 return {
  	     'node': this.$route.params.id,
  	     'display_graph':false,
  	     'data': 'loading...'
  	 }
       },
       created: function() {
  	 console.log('cr');
  	 this.$store.commit('GO',this.node);
  	 this.get_node(this.node, function(){});
       },
       beforeRouteUpdate: function(to, fro, next) {
  	 console.log("ND",this.node_data);
  	 let node_id = to.params.id;
  	 this.$store.dispatch('go',node_id);
  	 if (!this.nodes[node_id]) {
  	     console.log("problem:",node_id,"does not exist");
  	 }
  	 else if (node_id in this.node_data) {
  	     console.log("cached");
  	     this.data = this.node_data[node_id];
  	     console.log(this.data);
  	     this.node = node_id;
  	     this.$nextTick(function(){Vue$1.run_plugins(this);});
  	     next();
  	 }
  	 else if(this.nodes[node_id].auto == "yes") {
  	     console.log("auto");
  	     this.node = node_id;
  	     this.$store.dispatch('go',this.node);
  	     next();
  	 }
  	 else {
  	     console.log("not cached");
  	     this.get_node(node_id, next);
  	 }
       },
       computed: {
  	 internal_nodes: function() {
  	     // ans is going to be the set of locations within this document as well as all targets
  	     var ans = {};
  	     // Pull in children of the current node and everything connected to them:
  	     for(var n in this.nodes) {
  		 var node = this.nodes[n];
  		 if(node.parent == this.node && n != this.node) {
  		     ans[n] = node;
  		     for(var dir in node.edges) {
  			 for(var label in node.edges[dir]) {
  			     for(var edge of node.edges[dir][label]) {
  				 if(edge.target != this.node) {
  				     ans[edge.target] = this.nodes[edge.target];
  				 }
  			     }
  			 }
  		     }
  		 }
  	     }
  	     console.log("INTERNAL",ans);
  	     return ans;
  	 },
  	 ...mapState(['nodes', 'node_data']),
  	 ...mapGetters(['neighbours'])
       },
       methods: {
  	 get_node: function(node_id, next) {
  	     var self = this;
  	     console.log("fetching",node_id);
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     fetch('/out/'+node_id+'.html', fetch_params).then(function(response){
  		 response.text().then(function(data){
  		     var to_cache = {};
  		     to_cache[node_id] = data;
  		     self.$store.commit('CACHE',to_cache);
  		     self.data = data;
  		     self.node = node_id;
  		     next();
  		     console.log("IH1",self.data,"||",self.$el.innerHTML);
  		     self.$nextTick(function(){
  			 console.log("IH2",self.data,"||",self.$el.innerHTML);
  			 Vue$1.run_plugins(self);
  			 console.log("IH3",self.data,"||",self.$el.innerHTML);
  		     });
  		 });
  	     });

  	 },
  	 reload_node: function(node, event){
  	     this.get_node(this.node, function(){});
  	 },
  	 edit_node: function(node, event){
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     fetch('/edit/'+node, fetch_params).then(function(response){
  		 response.text().then(function(data){
  		     console.log(data);
  		 });
  	     });
  	 },
  	 new_node: function(node, event){
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     fetch('/new', fetch_params).then(function(response){
  		 response.text().then(function(data){
  		     console.log(data);
  		 });
  	     });
  	 }
       }
   };

  /* script */
  const __vue_script__$1 = script$1;

  /* template */
  var __vue_render__$2 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c(
        "div",
        { staticClass: "snippet_header" },
        [
          _c("span", { staticClass: "snippet_title" }, [
            _vm._v(
              _vm._s(
                _vm.nodes && _vm.nodes[_vm.node]
                  ? _vm.nodes[_vm.node].name
                  : "loading..."
              )
            )
          ]),
          _c(
            "span",
            {
              staticClass: "close_x",
              on: {
                click: function($event) {
                  return _vm.edit_node(_vm.node)
                }
              }
            },
            [_c("span", { staticClass: "fas fa-edit" })]
          ),
          _c(
            "span",
            {
              staticClass: "close_x",
              on: {
                click: function($event) {
                  return _vm.reload_node(_vm.node)
                }
              }
            },
            [_c("span", { staticClass: "fas fa-sync" })]
          ),
          _c(
            "span",
            {
              staticClass: "close_x",
              on: {
                click: function($event) {
                  return _vm.new_node(_vm.node)
                }
              }
            },
            [_c("span", { staticClass: "fas fa-plus" })]
          ),
          _c("router-link", { staticClass: "close_x", attrs: { to: "/" } }, [
            _c("span", { staticClass: "fas fa-home" })
          ])
        ],
        1
      ),
      _c("div", [
        _vm.nodes && _vm.nodes[_vm.node] && _vm.nodes[_vm.node].auto == false
          ? _c(
              "div",
              [
                _c(
                  "span",
                  {
                    staticClass: "close_x",
                    on: {
                      click: function($event) {
                        _vm.display_graph = !_vm.display_graph;
                      }
                    }
                  },
                  [_c("span", { staticClass: "fas fa-search" })]
                ),
                _vm.display_graph
                  ? _c(
                      "div",
                      { staticStyle: { float: "left", width: "100%" } },
                      [
                        _c("search", {
                          attrs: { nodes: _vm.internal_nodes, initquery: "*" }
                        })
                      ],
                      1
                    )
                  : _vm._e(),
                _c("div", {
                  staticClass: "expanded_content",
                  domProps: { innerHTML: _vm._s(_vm.data) }
                }),
                _c("edge-display", { attrs: { node: _vm.node } })
              ],
              1
            )
          : _vm._e(),
        _vm.nodes && _vm.nodes[_vm.node] && _vm.nodes[_vm.node].auto == true
          ? _c(
              "div",
              [
                _c("node-index", { attrs: { nodeset: _vm.neighbours(_vm.node) } })
              ],
              1
            )
          : _vm._e(),
        !_vm.nodes || !_vm.nodes[_vm.node]
          ? _c("div", [_vm._v("\n\t\tLoading...\n\t    ")])
          : _vm._e()
      ])
    ])
  };
  var __vue_staticRenderFns__$2 = [];
  __vue_render__$2._withStripped = true;

    /* style */
    const __vue_inject_styles__$2 = function (inject) {
      if (!inject) return
      inject("data-v-f8ff00f8_0", { source: "\n.snippet_content img[data-v-f8ff00f8] {\n    max-width: 100%;\n}\n.expanded_content img[data-v-f8ff00f8] {\n    max-width: 100%;\n}\n.snippet[data-v-f8ff00f8]{\n    border-radius: 3px;\n    border: 1px solid #ccc;\n    margin-bottom: 10px;\n}\n.snippet_content[data-v-f8ff00f8]{\n    padding:5px;\n}\n.snippet_header[data-v-f8ff00f8]{\n    border-radius: 10px;\n    padding: 5px;\n    width: 100%;\n    margin-bottom: 10px;\n}\n.snippet_title[data-v-f8ff00f8]{\n    font-size: 20pt;\n}\n.snippet_content[data-v-f8ff00f8]{\n    max-height: 400px;\n    overflow-y:scroll;\n    overflow-x:scroll;\n    margin-bottom:10px;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/views/Node.vue"],"names":[],"mappings":";AA8KA;IACA,eAAA;AACA;AAEA;IACA,eAAA;AACA;AAEA;IACA,kBAAA;IACA,sBAAA;IACA,mBAAA;AACA;AAEA;IACA,WAAA;AACA;AAEA;IACA,mBAAA;IACA,YAAA;IACA,WAAA;IACA,mBAAA;AACA;AAEA;IACA,eAAA;AACA;AAEA;IACA,iBAAA;IACA,iBAAA;IACA,iBAAA;IACA,kBAAA;AACA","file":"Node.vue","sourcesContent":["<template>\n    <div>\n\t<div class=\"snippet_header\">\n\t    <span class=\"snippet_title\">{{nodes && nodes[node] ? nodes[node].name : 'loading...'}}</span>\n\t    <span v-on:click=\"edit_node(node)\" class=\"close_x\"><span class=\"fas fa-edit\"></span></span>\n\t    <span v-on:click=\"reload_node(node)\" class=\"close_x\"><span class=\"fas fa-sync\"></span></span>\n\t    <span v-on:click=\"new_node(node)\" class=\"close_x\"><span class=\"fas fa-plus\"></span></span>\n\t    <router-link to=\"/\" class=\"close_x\"><span class=\"fas fa-home\"></span></router-link>\n\t</div>\n\t<div>\n\t    <div v-if=\"nodes && nodes[node] && nodes[node].auto == false\">\n\t\t<span v-on:click=\"display_graph = !display_graph\" class=\"close_x\"><span class=\"fas fa-search\"></span></span>\n\t\t<div v-if=\"display_graph\" style=\"float:left;width:100%;\">\n\t\t    <search :nodes=\"internal_nodes\" initquery=\"*\"></search>\n\t\t</div>\n\t\t\n\t\t<div v-html=\"data\" class=\"expanded_content\"></div>\n\t\t<edge-display :node=\"node\"></edge-display>\n\t    </div>\n\t    <div v-if=\"nodes && nodes[node] && nodes[node].auto == true\">\n\t\t<node-index :nodeset=\"neighbours(node)\" />\n\t    </div>\n\t    <div v-if=\"!nodes || !nodes[node]\">\n\t\tLoading...\n\t    </div>\n\t</div>\n    </div>\n</template>\n\n<script>\n import Vue from 'vue'\n \n import { mapState } from 'vuex'\n import { mapGetters } from 'vuex'\n\n export default {\n     name: 'Node',\n     data() {\n\t return {\n\t     'node': this.$route.params.id,\n\t     'display_graph':false,\n\t     'data': 'loading...'\n\t }\n     },\n     created: function() {\n\t console.log('cr');\n\t this.$store.commit('GO',this.node);\n\t this.get_node(this.node, function(){});\n     },\n     beforeRouteUpdate: function(to, fro, next) {\n\t console.log(\"ND\",this.node_data);\n\t let node_id = to.params.id;\n\t this.$store.dispatch('go',node_id);\n\t var self = this;\n\t if (!this.nodes[node_id]) {\n\t     console.log(\"problem:\",node_id,\"does not exist\");\n\t }\n\t else if (node_id in this.node_data) {\n\t     console.log(\"cached\");\n\t     this.data = this.node_data[node_id];\n\t     console.log(this.data);\n\t     this.node = node_id;\n\t     this.$nextTick(function(){Vue.run_plugins(this);});\n\t     next();\n\t }\n\t else if(this.nodes[node_id].auto == \"yes\") {\n\t     console.log(\"auto\");\n\t     this.node = node_id;\n\t     this.$store.dispatch('go',this.node);\n\t     next();\n\t }\n\t else {\n\t     console.log(\"not cached\");\n\t     this.get_node(node_id, next);\n\t }\n     },\n     computed: {\n\t internal_nodes: function() {\n\t     // ans is going to be the set of locations within this document as well as all targets\n\t     var ans = {};\n\t     var duals = {\"has\":\"is\",\"is\":\"has\"};\n\t     // Pull in children of the current node and everything connected to them:\n\t     for(var n in this.nodes) {\n\t\t var node = this.nodes[n];\n\t\t if(node.parent == this.node && n != this.node) {\n\t\t     ans[n] = node;\n\t\t     for(var dir in node.edges) {\n\t\t\t for(var label in node.edges[dir]) {\n\t\t\t     for(var edge of node.edges[dir][label]) {\n\t\t\t\t if(edge.target != this.node) {\n\t\t\t\t     ans[edge.target] = this.nodes[edge.target];\n\t\t\t\t }\n\t\t\t     }\n\t\t\t }\n\t\t     }\n\t\t }\n\t     }\n\t     console.log(\"INTERNAL\",ans);\n\t     return ans;\n\t },\n\t ...mapState(['nodes', 'node_data']),\n\t ...mapGetters(['neighbours'])\n     },\n     methods: {\n\t get_node: function(node_id, next) {\n\t     var self = this;\n\t     console.log(\"fetching\",node_id);\n\t     var fetch_headers = new Headers();\n\t     fetch_headers.append('pragma', 'no-cache');\n\t     fetch_headers.append('cache-control', 'no-cache');\n\t     \n\t     var fetch_params = {\n\t\t method: 'GET',\n\t\t headers: fetch_headers,\n\t     };\n\t     fetch('/out/'+node_id+'.html', fetch_params).then(function(response){\n\t\t response.text().then(function(data){\n\t\t     var to_cache = {};\n\t\t     to_cache[node_id] = data;\n\t\t     self.$store.commit('CACHE',to_cache);\n\t\t     self.data = data;\n\t\t     self.node = node_id;\n\t\t     next();\n\t\t     console.log(\"IH1\",self.data,\"||\",self.$el.innerHTML);\n\t\t     self.$nextTick(function(){\n\t\t\t console.log(\"IH2\",self.data,\"||\",self.$el.innerHTML);\n\t\t\t Vue.run_plugins(self);\n\t\t\t console.log(\"IH3\",self.data,\"||\",self.$el.innerHTML);\n\t\t     });\n\t\t });\n\t     });\n\n\t },\n\t reload_node: function(node, event){\n\t     var self = this;\n\t     this.get_node(this.node, function(){});\n\t },\n\t edit_node: function(node, event){\n\t     var self = this;\n\t     var fetch_headers = new Headers();\n\t     fetch_headers.append('pragma', 'no-cache');\n\t     fetch_headers.append('cache-control', 'no-cache');\n\t     \n\t     var fetch_params = {\n\t\t method: 'GET',\n\t\t headers: fetch_headers,\n\t     };\n\t     fetch('/edit/'+node, fetch_params).then(function(response){\n\t\t response.text().then(function(data){\n\t\t     console.log(data);\n\t\t });\n\t     });\n\t },\n\t new_node: function(node, event){\n\t     var self = this;\n\t     var fetch_headers = new Headers();\n\t     fetch_headers.append('pragma', 'no-cache');\n\t     fetch_headers.append('cache-control', 'no-cache');\n\t     \n\t     var fetch_params = {\n\t\t method: 'GET',\n\t\t headers: fetch_headers,\n\t     };\n\t     fetch('/new', fetch_params).then(function(response){\n\t\t response.text().then(function(data){\n\t\t     console.log(data);\n\t\t });\n\t     });\n\t }\n     }\n }\n</script>\n\n<style scoped>\n .snippet_content img {\n     max-width: 100%;\n }\n\n .expanded_content img {\n     max-width: 100%;\n }\n\n .snippet{\n     border-radius: 3px;\n     border: 1px solid #ccc;\n     margin-bottom: 10px;\n }\n\n .snippet_content{\n     padding:5px;\n }\n\n .snippet_header{\n     border-radius: 10px;\n     padding: 5px;\n     width: 100%;\n     margin-bottom: 10px;\n }\n\n .snippet_title{\n     font-size: 20pt;\n }\n\n .snippet_content{\n     max-height: 400px;\n     overflow-y:scroll;\n     overflow-x:scroll;\n     margin-bottom:10px;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$2 = "data-v-f8ff00f8";
    /* module identifier */
    const __vue_module_identifier__$2 = undefined;
    /* functional template */
    const __vue_is_functional_template__$2 = false;
    /* style inject SSR */
    

    
    var Node = normalizeComponent_1(
      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
      __vue_inject_styles__$2,
      __vue_script__$1,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      browser,
      undefined
    );

  //

   var script$2 = {
       name: 'browse',
       computed: { 
  	 resultset: function() {
  	     var ans = {};
  	     for(var r of this.result) {
  		 ans[r] = this.nodes[r];
  	     }
  	     return ans;
  	 },
  	 highlightset: function() {
  	     var ans = {};
  	     for(var r of this.highlight) {
  		 ans[r] = true;
  	     }
  	     console.log(ans);
  	     return ans;
  	 },
  	 best_highlights: function() {
  	     var nodes_by_deg = [];
  	     for(var n in this.highlightset) {
  		 var targets = {};
  		 for(var label in this.nodes[n].edges.has) {
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 for(var label in this.nodes[n].edges.is) {
  		     for(var edge of this.nodes[n].edges.is[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 var deg = 0;
  		 for(var t in targets) {
  		     deg++;
  		 }
  		 nodes_by_deg.push({"node":n,"degree":deg});
  	     }
  	     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });
  	     return nodes_by_deg.slice(0,10);
  	 },
  	 best_nodes: function() {
  	     var nodes_by_deg = [];
  	     for(var n in this.resultset) {
  		 var targets = {};
  		 for(var label in this.nodes[n].edges.has) {
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 for(var label in this.nodes[n].edges.is) {
  		     for(var edge of this.nodes[n].edges.is[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 var deg = 0;
  		 for(var t in targets) {
  		     deg++;
  		 }
  		 nodes_by_deg.push({"node":n,"degree":deg});
  	     }
  	     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });
  	     return nodes_by_deg.slice(0,10);
  	 },
  	 best_edges: function() {
  	     var edges_with_count = {};
  	     for(var n in this.resultset) {
  		 // only need to count the has direction since the is direction will be accounted for when iterating over the has edges of the target
  		 for(var label in this.nodes[n].edges.has) {
  		     if(!(label in edges_with_count)) {
  			 edges_with_count[label] = 0;
  		     }
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     edges_with_count[label]++;
  			 }
  		     }
  		 }
  	     }
  	     var edges_by_count = [];
  	     for(var e in edges_with_count) {
  		 edges_by_count.push({"edge":e,"count":edges_with_count[e]});
  	     }
  	     edges_by_count.sort(function(a, b){return b.count-a.count;});
  	     return edges_by_count.slice(0,10);
  	 },
  	 ...mapState(['nodes', 'node_data']),
       },
       data() {
  	 return {
  	     entered_query: '',
  	     query: '',
  	     highlight_query: '',
  	     errormsg: '',
  	     result: [],
  	     highlight: [],
  	     mode: 'graph',
  	 }
       },
       watch: {
  	 nodes: function(val) {
  	     this.$nextTick(function () {
  		 this.search();
  	     });
  	 }
       },
       methods: {
  	 add_to_query: function(qry) {
  	     if(this.query.trim().length > 0 && this.query.trim() != "*") {
  		 this.query = "("+this.query+"),"+qry;
  	     }
  	     else {
  		 this.query = qry;
  	     }
  	     this.search();
  	 },
  	 set_query: function(qry) {
  	     this.query = qry;
  	     this.highlight_query = "";
  	     this.do_highlight();
  	     this.search();
  	 },
  	 set_highlight: function(qry) {
  	     this.highlight_query = qry;
  	     this.do_highlight();
  	 },
  	 run_search: function(qry, nodeset) {
  	     this.entered_query = qry;
  	     this.errormsg = "";
  	     if(qry.trim().length == 0) {
  		 return [];
  	     }
  	     try {
  		 var q = Vue$1.category_query.parse(qry);
  	     }
  	     catch(e){
  		 this.errormsg = e.toString();
  		 return [];
  	     }
  	     return Vue$1.category_search(q, nodeset);
  	 },
  	 search: function() {
  	     if(this.query.trim().length == 0) {
  		 this.query = "*";
  	     }
  	     var query_result = this.run_search(this.query, this.nodes);
  	     console.log(query_result);
  	     if(query_result.length == 0) {
  		 return;
  	     }
  	     if(query_result.length == 1) {
  		 this.$router.push('/node/'+query_result[0]);
  	     }
  	     else {
  		 this.result = query_result;
  		 console.log("RES",this.result);
  		 for(var i = 0; i < this.result.length; i++){
  		     if(this.nodes[this.result[i]].name == this.query.trim()) {
  			 this.$router.push('/node/'+this.result[i]);
  			 break;
  		     }
  		 }
  	     }
  	 },
  	 do_highlight: function() {
  	     this.highlight = this.run_search(this.highlight_query, this.resultset);
  	 },
  	 expand_highlight: function() {
  	     this.highlight_query = "("+this.highlight_query+")[1]";
  	     this.do_highlight();
  	 },
  	 clear_highlight: function() {
  	     this.highlight_query = "";
  	     this.do_highlight();
  	 },
  	 new_node: function(event){
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     fetch('/new', fetch_params).then(function(response){
  		 response.text().then(function(data){
  		     console.log(data);
  		 });
  	     });
  	 },
  	 clear_filter: function() {
  	     this.query = '*';
  	     this.search();
  	     this.do_highlight();
  	 }
       },
       mounted: function() {
  	 this.query = '*';
  	 this.search();
       }
   };

  /* script */
  const __vue_script__$2 = script$2;

  /* template */
  var __vue_render__$3 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "browse" }, [
      _c(
        "div",
        {
          staticClass: "browse_container",
          staticStyle: { float: "left", width: "70%" }
        },
        [
          _c("div", { staticClass: "filterquery" }, [
            _c("span", [_vm._v(_vm._s(_vm.query))]),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    return _vm.clear_filter()
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-eraser" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    _vm.mode = "list";
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-list" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    _vm.mode = "graph";
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-project-diagram" })]
            )
          ]),
          _vm.mode == "graph"
            ? _c("div", [
                _c(
                  "div",
                  { staticStyle: { float: "left", width: "100%" } },
                  [
                    _c("br"),
                    _vm.result.length > 0
                      ? _c("graph-index", {
                          attrs: {
                            nodeset: _vm.resultset,
                            highlight: _vm.highlightset
                          }
                        })
                      : _vm._e()
                  ],
                  1
                )
              ])
            : _vm._e(),
          _vm.mode == "list"
            ? _c(
                "div",
                [
                  _vm.result.length > 0
                    ? _c("node-index", { attrs: { nodeset: _vm.resultset } })
                    : _vm._e()
                ],
                1
              )
            : _vm._e()
        ]
      ),
      _c(
        "div",
        {
          staticClass: "querypanel",
          staticStyle: { float: "left", width: "30%", "padding-left": "10px" }
        },
        [
          _c("div", { staticStyle: { float: "left" } }, [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.highlight_query,
                  expression: "highlight_query"
                }
              ],
              attrs: { type: "text", id: "highlight_input" },
              domProps: { value: _vm.highlight_query },
              on: {
                keyup: function($event) {
                  if (
                    !$event.type.indexOf("key") &&
                    _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                  ) {
                    return null
                  }
                  return _vm.do_highlight($event)
                },
                input: function($event) {
                  if ($event.target.composing) {
                    return
                  }
                  _vm.highlight_query = $event.target.value;
                }
              }
            }),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    return _vm.do_highlight()
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-search" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    return _vm.expand_highlight()
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-plus" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    return _vm.clear_highlight()
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-backspace" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    return _vm.set_query(_vm.highlight_query)
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-search-plus" })]
            ),
            _c(
              "span",
              {
                staticClass: "close_x",
                on: {
                  click: function($event) {
                    _vm.add_to_query("!(" + _vm.highlight_query + ")");
                  }
                }
              },
              [_c("span", { staticClass: "fas fa-search-minus" })]
            )
          ]),
          _vm.errormsg.length > 0
            ? _c("span", { staticClass: "search-error" }, [
                _vm._v(_vm._s(_vm.errormsg))
              ])
            : _vm._e(),
          _c("br"),
          _c("br"),
          _vm.highlight.length == 0
            ? _c(
                "div",
                [
                  _c("b", [_vm._v("Top nodes")]),
                  _vm._l(_vm.best_nodes, function(n) {
                    return _c("div", { staticClass: "query_result" }, [
                      _c("div", { staticStyle: { display: "inline-block" } }, [
                        _c(
                          "span",
                          {
                            staticClass: "badge_button",
                            on: {
                              click: function($event) {
                                _vm.add_to_query(
                                  "((=" +
                                    _vm.nodes[n.node].name +
                                    ")[2], !(=" +
                                    _vm.nodes[n.node].name +
                                    "))"
                                );
                              }
                            }
                          },
                          [_vm._v("+")]
                        ),
                        _c(
                          "span",
                          {
                            staticClass: "badge_button",
                            on: {
                              click: function($event) {
                                _vm.add_to_query(
                                  "!(=" + _vm.nodes[n.node].name + ")"
                                );
                              }
                            }
                          },
                          [_vm._v("-")]
                        )
                      ]),
                      _c(
                        "a",
                        {
                          attrs: { href: "#" },
                          on: {
                            click: function($event) {
                              _vm.set_highlight(
                                "(=" + _vm.nodes[n.node].name + ")[1]"
                              );
                            }
                          }
                        },
                        [
                          _vm._v(
                            _vm._s(_vm.nodes[n.node].name) +
                              " (" +
                              _vm._s(n.degree) +
                              ")"
                          )
                        ]
                      )
                    ])
                  })
                ],
                2
              )
            : _vm._e(),
          _vm.highlight.length > 0
            ? _c(
                "div",
                [
                  _c("b", [_vm._v("Top nodes in result")]),
                  _vm._l(_vm.best_highlights, function(n) {
                    return _c("div", { staticClass: "query_result" }, [
                      _c("div", { staticStyle: { display: "inline-block" } }, [
                        _c(
                          "span",
                          {
                            staticClass: "badge_button",
                            on: {
                              click: function($event) {
                                _vm.add_to_query(
                                  "((=" +
                                    _vm.nodes[n.node].name +
                                    ")[2], !(=" +
                                    _vm.nodes[n.node].name +
                                    "))"
                                );
                              }
                            }
                          },
                          [_vm._v("+")]
                        ),
                        _c(
                          "span",
                          {
                            staticClass: "badge_button",
                            on: {
                              click: function($event) {
                                _vm.add_to_query(
                                  "!(=" + _vm.nodes[n.node].name + ")"
                                );
                              }
                            }
                          },
                          [_vm._v("-")]
                        )
                      ]),
                      _c(
                        "a",
                        {
                          attrs: { href: "#" },
                          on: {
                            click: function($event) {
                              _vm.set_highlight(
                                "(=" + _vm.nodes[n.node].name + ")[1]"
                              );
                            }
                          }
                        },
                        [
                          _vm._v(
                            _vm._s(_vm.nodes[n.node].name) +
                              " (" +
                              _vm._s(n.degree) +
                              ")"
                          )
                        ]
                      )
                    ])
                  })
                ],
                2
              )
            : _vm._e(),
          _c("hr"),
          _c("b", [_vm._v("Top labels")]),
          _vm._l(_vm.best_edges, function(e) {
            return _c("div", { staticClass: "query_result" }, [
              _c("div", { staticStyle: { display: "inline-block" } }, [
                _c(
                  "span",
                  {
                    staticClass: "badge_button",
                    on: {
                      click: function($event) {
                        _vm.add_to_query(
                          "(has " + e.edge + " / is " + e.edge + ")"
                        );
                      }
                    }
                  },
                  [_vm._v("+")]
                ),
                _c(
                  "span",
                  {
                    staticClass: "badge_button",
                    on: {
                      click: function($event) {
                        _vm.add_to_query("!(is " + e.edge + ")");
                      }
                    }
                  },
                  [_vm._v("-")]
                )
              ]),
              _c(
                "a",
                {
                  attrs: { href: "#" },
                  on: {
                    click: function($event) {
                      _vm.set_highlight("(is " + e.edge + ")");
                    }
                  }
                },
                [_vm._v(_vm._s(e.edge) + " (" + _vm._s(e.count) + ")")]
              )
            ])
          })
        ],
        2
      )
    ])
  };
  var __vue_staticRenderFns__$3 = [];
  __vue_render__$3._withStripped = true;

    /* style */
    const __vue_inject_styles__$3 = function (inject) {
      if (!inject) return
      inject("data-v-7e95ab42_0", { source: "\n.sidebar-item[data-v-7e95ab42] {\n    border:1px solid #66f;\n    border-radius:3px;\n    margin:1px;\n    overflow:hidden;\n    white-space:nowrap;\n    padding:2px;\n}\n.search-error[data-v-7e95ab42] {\n    font-family: monospace;\n    white-space: pre;\n    color: #e33;\n}\n.badge_button[data-v-7e95ab42] {\n    cursor:pointer;\n    margin-right:5px;\n    display: inline-block;\n    min-width: 10px;\n    padding: 3px 7px;\n    font-size: 12px;\n    font-weight: bold;\n    line-height: 1;\n    color: #fff;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: middle;\n    background-color: #777;\n    border-radius: 10px;\n    float:right;\n}\n.snippet_header[data-v-7e95ab42]{\n    border-radius: 10px;\n    padding: 5px;\n    width: 100%;\n    margin-bottom: 10px;\n}\n.snippet_title[data-v-7e95ab42]{\n    font-size: 20pt;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/views/Browse.vue"],"names":[],"mappings":";AAkSA;IACA,qBAAA;IACA,iBAAA;IACA,UAAA;IACA,eAAA;IACA,kBAAA;IACA,WAAA;AACA;AACA;IACA,sBAAA;IACA,gBAAA;IACA,WAAA;AACA;AACA;IACA,cAAA;IACA,gBAAA;IACA,qBAAA;IACA,eAAA;IACA,gBAAA;IACA,eAAA;IACA,iBAAA;IACA,cAAA;IACA,WAAA;IACA,kBAAA;IACA,mBAAA;IACA,sBAAA;IACA,sBAAA;IACA,mBAAA;IACA,WAAA;AACA;AACA;IACA,mBAAA;IACA,YAAA;IACA,WAAA;IACA,mBAAA;AACA;AAEA;IACA,eAAA;AACA","file":"Browse.vue","sourcesContent":["<template>\n    <div class=\"browse\">\n\t<div class=\"browse_container\" style=\"float:left;width:70%;\">\n\t    <div class=\"filterquery\">\n\t\t<!-- <input type=\"text\" id=\"query_input\" v-model=\"query\" v-on:keyup.enter=\"search\" /> -->\n\t\t<span>{{query}}</span>\n\t\t<span v-on:click=\"clear_filter()\" class=\"close_x\"><span class=\"fas fa-eraser\"></span></span>\n\t\t<span v-on:click=\"mode='list'\" class=\"close_x\"><span class=\"fas fa-list\"></span></span>\n\t\t<span v-on:click=\"mode='graph'\" class=\"close_x\"><span class=\"fas fa-project-diagram\"></span></span>\n\t    </div>\n\t    <div v-if=\"mode=='graph'\">\n\t\t<div style=\"float:left;width:100%;\">\n\t\t    <br />\n\t\t    <graph-index :nodeset=\"resultset\" :highlight=\"highlightset\" v-if=\"result.length > 0\"></graph-index>\n\t\t</div>\n\t    </div>\n\t    <div v-if=\"mode=='list'\">\n\t\t<node-index :nodeset=\"resultset\" v-if=\"result.length > 0\"></node-index>\n\t    </div>\n\t</div>\n\t<div class=\"querypanel\" style=\"float:left;width:30%;padding-left:10px;\">\n\t    <div style=\"float:left\">\n\t\t<input type=\"text\" id=\"highlight_input\" v-model=\"highlight_query\" v-on:keyup.enter=\"do_highlight\" />\n\t\t<span v-on:click=\"do_highlight()\" class=\"close_x\"><span class=\"fas fa-search\"></span></span>\n\t\t<span v-on:click=\"expand_highlight()\" class=\"close_x\"><span class=\"fas fa-plus\"></span></span>\n\t\t<span v-on:click=\"clear_highlight()\" class=\"close_x\"><span class=\"fas fa-backspace\"></span></span>\n\t\t<span v-on:click=\"set_query(highlight_query)\" class=\"close_x\"><span class=\"fas fa-search-plus\"></span></span>\n\t\t<span v-on:click=\"add_to_query('!('+highlight_query+')')\" class=\"close_x\"><span class=\"fas fa-search-minus\"></span></span>\n\t    </div>\n\n\t    <span class=\"search-error\" v-if=\"errormsg.length > 0\">{{errormsg}}</span>\n\t    <br /><br />\n\t    <div v-if=\"highlight.length == 0\">\n\t\t<b>Top nodes</b>\n\t\t<div v-for=\"n in best_nodes\" class=\"query_result\">\n\t\t    <div style=\"display:inline-block;\">\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('((=' + nodes[n.node].name + ')[2], !(=' + nodes[n.node].name + '))')\">+</span>\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('!(=' + nodes[n.node].name + ')')\">-</span>\n\t\t    </div>\n\t\t    <a href=\"#\" v-on:click=\"set_highlight('(=' + nodes[n.node].name + ')[1]')\">{{nodes[n.node].name}} ({{n.degree}})</a> \n\t\t</div>\n\t    </div>\n\t    <div v-if=\"highlight.length > 0\">\n\t\t<b>Top nodes in result</b>\n\t\t<div v-for=\"n in best_highlights\" class=\"query_result\">\n\t\t    <div style=\"display:inline-block;\">\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('((=' + nodes[n.node].name + ')[2], !(=' + nodes[n.node].name + '))')\">+</span>\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('!(=' + nodes[n.node].name + ')')\">-</span>\n\t\t    </div>\n\t\t    <a href=\"#\" v-on:click=\"set_highlight('(=' + nodes[n.node].name + ')[1]')\">{{nodes[n.node].name}} ({{n.degree}})</a> \n\t\t</div>\n\t    </div>\n\t    <hr />\n\t    <b>Top labels</b>\n\t    <div v-for=\"e in best_edges\" class=\"query_result\">\n\t\t<div style=\"display:inline-block;\">\n\t\t    <span class=\"badge_button\" v-on:click=\"add_to_query('(has ' + e.edge + ' / is ' + e.edge + ')')\">+</span>\n\t\t    <span class=\"badge_button\" v-on:click=\"add_to_query('!(is ' + e.edge + ')')\">-</span>\n\t\t</div>\n\t\t<a href=\"#\" v-on:click=\"set_highlight('(is ' + e.edge + ')')\">{{e.edge}} ({{e.count}})</a>\n\t    </div>\n\t</div>\n    </div>\n</template>\n\n<script>\n import Vue from 'vue'\n import { mapState } from 'vuex'\n\n export default {\n     name: 'browse',\n     computed: { \n\t resultset: function() {\n\t     var ans = {};\n\t     for(var r of this.result) {\n\t\t ans[r] = this.nodes[r];\n\t     }\n\t     return ans;\n\t },\n\t highlightset: function() {\n\t     var ans = {};\n\t     for(var r of this.highlight) {\n\t\t ans[r] = true;\n\t     }\n\t     console.log(ans);\n\t     return ans;\n\t },\n\t best_highlights: function() {\n\t     var nodes_by_deg = [];\n\t     for(var n in this.highlightset) {\n\t\t var targets = {}\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t for(var label in this.nodes[n].edges.is) {\n\t\t     for(var edge of this.nodes[n].edges.is[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t var deg = 0;\n\t\t for(var t in targets) {\n\t\t     deg++;\n\t\t }\n\t\t nodes_by_deg.push({\"node\":n,\"degree\":deg});\n\t     }\n\t     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });\n\t     return nodes_by_deg.slice(0,10);\n\t },\n\t best_nodes: function() {\n\t     var nodes_by_deg = [];\n\t     for(var n in this.resultset) {\n\t\t var targets = {}\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t for(var label in this.nodes[n].edges.is) {\n\t\t     for(var edge of this.nodes[n].edges.is[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t var deg = 0;\n\t\t for(var t in targets) {\n\t\t     deg++;\n\t\t }\n\t\t nodes_by_deg.push({\"node\":n,\"degree\":deg});\n\t     }\n\t     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });\n\t     return nodes_by_deg.slice(0,10);\n\t },\n\t best_edges: function() {\n\t     var edges_with_count = {};\n\t     for(var n in this.resultset) {\n\t\t var count = 0;\n\t\t // only need to count the has direction since the is direction will be accounted for when iterating over the has edges of the target\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     if(!(label in edges_with_count)) {\n\t\t\t edges_with_count[label] = 0\n\t\t     }\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     edges_with_count[label]++;\n\t\t\t }\n\t\t     }\n\t\t }\n\t     }\n\t     var edges_by_count = [];\n\t     for(var e in edges_with_count) {\n\t\t edges_by_count.push({\"edge\":e,\"count\":edges_with_count[e]})\n\t     }\n\t     edges_by_count.sort(function(a, b){return b.count-a.count;});\n\t     return edges_by_count.slice(0,10);\n\t },\n\t ...mapState(['nodes', 'node_data']),\n     },\n     data() {\n\t return {\n\t     entered_query: '',\n\t     query: '',\n\t     highlight_query: '',\n\t     errormsg: '',\n\t     result: [],\n\t     highlight: [],\n\t     mode: 'graph',\n\t }\n     },\n     watch: {\n\t nodes: function(val) {\n\t     this.$nextTick(function () {\n\t\t this.search();\n\t     });\n\t }\n     },\n     methods: {\n\t add_to_query: function(qry) {\n\t     if(this.query.trim().length > 0 && this.query.trim() != \"*\") {\n\t\t this.query = \"(\"+this.query+\"),\"+qry;\n\t     }\n\t     else {\n\t\t this.query = qry;\n\t     }\n\t     this.search();\n\t },\n\t set_query: function(qry) {\n\t     this.query = qry;\n\t     this.highlight_query = \"\";\n\t     this.do_highlight();\n\t     this.search();\n\t },\n\t set_highlight: function(qry) {\n\t     this.highlight_query = qry;\n\t     this.do_highlight();\n\t },\n\t run_search: function(qry, nodeset) {\n\t     this.entered_query = qry;\n\t     this.errormsg = \"\";\n\t     if(qry.trim().length == 0) {\n\t\t return [];\n\t     }\n\t     try {\n\t\t var q = Vue.category_query.parse(qry);\n\t     }\n\t     catch(e){\n\t\t this.errormsg = e.toString();\n\t\t return [];\n\t     }\n\t     return Vue.category_search(q, nodeset);\n\t },\n\t search: function() {\n\t     if(this.query.trim().length == 0) {\n\t\t this.query = \"*\";\n\t     }\n\t     var query_result = this.run_search(this.query, this.nodes)\n\t     console.log(query_result);\n\t     if(query_result.length == 0) {\n\t\t return;\n\t     }\n\t     if(query_result.length == 1) {\n\t\t this.$router.push('/node/'+query_result[0]);\n\t     }\n\t     else {\n\t\t this.result = query_result;\n\t\t console.log(\"RES\",this.result);\n\t\t for(var i = 0; i < this.result.length; i++){\n\t\t     if(this.nodes[this.result[i]].name == this.query.trim()) {\n\t\t\t this.$router.push('/node/'+this.result[i]);\n\t\t\t break;\n\t\t     }\n\t\t }\n\t     }\n\t },\n\t do_highlight: function() {\n\t     this.highlight = this.run_search(this.highlight_query, this.resultset);\n\t },\n\t expand_highlight: function() {\n\t     this.highlight_query = \"(\"+this.highlight_query+\")[1]\";\n\t     this.do_highlight();\n\t },\n\t clear_highlight: function() {\n\t     this.highlight_query = \"\";\n\t     this.do_highlight();\n\t },\n\t new_node: function(event){\n\t     var self = this;\n\t     var fetch_headers = new Headers();\n\t     fetch_headers.append('pragma', 'no-cache');\n\t     fetch_headers.append('cache-control', 'no-cache');\n\t     \n\t     var fetch_params = {\n\t\t method: 'GET',\n\t\t headers: fetch_headers,\n\t     };\n\t     fetch('/new', fetch_params).then(function(response){\n\t\t response.text().then(function(data){\n\t\t     console.log(data);\n\t\t });\n\t     });\n\t },\n\t clear_filter: function() {\n\t     this.query = '*';\n\t     this.search();\n\t     this.do_highlight();\n\t }\n     },\n     mounted: function() {\n\t this.query = '*';\n\t this.search();\n     }\n }\n\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n .sidebar-item {\n     border:1px solid #66f;\n     border-radius:3px;\n     margin:1px;\n     overflow:hidden;\n     white-space:nowrap;\n     padding:2px;\n }\n .search-error {\n     font-family: monospace;\n     white-space: pre;\n     color: #e33;\n }\n .badge_button {\n     cursor:pointer;\n     margin-right:5px;\n     display: inline-block;\n     min-width: 10px;\n     padding: 3px 7px;\n     font-size: 12px;\n     font-weight: bold;\n     line-height: 1;\n     color: #fff;\n     text-align: center;\n     white-space: nowrap;\n     vertical-align: middle;\n     background-color: #777;\n     border-radius: 10px;\n     float:right;\n }\n .snippet_header{\n     border-radius: 10px;\n     padding: 5px;\n     width: 100%;\n     margin-bottom: 10px;\n }\n\n .snippet_title{\n     font-size: 20pt;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$3 = "data-v-7e95ab42";
    /* module identifier */
    const __vue_module_identifier__$3 = undefined;
    /* functional template */
    const __vue_is_functional_template__$3 = false;
    /* style inject SSR */
    

    
    var Browse = normalizeComponent_1(
      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
      __vue_inject_styles__$3,
      __vue_script__$2,
      __vue_scope_id__$3,
      __vue_is_functional_template__$3,
      __vue_module_identifier__$3,
      browser,
      undefined
    );

  Vue$1.use(VueRouter);

  var router = new VueRouter({
      mode: 'history',
      base: '/',
      routes: [
  	{
  	    path: '/',
  	    name: 'home',
  	    component: Home
  	},
  	{
  	    path: '/node/:id',
  	    name: 'node',
  	    component: Node,
  	    props: true
  	    // route level code-splitting
  	    // this generates a separate chunk (about.[hash].js) for this route
  	    // which is lazy-loaded when the route is visited.
  	    // component: function () { 
  	    //   return import(/* webpackChunkName: "about" */ './views/Node.vue')
  	    // }
  	},
  	{
  	    path: '/browse/:query',
  	    name: 'browse',
  	    component: Browse,
  	    props:true
  	}
      ]
  });

  Vue$1.use(index_esm);

  var store = new index_esm.Store({
      state: {
  	query: 'is category',
  	ready: false,
  	current: '',
  	nodes: {},
  	recent: [],
  	node_data: {},
  	plugin_data: {}
      },
      getters: {
  	neighbours: state => node_id => {
  	    let node = state.nodes[node_id];
  	    var ans = {};
  	    for(var d in node.edges) {
  		for(var l in node.edges[d]) {
  		    for(var edge of node.edges[d][l]) {
  			ans[edge.target] = state.nodes[edge.target];
  		    }
  		}
  	    }
  	    return ans;
  	},
  	sorted: state => nodelist => {
  	    return nodelist.sort(function(a, b){
  		if('index' in state.nodes[a] && 'index' in state.nodes[b]) {
  		    return parseInt(state.nodes[a].index) - parseInt(state.nodes[b].index);
  		}
  		else if('date' in state.nodes[a] && 'date' in state.nodes[b]) {
  		    return state.nodes[a].date.localeCompare(state.nodes[b].date);
  		}
  		else return state.nodes[a].name.localeCompare(state.nodes[b].name);
  	    });
  	},
  	sortedby: state => (nodeset, nodelist, key, ascending) => {
  	    var ans = nodelist.sort(function(a, b){
  		var res = 0;
  		if (key in nodeset[a] && key in nodeset[b]) {
  		    //console.log("arr by",key);
  		    if (key == 'index') {
  			var res = parseInt(nodeset[a].index) - parseInt(nodeset[b].index);
  			return ascending ? res : -res;
  		    }
  		    var res = nodeset[a][key].localeCompare(nodeset[b][key]);
  		    return ascending ? res : -res;
  		} // Place things without properties 
  		else if (!(key in nodeset[a]) && key in nodeset[b]) {
  		    return 1;
  		}
  		else if ((key in nodeset[a]) && !(key in nodeset[b])) {
  		    return -1;
  		}
  		return ascending ? res : -res;
  	    });
  	    console.log(ans);
  	    return ans;
  	}
      }, 
      mutations: {
  	CACHE: (state, nodes) => {
  	    //node_data = plugin_process(state, node_id, node_data);
  	    console.log('caching',nodes);
  	    if(state.ready) {
  		for(var node_id in nodes){
  		    if(state.nodes[node_id].auto) {
  			state.nodes[node_id].snippet = "[index node]";
  		    }
  		    state.node_data[node_id] = nodes[node_id];
  		}
  	    }
  	},
  	PLUGIN_DATA_STORE: (state, data) => {
  	    //node_data = plugin_process(state, node_id, node_data);
  	    console.log('storing',data);
  	    for(var plugin_id in data){
  		state.plugin_data[plugin_id] = data[plugin_id];
  	    }
  	},
  	CLEAR_HISTORY: state => {
  	    state.recent = [];
  	},
  	REMOVE_FROM_HISTORY: (state, node_id) => {
  	    var idx = -1;
  	    for(var i = 0; i < state.recent.length; i++) {
  		if(state.recent[i].id == node_id) {
  		    idx = i;
  		    break;
  		}
  	    }
  	    if(idx >= 0) state.recent.splice(idx,1);
  	},
  	GO: (state, node_id) => {
  	    console.log('historicising');
  	    console.log(state.recent);
  	    state.current = node_id;
  	    var idx = -1;
  	    for(var i = 0; i < state.recent.length; i++) {
  		if(state.recent[i].id == node_id) {
  		    idx = i;
  		    break;
  		}
  	    }
  	    if(idx < 0) {
  		state.recent.unshift({"id":node_id,"fixed":false});
  	    }
  	    // else {
  	    // 	// Move to top if already in working set
  	    // 	state.recent.splice(idx, 1);
  	    // }
  	},
  	METADATA: (state, nodes) => {
  	    state.nodes = nodes;
  	    state.recent = [];
  	    state.ready = true;
  	    state.query = "is category";
  	}
      },
      actions: {
  	cache: (context, nodes) => {
  	    context.commit('CACHE',nodes);
  	},
  	clear_history: (context) => {
  	    context.commit('CLEAR_HISTORY');
  	},
  	reset_metadata: (context, data) => {
  	    context.commit('METADATA', data);
  	},
  	remove_from_history: (context, node_id) => {
  	    context.commit('REMOVE_FROM_HISTORY', node_id);
  	},
  	go: (context, node_id) => {
  	    context.commit('GO', node_id);
  	},
  	refresh_metadata: (context) => {
  	    var fetch_headers = new Headers();
  	    fetch_headers.append('pragma', 'no-cache');
  	    fetch_headers.append('cache-control', 'no-cache');
  	    
  	    var fetch_params = {
  		method: 'GET',
  		headers: fetch_headers,
  	    };
  	    return new Promise((resolve, reject) => {
  		fetch('/out/metadata.json', fetch_params).then(function(response){
  	    	    response.json().then(function(data){
  	    		context.commit('METADATA', data);
  			resolve();
  	    	    });
  		});
  	    });
  	    // fetch('/out/metadata.json', fetch_params).then(function(response){
  	    // 	console.log("R",response);
  	    // 	response.json().then(function(data){
  	    // 	    context.commit('METADATA', data);
  	    // 	});
  	    // });

  	}
      }
  });

  //
   
   var script$3 = {
       name: 'node-index',
       props: ['nodeset','node'],
       data() {
  	 return {
  	     'current_label': 'blah',
  	     'modes': {},
  	     'sort_method': 'name',
  	     'sort_is_ascending': true
  	 }
       },
       computed: {
  	 sorted_nodes: function() {
  	     var ans = [];
  	     for(var n in this.nodeset) {
  		 ans.push(n);
  	     }
  	     return this.sortedby(this.nodeset, ans, this.sort_method, this.sort_is_ascending)
  	 },
  	 nodelist: function() {
  	     var ans = [];
  	     for(var n in this.nodeset) {
  		 ans.push(n);
  	     }
  	     return ans;
  	 },
  	 num_nodes: function() {
  	     var ans = 0;
  	     for(var n in this.nodeset) ans++;
  	     return ans;
  	 },
  	 labeldata: function() {
  	     // The result is:
  	     // {
  	     //   disconnected: [],
  	     //   labels: {},
  	     // }

  	     var disconnected_nodes = [];
  	     var modes = {};
  	     var best_label = '';
  	     
  	     // We build the data structure needed to prepare the index.
  	     // For each label, we create an entry like:
  	     // {
  	     //   count: how many nodes does this label cover
  	     //   covered: the set of nodes hit by the eddge
  	     //   has: the list of nodes that "have" this edge
  	     //   is: the list of nodes that "is" this edge
  	     // }
  	     var all_labels = {}; 
  	     for(var n in this.nodeset) {
  		 for(var e in this.nodeset[n].edges.has) {
  		     if(!(e in all_labels)) all_labels[e] = {'count':0, 'covered':{},'has':[],'is':[], 'mode':''};
  		     for(var t in this.nodeset[n].edges.has[e]){
  			 t = this.nodeset[n].edges.has[e][t].target;
  			 if(!(t in this.nodeset)) continue;
  			 if(!all_labels[e].covered[t]){
  			     // We haven't seen this node before
  			     all_labels[e].covered[t] = true;
  			     all_labels[e].count++;
  			 }
  			 if(all_labels[e].has.indexOf(n) == -1)
  			     all_labels[e].has.push(n);
  		     }
  		 }
  		 for(var e in this.nodeset[n].edges.is){
  		     if(!(e in all_labels)) all_labels[e] = {'count':0, 'covered':{},'has':[],'is':[], 'mode':''};
  		     for(var t in this.nodeset[n].edges.is[e]){
  			 t = this.nodeset[n].edges.is[e][t].target;
  			 if(!(t in this.nodeset)) continue;
  			 if(!all_labels[e].covered[t]){
  			     // We haven't seen this node before
  			     all_labels[e].covered[t] = true;
  			     all_labels[e].count++;
  			 }
  			 if(all_labels[e].is.indexOf(n) == -1)
  			     all_labels[e].is.push(n);
  		     }
  		 }
  	     }
  	     // Place the labels into a sorted list in order of
  	     // most edges to fewest edges (also, take this
  	     // opportunity to select the mode)
  	     var sorted_labels = [];
  	     for(var l in all_labels){
  		 if(all_labels[l].count == 0) continue;
  		 modes[l] = all_labels[l].is.length < all_labels[l].has.length ? 'by' : 'menu';
  		 sorted_labels.push(l);
  	     }
  	     var discriminitivity = function(l){
  		 // Intuitively, we are going to arrange the |count|
  		 // nodes in a rectangle with |has| or |is| columns. This
  		 // is the most "discriminitave" if the rectangle is a
  		 // square, i.e. |has| or |is| is close to sqrt(|count|).
  		     
  		 // However, we also want to normalise for number of
  		 // nodes, to a point, and we want to penalise being too close to the useless values of 

  		 var N = all_labels[l].count;
  		 var tgt = Math.sqrt(N);
  		 var scores = [];
  		 var ns = [all_labels[l].has.length, all_labels[l].is.length];
  		 for(var i = 0; i < 2; i++) {
  		     var n = ns[i];
  		     var tgt_score = 1-(tgt-n)*(tgt-n)/(N*N); // This rewards being close to sqrt(N) -- bigger is better
  		     var avoid_ends_score = Math.min(0, (n-1)*(N/2-n)/(N*N)); // This penalises being too close to 1 or N/2--bigger is better
  		     var nodes_score = Math.log(N+1); // This factors in number of nodes a little (containing more is better than few, but only meaningfully so if an order of magnitude more)
  		     var score = nodes_score*(tgt_score + avoid_ends_score);
  		     
  		     console.log("D",l,i,tgt_score, avoid_ends_score, nodes_score,score);   
  		     scores.push(score);
  		 }
  		 return Math.max(scores[0], scores[1]);
  	     };
  	     console.log("ALAL",all_labels);
  	     sorted_labels.sort(function(a, b){
  		 var da = discriminitivity(a);
  		 var db = discriminitivity(b);
  		 // We want to sort in increa
  		 if(da < db) return 1; // Sort a before b
  		 if(da > db) return -1; // Sort b before a
  		 return 0;
  	     });
  	     // Prep a set of all nodes so we can mark which ones we've finished
  	     var finished_nodes = {};
  	     var nodes_count = 0;
  	     var finished_count = 0;
  	     for(var n in this.nodeset) {
  		 // Only count nodes with actual edges; we'll deal
  		 // with disconnected ones separately
  		 var disconnected = true;
  		 for(var e in this.nodeset[n].edges.has){
  		     for(var i = 0; i < this.nodeset[n].edges.has[e].length; i++){
  			 t = this.nodeset[n].edges.has[e][i].target;
  			 if(this.nodeset[t]) disconnected = false;
  		     }
  		 }
  		 for(var e in this.nodeset[n].edges.is){
  		     for(var i = 0; i < this.nodeset[n].edges.is[e].length; i++){
  			 t = this.nodeset[n].edges.is[e][i].target;
  			 if(this.nodeset[t]) disconnected = false;
  		     }
  		 }
  		 if(disconnected){
  		     disconnected_nodes.push(n);
  		 }
  		 else {
  		     finished_nodes[n] = false;
  		     nodes_count++;
  		 }
  	     }

  	     // Now we want to collect the labels we will use for
  	     // indexing as well as figure out what modes to
  	     // display them in
  	     var best_labels = [];
  	     
  	     // Run through the labels
  	     for(var i = 0; i < sorted_labels.length; i++) {
  		 best_labels.push(sorted_labels[i]);
  		 // Mark all nodes covered as finished:
  		 for(var n in sorted_labels[i].covered){
  		     if(!finished_nodes[n]){
  			 finished_count++;
  			 finished_nodes[n] = true;
  		     }
  		 }
  		 // We cut short the use of labels, but only if we have
  		 // exhausted all the connected nodes, each under at
  		 // least one label already _and_ only if we already
  		 // have a lot of labels (> 20)
  		 if(finished_count == nodes_count && best_labels.length > 20) {
  		     break;
  		 }
  	     }

  	     // Now we are done!
  	     if(best_labels.length == 1) best_label = best_labels[0];
  	     else best_label = 'all';
  	     this.current_label = best_label;
  	     this.modes = modes;
  	     return {
  		 'disconnected': disconnected_nodes,
  		 'labels': best_labels
  	     };
  	 },
  	 ...mapState(['nodes']),
  	 ...mapGetters(['sorted','sortedby'])
       },
       methods: {
  	 sortasc: function(ascending) {
  	     Vue.set(this, 'sort_is_ascending', ascending);
  	 },
  	 sortby: function(key) {
  	     Vue.set(this, 'sort_method', key);
  	 },
  	 toggle_display: function(l) {
   	     this.current_label = l;
  	 },
  	 swap_mode: function(l) {
   	     this.modes[l] = (this.modes[l] == 'by' ? 'menu' : 'by');
   	     //this.$forceUpdate();
  	 },

       }
   };

  /* script */
  const __vue_script__$3 = script$3;

  /* template */
  var __vue_render__$4 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "node-index-container" }, [
      _c(
        "div",
        { staticClass: "node-index-menu" },
        [
          _vm.num_nodes > 0
            ? _c(
                "div",
                {
                  class:
                    "node-index-menu-item " +
                    (_vm.current_label == "all"
                      ? "node-index-menu-selected"
                      : ""),
                  on: {
                    click: function($event) {
                      return _vm.toggle_display("all")
                    }
                  }
                },
                [_vm._v("\n\t\t(all)\n            ")]
              )
            : _vm._e(),
          _vm._l(_vm.labeldata.labels, function(l) {
            return _c(
              "div",
              {
                class:
                  "node-index-menu-item " +
                  (_vm.current_label == l ? "node-index-menu-selected" : ""),
                on: {
                  click: function($event) {
                    return _vm.toggle_display(l)
                  }
                }
              },
              [_vm._v("\n\t\t" + _vm._s(l) + "\n            ")]
            )
          }),
          _vm.labeldata.disconnected &&
          _vm.labeldata.disconnected.length > 0 &&
          _vm.labeldata.disconnected.length < _vm.num_nodes
            ? _c(
                "div",
                {
                  class:
                    "node-index-menu-item " +
                    (_vm.current_label == "unlinked"
                      ? "node-index-menu-selected"
                      : ""),
                  on: {
                    click: function($event) {
                      return _vm.toggle_display("unlinked")
                    }
                  }
                },
                [_vm._v("\n\t\t(unlinked)\n            ")]
              )
            : _vm._e()
        ],
        2
      ),
      _vm.current_label != "all" && _vm.current_label != "unlinked"
        ? _c(
            "div",
            { staticClass: "node-index-list" },
            [
              _c("h3", [
                _vm._v(
                  _vm._s(
                    _vm.modes[_vm.current_label] == "by"
                      ? "By " + _vm.current_label
                      : "Has " + _vm.current_label
                  ) + " "
                ),
                _c(
                  "span",
                  {
                    staticStyle: { cursor: "pointer", "font-size": ".5em" },
                    on: {
                      click: function($event) {
                        return _vm.swap_mode(_vm.current_label)
                      }
                    }
                  },
                  [_c("span", { staticClass: "fas fa-random" })]
                ),
                !_vm.sort_is_ascending
                  ? _c(
                      "span",
                      {
                        staticStyle: {
                          "margin-left": "1em",
                          float: "right",
                          cursor: "pointer",
                          "font-size": ".5em"
                        },
                        on: {
                          click: function($event) {
                            return _vm.sortasc(true)
                          }
                        }
                      },
                      [_c("span", { staticClass: "fas fa-long-arrow-alt-up" })]
                    )
                  : _vm._e(),
                _vm.sort_is_ascending
                  ? _c(
                      "span",
                      {
                        staticStyle: {
                          "margin-left": "1em",
                          float: "right",
                          cursor: "pointer",
                          "font-size": ".5em"
                        },
                        on: {
                          click: function($event) {
                            return _vm.sortasc(false)
                          }
                        }
                      },
                      [_c("span", { staticClass: "fas fa-long-arrow-alt-down" })]
                    )
                  : _vm._e(),
                _c(
                  "span",
                  {
                    class: { sortkey_selected: _vm.sort_method == "name" },
                    staticStyle: {
                      "margin-left": "1em",
                      float: "right",
                      cursor: "pointer",
                      "font-size": ".5em"
                    },
                    on: {
                      click: function($event) {
                        return _vm.sortby("name")
                      }
                    }
                  },
                  [_vm._v("name")]
                ),
                _c(
                  "span",
                  {
                    class: { sortkey_selected: _vm.sort_method == "date" },
                    staticStyle: {
                      "margin-left": "1em",
                      float: "right",
                      cursor: "pointer",
                      "font-size": ".5em"
                    },
                    on: {
                      click: function($event) {
                        return _vm.sortby("date")
                      }
                    }
                  },
                  [_vm._v("date")]
                ),
                _c(
                  "span",
                  {
                    staticStyle: {
                      "margin-left": "1em",
                      float: "right",
                      "font-size": ".5em"
                    }
                  },
                  [_vm._v("Sort by:")]
                )
              ]),
              _c("label-index", {
                attrs: {
                  label: _vm.current_label,
                  mode: _vm.modes[_vm.current_label],
                  nodeset: _vm.nodeset,
                  sortkey: _vm.sort_method,
                  sortasc: _vm.sort_is_ascending
                }
              })
            ],
            1
          )
        : _vm._e(),
      _vm.current_label == "all" && _vm.num_nodes > 0
        ? _c("div", { staticClass: "node-index-list" }, [
            _vm.node
              ? _c(
                  "div",
                  [
                    _c("h3", [_vm._v("All edges")]),
                    _c("edge-display", { attrs: { node: _vm.node } })
                  ],
                  1
                )
              : _vm._e(),
            !_vm.node
              ? _c("div", [
                  _c("h3", [
                    _vm._v("All nodes\n\t\t    "),
                    !_vm.sort_is_ascending
                      ? _c(
                          "span",
                          {
                            staticStyle: {
                              "margin-left": "1em",
                              float: "right",
                              cursor: "pointer",
                              "font-size": ".5em"
                            },
                            on: {
                              click: function($event) {
                                return _vm.sortasc(true)
                              }
                            }
                          },
                          [
                            _c("span", {
                              staticClass: "fas fa-long-arrow-alt-up"
                            })
                          ]
                        )
                      : _vm._e(),
                    _vm.sort_is_ascending
                      ? _c(
                          "span",
                          {
                            staticStyle: {
                              "margin-left": "1em",
                              float: "right",
                              cursor: "pointer",
                              "font-size": ".5em"
                            },
                            on: {
                              click: function($event) {
                                return _vm.sortasc(false)
                              }
                            }
                          },
                          [
                            _c("span", {
                              staticClass: "fas fa-long-arrow-alt-down"
                            })
                          ]
                        )
                      : _vm._e(),
                    _c(
                      "span",
                      {
                        class: { sortkey_selected: _vm.sort_method == "name" },
                        staticStyle: {
                          "margin-left": "1em",
                          float: "right",
                          cursor: "pointer",
                          "font-size": ".5em"
                        },
                        on: {
                          click: function($event) {
                            return _vm.sortby("name")
                          }
                        }
                      },
                      [_vm._v("name")]
                    ),
                    _c(
                      "span",
                      {
                        class: { sortkey_selected: _vm.sort_method == "date" },
                        staticStyle: {
                          "margin-left": "1em",
                          float: "right",
                          cursor: "pointer",
                          "font-size": ".5em"
                        },
                        on: {
                          click: function($event) {
                            return _vm.sortby("date")
                          }
                        }
                      },
                      [_vm._v("date")]
                    ),
                    _c(
                      "span",
                      {
                        staticStyle: {
                          "margin-left": "1em",
                          float: "right",
                          "font-size": ".5em"
                        }
                      },
                      [_vm._v("Sort by:")]
                    )
                  ]),
                  _c(
                    "ul",
                    _vm._l(_vm.sorted_nodes, function(n) {
                      return _c(
                        "li",
                        [
                          _c("router-link", { attrs: { to: "/node/" + n } }, [
                            _vm._v(_vm._s(_vm.nodeset[n].name) + " "),
                            "date" in _vm.nodeset[n]
                              ? _c(
                                  "span",
                                  {
                                    staticStyle: {
                                      "font-size": ".5em",
                                      color: "#666"
                                    }
                                  },
                                  [_vm._v(_vm._s(_vm.nodeset[n].date))]
                                )
                              : _vm._e()
                          ])
                        ],
                        1
                      )
                    }),
                    0
                  )
                ])
              : _vm._e()
          ])
        : _vm._e(),
      _vm.current_label == "unlinked"
        ? _c("div", { staticClass: "node-index-list" }, [
            _c("h3", [_vm._v("Unlinked")]),
            _c(
              "ul",
              _vm._l(_vm.sorted(_vm.labeldata.disconnected), function(n) {
                return _c(
                  "li",
                  [
                    _c("router-link", { attrs: { to: "/node/" + n } }, [
                      _vm._v(_vm._s(_vm.nodeset[n].name))
                    ])
                  ],
                  1
                )
              }),
              0
            )
          ])
        : _vm._e(),
      _c("div", { staticClass: "spacer", staticStyle: { clear: "both" } })
    ])
  };
  var __vue_staticRenderFns__$4 = [];
  __vue_render__$4._withStripped = true;

    /* style */
    const __vue_inject_styles__$4 = function (inject) {
      if (!inject) return
      inject("data-v-0d2523a4_0", { source: "\n.sortkey_selected[data-v-0d2523a4] {\n    text-decoration:underline;\n}\n.node-index-menu[data-v-0d2523a4] {\n    width: 24%;\n    float:left;\n}\n.node-index-menu-item[data-v-0d2523a4] {\n    width: 90%;\n    border-radius:8px;\n    padding:5px;\n    margin:2px;\n    cursor:pointer;\n    background-color: #ccf !important;\n}\n.node-index-menu-selected[data-v-0d2523a4] {\n    background-color: #99c !important;\n}\n.node-index-list[data-v-0d2523a4] {\n    width: 72%;\n    float:left;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/components/nodes.vue"],"names":[],"mappings":";AA8RA;IACA,yBAAA;AACA;AAEA;IACA,UAAA;IACA,UAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,WAAA;IACA,UAAA;IACA,cAAA;IACA,iCAAA;AACA;AAGA;IACA,iCAAA;AACA;AAEA;IACA,UAAA;IACA,UAAA;AACA","file":"nodes.vue","sourcesContent":["<template>\n    <div class=\"node-index-container\">\n\t<div class=\"node-index-menu\">\n            <div v-on:click=\"toggle_display('all')\" v-bind:class=\"'node-index-menu-item ' + (current_label == 'all' ? 'node-index-menu-selected' : '')\" v-if=\"num_nodes > 0\">\n\t\t(all)\n            </div>\n            <div v-on:click=\"toggle_display(l)\" v-bind:class=\"'node-index-menu-item ' + (current_label == l ? 'node-index-menu-selected' : '')\" v-for=\"l in labeldata.labels\">\n\t\t{{l}}\n            </div>\n            <div v-on:click=\"toggle_display('unlinked')\" v-bind:class=\"'node-index-menu-item ' + (current_label == 'unlinked' ? 'node-index-menu-selected' : '')\" v-if=\"labeldata.disconnected && labeldata.disconnected.length > 0 && labeldata.disconnected.length < num_nodes\">\n\t\t(unlinked)\n            </div>\n\t</div>\n\t\n\t<!-- List of edges associated with current_label -->\n\t<div class=\"node-index-list\" v-if=\"current_label != 'all' && current_label != 'unlinked'\">\n            <h3>{{modes[current_label] == 'by' ? 'By ' + current_label : 'Has ' + current_label}} <span style=\"cursor:pointer;font-size:.5em;\" v-on:click=\"swap_mode(current_label)\"><span class=\"fas fa-random\"></span></span>\n\t\t<span v-if=\"!sort_is_ascending\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortasc(true)\">\n\t\t    <span class=\"fas fa-long-arrow-alt-up\"></span>\n\t\t</span>\n\t\t<span v-if=\"sort_is_ascending\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortasc(false)\">\n\t\t    <span class=\"fas fa-long-arrow-alt-down\"></span>\n\t\t</span>\n\t\t<span v-bind:class=\"{'sortkey_selected': sort_method == 'name'}\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortby('name')\">name</span>\n\t\t<span v-bind:class=\"{'sortkey_selected': sort_method == 'date'}\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortby('date')\">date</span>\n\t\t<span style=\"margin-left:1em;float:right;font-size:.5em;\">Sort by:</span>\n\t    </h3>\n            <label-index :label=\"current_label\" :mode=\"modes[current_label]\" :nodeset=\"nodeset\" v-bind:sortkey=\"sort_method\" v-bind:sortasc=\"sort_is_ascending\" />\n\t</div>\n\t\n\t<!-- List of all edges -->\n\t<div class=\"node-index-list\" v-if=\"current_label == 'all' && num_nodes > 0\">\n            <div v-if=\"node\">\n\t\t<h3>All edges</h3>\n    \t\t<edge-display :node=\"node\"></edge-display>\n            </div>\n            <div v-if=\"!node\">\n\t\t<h3>All nodes\n\t\t    <span v-if=\"!sort_is_ascending\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortasc(true)\">\n\t\t\t<span class=\"fas fa-long-arrow-alt-up\"></span>\n\t\t    </span>\n\t\t    <span v-if=\"sort_is_ascending\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortasc(false)\">\n\t\t\t<span class=\"fas fa-long-arrow-alt-down\"></span>\n\t\t    </span>\n\t\t    <span v-bind:class=\"{'sortkey_selected': sort_method == 'name'}\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortby('name')\">name</span>\n\t\t    <span v-bind:class=\"{'sortkey_selected': sort_method == 'date'}\" style=\"margin-left:1em;float:right;cursor:pointer;font-size:.5em;\" v-on:click=\"sortby('date')\">date</span>\n\t\t    <span style=\"margin-left:1em;float:right;font-size:.5em;\">Sort by:</span>\n\t\t</h3>\n    \t\t<ul>\n\t\t    <li v-for=\"n in sorted_nodes\">\n\t\t\t<router-link :to=\"'/node/'+n\">{{nodeset[n].name}} <span v-if=\"'date' in nodeset[n]\" style=\"font-size:.5em;color:#666;\">{{nodeset[n].date}}</span></router-link>\n\t\t    </li>\n    \t\t</ul>\n            </div>\n\t</div>\n\t\n\t<!-- List of unlinked nodes -->\n\t<div class=\"node-index-list\" v-if=\"current_label == 'unlinked'\">\n            <h3>Unlinked</h3>\n            <ul>\n    \t\t<li v-for=\"n in sorted(labeldata.disconnected)\">\n    \t\t    <router-link :to=\"'/node/'+n\">{{nodeset[n].name}}</router-link>\n    \t\t</li>\n            </ul>\n\t</div>\n\t\n\t<div class=\"spacer\" style=\"clear: both;\"></div>\n    </div>\n</template>\n\n<script>\n import { mapState } from 'vuex'\n import { mapGetters } from 'vuex'\n \n export default {\n     name: 'node-index',\n     props: ['nodeset','node'],\n     data() {\n\t return {\n\t     'current_label': 'blah',\n\t     'modes': {},\n\t     'sort_method': 'name',\n\t     'sort_is_ascending': true\n\t }\n     },\n     computed: {\n\t sorted_nodes: function() {\n\t     var ans = [];\n\t     for(var n in this.nodeset) {\n\t\t ans.push(n);\n\t     }\n\t     return this.sortedby(this.nodeset, ans, this.sort_method, this.sort_is_ascending)\n\t },\n\t nodelist: function() {\n\t     var ans = [];\n\t     for(var n in this.nodeset) {\n\t\t ans.push(n);\n\t     }\n\t     return ans;\n\t },\n\t num_nodes: function() {\n\t     var ans = 0;\n\t     for(var n in this.nodeset) ans++;\n\t     return ans;\n\t },\n\t labeldata: function() {\n\t     // The result is:\n\t     // {\n\t     //   disconnected: [],\n\t     //   labels: {},\n\t     // }\n\n\t     var disconnected_nodes = [];\n\t     var modes = {};\n\t     var best_label = ''\n\t     \n\t     // We build the data structure needed to prepare the index.\n\t     // For each label, we create an entry like:\n\t     // {\n\t     //   count: how many nodes does this label cover\n\t     //   covered: the set of nodes hit by the eddge\n\t     //   has: the list of nodes that \"have\" this edge\n\t     //   is: the list of nodes that \"is\" this edge\n\t     // }\n\t     var all_labels = {}; \n\t     for(var n in this.nodeset) {\n\t\t for(var e in this.nodeset[n].edges.has) {\n\t\t     if(!(e in all_labels)) all_labels[e] = {'count':0, 'covered':{},'has':[],'is':[], 'mode':''};\n\t\t     for(var t in this.nodeset[n].edges.has[e]){\n\t\t\t t = this.nodeset[n].edges.has[e][t].target;\n\t\t\t if(!(t in this.nodeset)) continue;\n\t\t\t if(!all_labels[e].covered[t]){\n\t\t\t     // We haven't seen this node before\n\t\t\t     all_labels[e].covered[t] = true;\n\t\t\t     all_labels[e].count++;\n\t\t\t }\n\t\t\t if(all_labels[e].has.indexOf(n) == -1)\n\t\t\t     all_labels[e].has.push(n);\n\t\t     }\n\t\t }\n\t\t for(var e in this.nodeset[n].edges.is){\n\t\t     if(!(e in all_labels)) all_labels[e] = {'count':0, 'covered':{},'has':[],'is':[], 'mode':''};\n\t\t     for(var t in this.nodeset[n].edges.is[e]){\n\t\t\t t = this.nodeset[n].edges.is[e][t].target;\n\t\t\t if(!(t in this.nodeset)) continue;\n\t\t\t if(!all_labels[e].covered[t]){\n\t\t\t     // We haven't seen this node before\n\t\t\t     all_labels[e].covered[t] = true;\n\t\t\t     all_labels[e].count++;\n\t\t\t }\n\t\t\t if(all_labels[e].is.indexOf(n) == -1)\n\t\t\t     all_labels[e].is.push(n);\n\t\t     }\n\t\t }\n\t     }\n\t     // Place the labels into a sorted list in order of\n\t     // most edges to fewest edges (also, take this\n\t     // opportunity to select the mode)\n\t     var sorted_labels = [];\n\t     for(var l in all_labels){\n\t\t if(all_labels[l].count == 0) continue;\n\t\t modes[l] = all_labels[l].is.length < all_labels[l].has.length ? 'by' : 'menu';\n\t\t sorted_labels.push(l);\n\t     }\n\t     var discriminitivity = function(l){\n\t\t // Intuitively, we are going to arrange the |count|\n\t\t // nodes in a rectangle with |has| or |is| columns. This\n\t\t // is the most \"discriminitave\" if the rectangle is a\n\t\t // square, i.e. |has| or |is| is close to sqrt(|count|).\n\t\t     \n\t\t // However, we also want to normalise for number of\n\t\t // nodes, to a point, and we want to penalise being too close to the useless values of \n\n\t\t var N = all_labels[l].count;\n\t\t var tgt = Math.sqrt(N);\n\t\t var scores = [];\n\t\t var ns = [all_labels[l].has.length, all_labels[l].is.length]\n\t\t for(var i = 0; i < 2; i++) {\n\t\t     var n = ns[i];\n\t\t     var tgt_score = 1-(tgt-n)*(tgt-n)/(N*N); // This rewards being close to sqrt(N) -- bigger is better\n\t\t     var avoid_ends_score = Math.min(0, (n-1)*(N/2-n)/(N*N)); // This penalises being too close to 1 or N/2--bigger is better\n\t\t     var nodes_score = Math.log(N+1); // This factors in number of nodes a little (containing more is better than few, but only meaningfully so if an order of magnitude more)\n\t\t     var score = nodes_score*(tgt_score + avoid_ends_score);\n\t\t     \n\t\t     console.log(\"D\",l,i,tgt_score, avoid_ends_score, nodes_score,score)   \n\t\t     scores.push(score);\n\t\t }\n\t\t return Math.max(scores[0], scores[1]);\n\t     }\n\t     console.log(\"ALAL\",all_labels);\n\t     sorted_labels.sort(function(a, b){\n\t\t var da = discriminitivity(a);\n\t\t var db = discriminitivity(b);\n\t\t // We want to sort in increa\n\t\t if(da < db) return 1; // Sort a before b\n\t\t if(da > db) return -1; // Sort b before a\n\t\t return 0;\n\t     });\n\t     // Prep a set of all nodes so we can mark which ones we've finished\n\t     var finished_nodes = {};\n\t     var nodes_count = 0;\n\t     var finished_count = 0;\n\t     for(var n in this.nodeset) {\n\t\t // Only count nodes with actual edges; we'll deal\n\t\t // with disconnected ones separately\n\t\t var disconnected = true;\n\t\t for(var e in this.nodeset[n].edges.has){\n\t\t     for(var i = 0; i < this.nodeset[n].edges.has[e].length; i++){\n\t\t\t t = this.nodeset[n].edges.has[e][i].target;\n\t\t\t if(this.nodeset[t]) disconnected = false;\n\t\t     }\n\t\t }\n\t\t for(var e in this.nodeset[n].edges.is){\n\t\t     for(var i = 0; i < this.nodeset[n].edges.is[e].length; i++){\n\t\t\t t = this.nodeset[n].edges.is[e][i].target;\n\t\t\t if(this.nodeset[t]) disconnected = false;\n\t\t     }\n\t\t }\n\t\t if(disconnected){\n\t\t     disconnected_nodes.push(n);\n\t\t }\n\t\t else {\n\t\t     finished_nodes[n] = false;\n\t\t     nodes_count++;\n\t\t }\n\t     }\n\n\t     // Now we want to collect the labels we will use for\n\t     // indexing as well as figure out what modes to\n\t     // display them in\n\t     var best_labels = [];\n\t     \n\t     // Run through the labels\n\t     for(var i = 0; i < sorted_labels.length; i++) {\n\t\t best_labels.push(sorted_labels[i]);\n\t\t // Mark all nodes covered as finished:\n\t\t for(var n in sorted_labels[i].covered){\n\t\t     if(!finished_nodes[n]){\n\t\t\t finished_count++;\n\t\t\t finished_nodes[n] = true;\n\t\t     }\n\t\t }\n\t\t // We cut short the use of labels, but only if we have\n\t\t // exhausted all the connected nodes, each under at\n\t\t // least one label already _and_ only if we already\n\t\t // have a lot of labels (> 20)\n\t\t if(finished_count == nodes_count && best_labels.length > 20) {\n\t\t     break;\n\t\t }\n\t     }\n\n\t     // Now we are done!\n\t     if(best_labels.length == 1) best_label = best_labels[0];\n\t     else best_label = 'all';\n\t     this.current_label = best_label;\n\t     this.modes = modes;\n\t     return {\n\t\t 'disconnected': disconnected_nodes,\n\t\t 'labels': best_labels\n\t     };\n\t },\n\t ...mapState(['nodes']),\n\t ...mapGetters(['sorted','sortedby'])\n     },\n     methods: {\n\t sortasc: function(ascending) {\n\t     Vue.set(this, 'sort_is_ascending', ascending);\n\t },\n\t sortby: function(key) {\n\t     Vue.set(this, 'sort_method', key);\n\t },\n\t toggle_display: function(l) {\n \t     this.current_label = l;\n\t },\n\t swap_mode: function(l) {\n \t     this.modes[l] = (this.modes[l] == 'by' ? 'menu' : 'by');\n \t     //this.$forceUpdate();\n\t },\n\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n .sortkey_selected {\n     text-decoration:underline;\n }\n \n .node-index-menu {\n     width: 24%;\n     float:left;\n }\n\n .node-index-menu-item {\n     width: 90%;\n     border-radius:8px;\n     padding:5px;\n     margin:2px;\n     cursor:pointer;\n     background-color: #ccf !important;\n }\n\n\n .node-index-menu-selected {\n     background-color: #99c !important;\n }\n\n .node-index-list {\n     width: 72%;\n     float:left;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$4 = "data-v-0d2523a4";
    /* module identifier */
    const __vue_module_identifier__$4 = undefined;
    /* functional template */
    const __vue_is_functional_template__$4 = false;
    /* style inject SSR */
    

    
    var NodeIndex = normalizeComponent_1(
      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
      __vue_inject_styles__$4,
      __vue_script__$3,
      __vue_scope_id__$4,
      __vue_is_functional_template__$4,
      __vue_module_identifier__$4,
      browser,
      undefined
    );

  //
   
   var script$4 = {
       name: 'label-index',
       props: ['mode','label','nodeset','sortkey','sortasc'],
       computed: {
  	 headers: function() {
  	     if(this.mode == 'menu'){
  		 var ans = [];
  		 for(var n in this.nodeset) {
  		     if(this.nodeset[n].edges['has'][this.label]){
  			 ans.push(n);
  		     }
  		 }
  		 return ans;
  	     }
  	     else if(this.mode == 'by') {
  		 var ans = [];
  		 for(var n in this.nodeset) {
  		     if(this.nodeset[n].edges['is'][this.label]){
  			 ans.push(n);
  		     }
  		 }
  		 return ans;
  	     }
  	 },
  	 ...mapState([
  	     'nodes'
  	 ]),
  	 ...mapGetters(['sorted','sortedby'])
       },
       methods: {
  	 label_neighbours: function(n, label) {
  	     var ans = [];
  	     console.log("NL",n,label);
  	     var tgts = this.nodeset[n].edges[this.mode == 'menu' ? 'has' : 'is'][label];
  	     for(var i = 0; i < tgts.length; i++) {
  		 var m = tgts[i];
  		 console.log(m);
  		 if(m.target in this.nodeset) ans.push(m.target);
  	     }
  	     console.log(ans);
  	     return ans;
  	 }
       }
   };

  /* script */
  const __vue_script__$4 = script$4;

  /* template */
  var __vue_render__$5 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "label_index" }, [
      _vm.mode == "by" || _vm.mode == "menu"
        ? _c(
            "ul",
            _vm._l(
              _vm.sortedby(_vm.nodeset, _vm.headers, _vm.sortkey, _vm.sortasc),
              function(n) {
                return _c(
                  "li",
                  [
                    _c(
                      "router-link",
                      { attrs: { to: { name: "node", params: { id: n } } } },
                      [
                        _vm._v(_vm._s(_vm.nodeset[n].name) + " "),
                        "date" in _vm.nodeset[n]
                          ? _c(
                              "span",
                              {
                                staticStyle: {
                                  "font-size": ".5em",
                                  color: "#666"
                                }
                              },
                              [_vm._v(_vm._s(_vm.nodeset[n].date))]
                            )
                          : _vm._e()
                      ]
                    ),
                    _c(
                      "ul",
                      _vm._l(
                        _vm.sortedby(
                          _vm.nodeset,
                          _vm.label_neighbours(n, _vm.label),
                          _vm.sortkey,
                          _vm.sortasc
                        ),
                        function(m) {
                          return _c(
                            "li",
                            [
                              _c(
                                "router-link",
                                {
                                  attrs: {
                                    to: { name: "node", params: { id: m } }
                                  }
                                },
                                [
                                  _vm._v(_vm._s(_vm.nodeset[m].name) + " "),
                                  "date" in _vm.nodeset[m]
                                    ? _c(
                                        "span",
                                        {
                                          staticStyle: {
                                            "font-size": ".5em",
                                            color: "#666"
                                          }
                                        },
                                        [_vm._v(_vm._s(_vm.nodeset[m].date))]
                                      )
                                    : _vm._e()
                                ]
                              )
                            ],
                            1
                          )
                        }
                      ),
                      0
                    )
                  ],
                  1
                )
              }
            ),
            0
          )
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$5 = [];
  __vue_render__$5._withStripped = true;

    /* style */
    const __vue_inject_styles__$5 = function (inject) {
      if (!inject) return
      inject("data-v-d989b788_0", { source: "\nh3[data-v-d989b788] {\n  margin: 40px 0 0;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/components/labels.vue"],"names":[],"mappings":";AAmEA;EACA,gBAAA;AACA","file":"labels.vue","sourcesContent":["<template>\n  <div class=\"label_index\">\n      <ul v-if=\"mode == 'by' || mode == 'menu'\">\n\t  <li v-for=\"n in sortedby(nodeset, headers, sortkey, sortasc)\">\n\t      <router-link :to=\"{name:'node', params: {id: n}}\">{{nodeset[n].name}} <span v-if=\"'date' in nodeset[n]\" style=\"font-size:.5em;color:#666;\">{{nodeset[n].date}}</span></router-link>\n\t      <ul>\n\t\t  <li v-for=\"m in sortedby(nodeset, label_neighbours(n, label), sortkey, sortasc)\">\n\t\t      <router-link :to=\"{name:'node', params: {id: m}}\">{{nodeset[m].name}} <span v-if=\"'date' in nodeset[m]\" style=\"font-size:.5em;color:#666;\">{{nodeset[m].date}}</span></router-link>\n\t\t  </li>\n\t      </ul>\n\t  </li>\n      </ul>\n  </div>\n</template>\n\n<script>\n import { mapState } from 'vuex'\n import { mapGetters } from 'vuex'\n \n export default {\n     name: 'label-index',\n     props: ['mode','label','nodeset','sortkey','sortasc'],\n     computed: {\n\t headers: function() {\n\t     if(this.mode == 'menu'){\n\t\t var ans = []\n\t\t for(var n in this.nodeset) {\n\t\t     if(this.nodeset[n].edges['has'][this.label]){\n\t\t\t ans.push(n);\n\t\t     }\n\t\t }\n\t\t return ans;\n\t     }\n\t     else if(this.mode == 'by') {\n\t\t var ans = []\n\t\t for(var n in this.nodeset) {\n\t\t     if(this.nodeset[n].edges['is'][this.label]){\n\t\t\t ans.push(n);\n\t\t     }\n\t\t }\n\t\t return ans;\n\t     }\n\t },\n\t ...mapState([\n\t     'nodes'\n\t ]),\n\t ...mapGetters(['sorted','sortedby'])\n     },\n     methods: {\n\t label_neighbours: function(n, label) {\n\t     var ans = [];\n\t     console.log(\"NL\",n,label);\n\t     var tgts = this.nodeset[n].edges[this.mode == 'menu' ? 'has' : 'is'][label];\n\t     for(var i = 0; i < tgts.length; i++) {\n\t\t var m = tgts[i];\n\t\t console.log(m);\n\t\t if(m.target in this.nodeset) ans.push(m.target);\n\t     }\n\t     console.log(ans);\n\t     return ans;\n\t }\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh3 {\n  margin: 40px 0 0;\n}\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$5 = "data-v-d989b788";
    /* module identifier */
    const __vue_module_identifier__$5 = undefined;
    /* functional template */
    const __vue_is_functional_template__$5 = false;
    /* style inject SSR */
    

    
    var LabelIndex = normalizeComponent_1(
      { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
      __vue_inject_styles__$5,
      __vue_script__$4,
      __vue_scope_id__$5,
      __vue_is_functional_template__$5,
      __vue_module_identifier__$5,
      browser,
      undefined
    );

  //
   
   var script$5 = {
       name: 'node-filter',
       data() {
  	 return {
  	     filter_query: "",
  	     filter_error: ""
  	 };
       },
       computed: {
  	 ...mapState([
  	 'nodes', 'ready'
  	 ])
       },
       methods: {
  	 do_filter: function() {
  	     var fetch_headers = new Headers();
  	     fetch_headers.append('pragma', 'no-cache');
  	     fetch_headers.append('cache-control', 'no-cache');
  	     
  	     var fetch_params = {
  		 method: 'GET',
  		 headers: fetch_headers,
  	     };
  	     var self = this;
  	     fetch('/out/metadata.json?q=' + encodeURI(this.filter_query), fetch_params).then(function(response){
  	    	 response.json().then(function(data){
  		     console.log(data);
  		     if('error' in data) {
  			 self.filter_error = data.error;
  		     }
  		     else {
  			 self.$store.dispatch('reset_metadata',data);
  		     }
  	    	 });
  	     });
  	 },
       }
   };

  /* script */
  const __vue_script__$5 = script$5;

  /* template */
  var __vue_render__$6 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { attrs: { id: "first-pass-filter" } }, [
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.filter_query,
            expression: "filter_query"
          }
        ],
        attrs: { type: "text", id: "filter_input" },
        domProps: { value: _vm.filter_query },
        on: {
          keyup: function($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
            ) {
              return null
            }
            return _vm.do_filter($event)
          },
          input: function($event) {
            if ($event.target.composing) {
              return
            }
            _vm.filter_query = $event.target.value;
          }
        }
      }),
      _c("br"),
      _c("span", { staticClass: "filter-error" }, [
        _vm._v(_vm._s(_vm.filter_error))
      ])
    ])
  };
  var __vue_staticRenderFns__$6 = [];
  __vue_render__$6._withStripped = true;

    /* style */
    const __vue_inject_styles__$6 = function (inject) {
      if (!inject) return
      inject("data-v-74268c0c_0", { source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"filter.vue"}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$6 = "data-v-74268c0c";
    /* module identifier */
    const __vue_module_identifier__$6 = undefined;
    /* functional template */
    const __vue_is_functional_template__$6 = false;
    /* style inject SSR */
    

    
    var NodeFilter = normalizeComponent_1(
      { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
      __vue_inject_styles__$6,
      __vue_script__$5,
      __vue_scope_id__$6,
      __vue_is_functional_template__$6,
      __vue_module_identifier__$6,
      browser,
      undefined
    );

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  /**!
   * Sortable 1.10.2
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   */
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var version = "1.10.2";

  function userAgent(pattern) {
    if (typeof window !== 'undefined' && window.navigator) {
      return !!
      /*@__PURE__*/
      navigator.userAgent.match(pattern);
    }
  }

  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

  var captureMode = {
    capture: false,
    passive: false
  };

  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function matches$1(
  /**HTMLElement*/
  el,
  /**String*/
  selector) {
    if (!selector) return;
    selector[0] === '>' && (selector = selector.substring(1));

    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }

    return false;
  }

  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }

  function closest(
  /**HTMLElement*/
  el,
  /**String*/
  selector,
  /**HTMLElement*/
  ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;

      do {
        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches$1(el, selector) : matches$1(el, selector)) || includeCTX && el === ctx) {
          return el;
        }

        if (el === ctx) break;
        /* jshint boss:true */
      } while (el = getParentOrHost(el));
    }

    return null;
  }

  var R_SPACE = /\s+/g;

  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }

  function css(el, prop, val) {
    var style = el && el.style;

    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }

        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf('webkit') === -1) {
          prop = '-webkit-' + prop;
        }

        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }

  function matrix(el, selfOnly) {
    var appliedTransforms = '';

    if (typeof el === 'string') {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, 'transform');

        if (transform && transform !== 'none') {
          appliedTransforms = transform + ' ' + appliedTransforms;
        }
        /* jshint boss:true */

      } while (!selfOnly && (el = el.parentNode));
    }

    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    /*jshint -W056 */

    return matrixFn && new matrixFn(appliedTransforms);
  }

  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
          i = 0,
          n = list.length;

      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }

      return list;
    }

    return [];
  }

  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;

    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */


  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;

    if (el !== window && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }

    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      // Adjust for translate()
      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11

      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

            top -= containerRect.top + parseInt(css(container, 'border-top-width'));
            left -= containerRect.left + parseInt(css(container, 'border-left-width'));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
          /* jshint boss:true */

        } while (container = container.parentNode);
      }
    }

    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d;

      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }

    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height
    };
  }
  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */


  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
        elSideVal = getRect(el)[elSide];
    /* jshint boss:true */

    while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
          visible = void 0;

      if (parentSide === 'top' || parentSide === 'left') {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }

      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }

    return false;
  }
  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */


  function getChild(el, childNum, options) {
    var currentChild = 0,
        i = 0,
        children = el.children;

    while (i < children.length) {
      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }

        currentChild++;
      }

      i++;
    }

    return null;
  }
  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */


  function lastChild(el, selector) {
    var last = el.lastElementChild;

    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches$1(last, selector))) {
      last = last.previousElementSibling;
    }

    return last || null;
  }
  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */


  function index$1(el, selector) {
    var index = 0;

    if (!el || !el.parentNode) {
      return -1;
    }
    /* jshint boss:true */


    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches$1(el, selector))) {
        index++;
      }
    }

    return index;
  }
  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */


  function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
        offsetTop = 0,
        winScroller = getWindowScrollingElement();

    if (el) {
      do {
        var elMatrix = matrix(el),
            scaleX = elMatrix.a,
            scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }

    return [offsetLeft, offsetTop];
  }
  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */


  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }

    return -1;
  }

  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;

    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);

        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
      /* jshint boss:true */

    } while (elem = elem.parentNode);

    return getWindowScrollingElement();
  }

  function extend$2(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }

    return dst;
  }

  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }

  var _throttleTimeout;

  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
            _this = this;

        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }

        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }

  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }

  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }

  function clone$1(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;

    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }

  var expando = 'Sortable' + new Date().getTime();

  function AnimationStateManager() {
    var animationStates = [],
        animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });

          var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);

            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }

          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target: target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;

        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === 'function') callback();
          return;
        }

        var animating = false,
            animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
              target = state.target,
              fromRect = target.fromRect,
              toRect = getRect(target),
              prevFromRect = target.prevFromRect,
              prevToRect = target.prevToRect,
              animatingRect = state.rect,
              targetMatrix = matrix(target, true);

          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }

          target.toRect = toRect;

          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          } // if fromRect != toRect: animate


          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;

            if (!time) {
              time = _this.options.animation;
            }

            _this.animate(target, animatingRect, toRect, time);
          }

          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);

        if (!animating) {
          if (typeof callback === 'function') callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === 'function') callback();
          }, animationTime);
        }

        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, 'transition', '');
          css(target, 'transform', '');
          var elMatrix = matrix(this.el),
              scaleX = elMatrix && elMatrix.a,
              scaleY = elMatrix && elMatrix.d,
              translateX = (currentRect.left - toRect.left) / (scaleX || 1),
              translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
          repaint(target); // repaint

          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
          css(target, 'transform', 'translate3d(0,0,0)');
          typeof target.animated === 'number' && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, 'transition', '');
            css(target, 'transform', '');
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }

  function repaint(target) {
    return target.offsetWidth;
  }

  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }

  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }

      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;

      this.eventCanceled = false;

      evt.cancel = function () {
        _this.eventCanceled = true;
      };

      var eventNameGlobal = eventName + 'Global';
      plugins.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
            sortable: sortable
          }, evt));
        } // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined


        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread({
            sortable: sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
      plugins.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized; // Add default options from plugin

        _extends(defaults, initialized.defaults);
      });

      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(sortable, option, sortable.options[option]);

        if (typeof modified !== 'undefined') {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== 'function') return;

        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };

  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
        rootEl = _ref.rootEl,
        name = _ref.name,
        targetEl = _ref.targetEl,
        cloneEl = _ref.cloneEl,
        toEl = _ref.toEl,
        fromEl = _ref.fromEl,
        oldIndex = _ref.oldIndex,
        newIndex = _ref.newIndex,
        oldDraggableIndex = _ref.oldDraggableIndex,
        newDraggableIndex = _ref.newDraggableIndex,
        originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt,
        options = sortable.options,
        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
    }

    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

    var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }

    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }

    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }

  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        originalEvent = _ref.evt,
        data = _objectWithoutProperties(_ref, ["evt"]);

    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
      dragEl: dragEl,
      parentEl: parentEl,
      ghostEl: ghostEl,
      rootEl: rootEl,
      nextEl: nextEl,
      lastDownEl: lastDownEl,
      cloneEl: cloneEl,
      cloneHidden: cloneHidden,
      dragStarted: moved,
      putSortable: putSortable,
      activeSortable: Sortable.active,
      originalEvent: originalEvent,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable: sortable,
          name: name,
          originalEvent: originalEvent
        });
      }
    }, data));
  };

  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread({
      putSortable: putSortable,
      cloneEl: cloneEl,
      targetEl: dragEl,
      rootEl: rootEl,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex
    }, info));
  }

  var dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      oldIndex,
      newIndex,
      oldDraggableIndex,
      newDraggableIndex,
      activeGroup,
      putSortable,
      awaitingDragStarted = false,
      ignoreNextClick = false,
      sortables = [],
      tapEvt,
      touchEvt,
      lastDx,
      lastDy,
      tapDistanceLeft,
      tapDistanceTop,
      moved,
      lastTarget,
      lastDirection,
      pastFirstInvertThresh = false,
      isCircumstantialInvert = false,
      targetMoveDistance,
      // For positioning ghost absolutely
  ghostRelativeParent,
      ghostRelativeParentInitialScroll = [],
      // (left, top)
  _silent = false,
      savedInputChecked = [];
  /** @const */

  var documentExists = typeof document !== 'undefined',
      PositionGhostAbsolutely = IOS,
      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
      // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
      supportCssPointerEvents = function () {
    if (!documentExists) return; // false when <= IE11

    if (IE11OrLess) {
      return false;
    }

    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
      _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }

    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }

    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }

    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },

  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      if (lastChild(sortable)) return;
      var rect = getRect(sortable),
          threshold = sortable[expando].options.emptyInsertThreshold,
          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

      if (threshold && insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
      _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }

    var group = {};
    var originalGroup = options.group;

    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }

    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
      _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
      _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


  if (documentExists) {
    document.addEventListener('click', function (evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }

  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;

      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

      if (nearest) {
        // Create imitation event
        var event = {};

        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }

        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;

        nearest[expando]._onDragOver(event);
      }
    }
  };

  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */


  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }

    this.el = el; // root element

    this.options = options = _extends({}, options); // Export instance

    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options

    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }

    _prepareGroup(options); // Bind all private methods


    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    } // Setup drag mode


    this.nativeDraggable = options.forceFallback ? false : supportDraggable;

    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    } // Bind events


    if (options.supportPointer) {
      on(el, 'pointerdown', this._onTapStart);
    } else {
      on(el, 'mousedown', this._onTapStart);
      on(el, 'touchstart', this._onTapStart);
    }

    if (this.nativeDraggable) {
      on(el, 'dragover', this);
      on(el, 'dragenter', this);
    }

    sortables.push(this.el); // Restore sorting

    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

    _extends(this, AnimationStateManager());
  }

  Sortable.prototype =
  /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(
    /** Event|TouchEvent */
    evt) {
      if (!evt.cancelable) return;

      var _this = this,
          el = this.el,
          options = this.options,
          preventOnFilter = options.preventOnFilter,
          type = evt.type,
          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
          target = (touch || evt).target,
          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
          filter = options.filter;

      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


      if (dragEl) {
        return;
      }

      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return; // only left button and enabled
      } // cancel dnd if original target is content editable


      if (originalTarget.isContentEditable) {
        return;
      }

      target = closest(target, options.draggable, el, false);

      if (target && target.animated) {
        return;
      }

      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      } // Get the index of the dragged element within its parent


      oldIndex = index$1(target);
      oldDraggableIndex = index$1(target, options.draggable); // Check filter

      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: 'filter',
            targetEl: target,
            toEl: el,
            fromEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);

          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: 'filter',
              targetEl: target,
              fromEl: el,
              toEl: el
            });

            pluginEvent('filter', _this, {
              evt: evt
            });
            return true;
          }
        });

        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      }

      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      } // Prepare `dragstart`


      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(
    /** Event */
    evt,
    /** Touch */
    touch,
    /** HTMLElement */
    target) {
      var _this = this,
          el = _this.el,
          options = _this.options,
          ownerDocument = el.ownerDocument,
          dragStartFn;

      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';

        dragStartFn = function dragStartFn() {
          pluginEvent('delayEnded', _this, {
            evt: evt
          });

          if (Sortable.eventCanceled) {
            _this._onDrop();

            return;
          } // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove


          _this._disableDelayedDragEvents();

          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          } // Bind the events: dragstart/dragend


          _this._triggerDragStart(evt, touch); // Drag start event


          _dispatchEvent({
            sortable: _this,
            name: 'choose',
            originalEvent: evt
          }); // Chosen item


          toggleClass(dragEl, options.chosenClass, true);
        }; // Disable "draggable"


        options.ignore.split(',').forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }

        pluginEvent('delayStart', this, {
          evt: evt
        }); // Delay is impossible for native DnD in Edge or IE

        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();

            return;
          } // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag


          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
    /** TouchEvent|PointerEvent **/
    e) {
      var touch = e.touches ? e.touches[0] : e;

      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);

      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      off(ownerDocument, 'touchend', this._disableDelayedDrag);
      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(
    /** Event */
    evt,
    /** Touch */
    touch) {
      touch = touch || evt.pointerType == 'touch' && evt;

      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._onTouchMove);
        } else if (touch) {
          on(document, 'touchmove', this._onTouchMove);
        } else {
          on(document, 'mousemove', this._onTouchMove);
        }
      } else {
        on(dragEl, 'dragend', this);
        on(rootEl, 'dragstart', this._onDragStart);
      }

      try {
        if (document.selection) {
          // Timeout neccessary for IE9
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {

      awaitingDragStarted = false;

      if (rootEl && dragEl) {
        pluginEvent('dragStarted', this, {
          evt: evt
        });

        if (this.nativeDraggable) {
          on(document, 'dragover', _checkOutsideTargetEl);
        }

        var options = this.options; // Apply effect

        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost(); // Drag start event

        _dispatchEvent({
          sortable: this,
          name: 'start',
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;

        _hideGhostForTarget();

        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;

        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }

        dragEl.parentNode[expando]._isOutsideThisEl(target);

        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent
              });

              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }

            target = parent; // store last element
          }
          /* jshint boss:true */
          while (parent = parent.parentNode);
        }

        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(
    /**TouchEvent*/
    evt) {
      if (tapEvt) {
        var options = this.options,
            fallbackTolerance = options.fallbackTolerance,
            fallbackOffset = options.fallbackOffset,
            touch = evt.touches ? evt.touches[0] : evt,
            ghostMatrix = ghostEl && matrix(ghostEl, true),
            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }

          this._onDragStart(evt, true);
        }

        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }

          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, 'webkitTransform', cssMatrix);
          css(ghostEl, 'mozTransform', cssMatrix);
          css(ghostEl, 'msTransform', cssMatrix);
          css(ghostEl, 'transform', cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }

        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
            options = this.options; // Position absolutely

        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;

          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }

          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }

          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }

        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, 'transition', '');
        css(ghostEl, 'transform', '');
        css(ghostEl, 'box-sizing', 'border-box');
        css(ghostEl, 'margin', 0);
        css(ghostEl, 'top', rect.top);
        css(ghostEl, 'left', rect.left);
        css(ghostEl, 'width', rect.width);
        css(ghostEl, 'height', rect.height);
        css(ghostEl, 'opacity', '0.8');
        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
        css(ghostEl, 'zIndex', '100000');
        css(ghostEl, 'pointerEvents', 'none');
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl); // Set transform-origin

        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
      }
    },
    _onDragStart: function _onDragStart(
    /**Event*/
    evt,
    /**boolean*/
    fallback) {
      var _this = this;

      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent('dragStart', this, {
        evt: evt
      });

      if (Sortable.eventCanceled) {
        this._onDrop();

        return;
      }

      pluginEvent('setupClone', this);

      if (!Sortable.eventCanceled) {
        cloneEl = clone$1(dragEl);
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';

        this._hideClone();

        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      } // #1143: IFrame support workaround


      _this.cloneId = _nextTick(function () {
        pluginEvent('clone', _this);
        if (Sortable.eventCanceled) return;

        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }

        _this._hideClone();

        _dispatchEvent({
          sortable: _this,
          name: 'clone'
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, 'mouseup', _this._onDrop);
        off(document, 'touchend', _this._onDrop);
        off(document, 'touchcancel', _this._onDrop);

        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }

        on(document, 'drop', _this); // #1276 fix:

        css(dragEl, 'transform', 'translateZ(0)');
      }

      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, 'selectstart', _this);
      moved = true;

      if (Safari) {
        css(document.body, 'user-select', 'none');
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(
    /**Event*/
    evt) {
      var el = this.el,
          target = evt.target,
          dragRect,
          targetRect,
          revert,
          options = this.options,
          group = options.group,
          activeSortable = Sortable.active,
          isOwner = activeGroup === group,
          canSort = options.sort,
          fromSortable = putSortable || activeSortable,
          vertical,
          _this = this,
          completedFired = false;

      if (_silent) return;

      function dragOverEvent(name, extra) {
        pluginEvent(name, _this, _objectSpread({
          evt: evt,
          isOwner: isOwner,
          axis: vertical ? 'vertical' : 'horizontal',
          revert: revert,
          dragRect: dragRect,
          targetRect: targetRect,
          canSort: canSort,
          fromSortable: fromSortable,
          target: target,
          completed: completed,
          onMove: function onMove(target, after) {
            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
          },
          changed: changed
        }, extra));
      } // Capture animation state


      function capture() {
        dragOverEvent('dragOverAnimationCapture');

        _this.captureAnimationState();

        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      } // Return invocation when dragEl is inserted (or completed)


      function completed(insertion) {
        dragOverEvent('dragOverCompleted', {
          insertion: insertion
        });

        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }

          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }

          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          } // Animation


          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }

          _this.animateAll(function () {
            dragOverEvent('dragOverAnimationComplete');
            _this._ignoreWhileAnimating = null;
          });

          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        } // Null lastTarget if it is not inside a previously swapped element


        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        } // no bubbling and not fallback


        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


          !insertion && nearestEmptyInsertDetectEvent(evt);
        }

        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      } // Call when dragEl has been inserted


      function changed() {
        newIndex = index$1(dragEl);
        newDraggableIndex = index$1(dragEl, options.draggable);

        _dispatchEvent({
          sortable: _this,
          name: 'change',
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt
        });
      }

      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }

      target = closest(target, options.draggable, el, true);
      dragOverEvent('dragOver');
      if (Sortable.eventCanceled) return completedFired;

      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }

      ignoreNextClick = false;

      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === 'vertical';
        dragRect = getRect(dragEl);
        dragOverEvent('dragOverValid');
        if (Sortable.eventCanceled) return completedFired;

        if (revert) {
          parentEl = rootEl; // actualization

          capture();

          this._hideClone();

          dragOverEvent('revert');

          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }

          return completed(true);
        }

        var elLastChild = lastChild(el, options.draggable);

        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          } // assign target only if condition is true


          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }

          if (target) {
            targetRect = getRect(target);
          }

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            el.appendChild(dragEl);
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
              targetBeforeFirstSwap,
              differentLevel = dragEl.parentNode !== el,
              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
              side1 = vertical ? 'top' : 'left',
              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }

          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;

          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index$1(dragEl);

            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
          } // If dragEl is already beside target: Do not insert


          if (direction === 0 || sibling === target) {
            return completed(false);
          }

          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
              after = false;
          after = direction === 1;

          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }

            _silent = true;
            setTimeout(_unsilent, 30);
            capture();

            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            } // Undo chrome's scroll adjustment (has no effect on other browsers)


            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }

            parentEl = dragEl.parentNode; // actualization
            // must be done before animation

            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }

            changed();
            return completed(true);
          }
        }

        if (el.contains(dragEl)) {
          return completed(false);
        }
      }

      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, 'mousemove', this._onTouchMove);
      off(document, 'touchmove', this._onTouchMove);
      off(document, 'pointermove', this._onTouchMove);
      off(document, 'dragover', nearestEmptyInsertDetectEvent);
      off(document, 'mousemove', nearestEmptyInsertDetectEvent);
      off(document, 'touchmove', nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._onDrop);
      off(ownerDocument, 'touchend', this._onDrop);
      off(ownerDocument, 'pointerup', this._onDrop);
      off(ownerDocument, 'touchcancel', this._onDrop);
      off(document, 'selectstart', this);
    },
    _onDrop: function _onDrop(
    /**Event*/
    evt) {
      var el = this.el,
          options = this.options; // Get the index of the dragged element within its parent

      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      pluginEvent('drop', this, {
        evt: evt
      });
      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);

      if (Sortable.eventCanceled) {
        this._nulling();

        return;
      }

      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);

      _cancelNextTick(this.cloneId);

      _cancelNextTick(this._dragStartId); // Unbind events


      if (this.nativeDraggable) {
        off(document, 'drop', this);
        off(el, 'dragstart', this._onDragStart);
      }

      this._offMoveEvents();

      this._offUpEvents();

      if (Safari) {
        css(document.body, 'user-select', '');
      }

      css(dragEl, 'transform', '');

      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }

        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          // Remove clone(s)
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }

        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, 'dragend', this);
          }

          _disableDraggable(dragEl);

          dragEl.style['will-change'] = ''; // Remove classes
          // ghostClass is added in dragStarted

          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }

          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

          _dispatchEvent({
            sortable: this,
            name: 'unchoose',
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });

          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: 'add',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              }); // Remove event


              _dispatchEvent({
                sortable: this,
                name: 'remove',
                toEl: parentEl,
                originalEvent: evt
              }); // drag from one list and drop into another


              _dispatchEvent({
                rootEl: parentEl,
                name: 'sort',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }

            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: 'update',
                  toEl: parentEl,
                  originalEvent: evt
                });

                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }

          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }

            _dispatchEvent({
              sortable: this,
              name: 'end',
              toEl: parentEl,
              originalEvent: evt
            }); // Save sorting


            this.save();
          }
        }
      }

      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent('nulling', this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(
    /**Event*/
    evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);

          break;

        case 'dragenter':
        case 'dragover':
          if (dragEl) {
            this._onDragOver(evt);

            _globalDragOver(evt);
          }

          break;

        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },

    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
          el,
          children = this.el.children,
          i = 0,
          n = children.length,
          options = this.options;

      for (; i < n; i++) {
        el = children[i];

        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }

      return order;
    },

    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order) {
      var items = {},
          rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];

        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
    },

    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },

    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },

    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;

      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);

        if (typeof modifiedValue !== 'undefined') {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }

        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },

    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent('destroy', this);
      var el = this.el;
      el[expando] = null;
      off(el, 'mousedown', this._onTapStart);
      off(el, 'touchstart', this._onTapStart);
      off(el, 'pointerdown', this._onTapStart);

      if (this.nativeDraggable) {
        off(el, 'dragover', this);
        off(el, 'dragenter', this);
      } // Remove draggable attributes


      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });

      this._onDrop();

      this._disableDelayedDragEvents();

      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent('hideClone', this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, 'display', 'none');

        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }

        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== 'clone') {
        this._hideClone();

        return;
      }

      if (cloneHidden) {
        pluginEvent('showClone', this);
        if (Sortable.eventCanceled) return; // show clone at dragEl or original position

        if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }

        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }

        css(cloneEl, 'display', '');
        cloneHidden = false;
      }
    }
  };

  function _globalDragOver(
  /**Event*/
  evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }

    evt.cancelable && evt.preventDefault();
  }

  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt,
        sortable = fromEl[expando],
        onMoveFn = sortable.options.onMove,
        retVal; // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent('move', {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent('move', true, true);
    }

    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);

    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }

    return retVal;
  }

  function _disableDraggable(el) {
    el.draggable = false;
  }

  function _unsilent() {
    _silent = false;
  }

  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
  }

  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
        targetLength = vertical ? targetRect.height : targetRect.width,
        targetS1 = vertical ? targetRect.top : targetRect.left,
        targetS2 = vertical ? targetRect.bottom : targetRect.right,
        invert = false;

    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }

        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
          : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }

    invert = invert || invertSwap;

    if (invert) {
      // Invert of regular
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }

    return 0;
  }
  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */


  function _getInsertDirection(target) {
    if (index$1(dragEl) < index$1(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */


  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
        i = str.length,
        sum = 0;

    while (i--) {
      sum += str.charCodeAt(i);
    }

    return sum.toString(36);
  }

  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;

    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }

  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }

  function _cancelNextTick(id) {
    return clearTimeout(id);
  } // Fixed #973:


  if (documentExists) {
    on(document, 'touchmove', function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  } // Export utils


  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend$2,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone$1,
    index: index$1,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild
  };
  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */

  Sortable.get = function (element) {
    return element[expando];
  };
  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */


  Sortable.mount = function () {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }

      if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */


  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  }; // Export


  Sortable.version = version;

  var autoScrolls = [],
      scrollEl,
      scrollRootEl,
      scrolling = false,
      lastAutoScrollX,
      lastAutoScrollY,
      touchEvt$1,
      pointerElemChangedInterval;

  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      }; // Bind all private methods

      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }
    }

    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;

        if (this.sortable.nativeDraggable) {
          on(document, 'dragover', this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, 'touchmove', this._handleFallbackAutoScroll);
          } else {
            on(document, 'mousemove', this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;

        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, 'dragover', this._handleAutoScroll);
        } else {
          off(document, 'pointermove', this._handleFallbackAutoScroll);
          off(document, 'touchmove', this._handleFallbackAutoScroll);
          off(document, 'mousemove', this._handleFallbackAutoScroll);
        }

        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;

        var x = (evt.touches ? evt.touches[0] : evt).clientX,
            y = (evt.touches ? evt.touches[0] : evt).clientY,
            elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt; // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good

        if (fallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

          var ogElemScroller = getParentAutoScrollElement(elem, true);

          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }

              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }

          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: 'scroll',
      initializeByDefault: true
    });
  }

  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }

  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }

  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        sens = options.scrollSensitivity,
        speed = options.scrollSpeed,
        winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
        scrollCustomFn; // New scroll root, set scrollEl

    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;

      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }

    var layersOut = 0;
    var currentParent = scrollEl;

    do {
      var el = currentParent,
          rect = getRect(el),
          top = rect.top,
          bottom = rect.bottom,
          left = rect.left,
          right = rect.right,
          width = rect.width,
          height = rect.height,
          canScrollX = void 0,
          canScrollY = void 0,
          scrollWidth = el.scrollWidth,
          scrollHeight = el.scrollHeight,
          elCSS = css(el),
          scrollPosX = el.scrollLeft,
          scrollPosY = el.scrollTop;

      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
      }

      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }

      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);

        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */

          autoScrolls[layersOut].pid = setInterval(function () {
            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

            }

            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

            if (typeof scrollCustomFn === 'function') {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                return;
              }
            }

            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }

      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);

  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        dragEl = _ref.dragEl,
        activeSortable = _ref.activeSortable,
        dispatchSortableEvent = _ref.dispatchSortableEvent,
        hideGhostForTarget = _ref.hideGhostForTarget,
        unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();

    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent('spill');
      this.onSpill({
        dragEl: dragEl,
        putSortable: putSortable
      });
    }
  };

  function Revert() {}

  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
          putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();

      if (putSortable) {
        putSortable.captureAnimationState();
      }

      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }

      this.sortable.animateAll();

      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop
  };

  _extends(Revert, {
    pluginName: 'revertOnSpill'
  });

  function Remove() {}

  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
          putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop
  };

  _extends(Remove, {
    pluginName: 'removeOnSpill'
  });

  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  var vuedraggable_common = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ "02f4":
  /***/ (function(module, exports, __webpack_require__) {

  var toInteger = __webpack_require__("4588");
  var defined = __webpack_require__("be13");
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that));
      var i = toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };


  /***/ }),

  /***/ "0390":
  /***/ (function(module, exports, __webpack_require__) {

  var at = __webpack_require__("02f4")(true);

   // `AdvanceStringIndex` abstract operation
  // https://tc39.github.io/ecma262/#sec-advancestringindex
  module.exports = function (S, index, unicode) {
    return index + (unicode ? at(S, index).length : 1);
  };


  /***/ }),

  /***/ "07e3":
  /***/ (function(module, exports) {

  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };


  /***/ }),

  /***/ "0bfb":
  /***/ (function(module, exports, __webpack_require__) {

  // 21.2.5.3 get RegExp.prototype.flags
  var anObject = __webpack_require__("cb7c");
  module.exports = function () {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };


  /***/ }),

  /***/ "0fc9":
  /***/ (function(module, exports, __webpack_require__) {

  var toInteger = __webpack_require__("3a38");
  var max = Math.max;
  var min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };


  /***/ }),

  /***/ "1654":
  /***/ (function(module, exports, __webpack_require__) {

  var $at = __webpack_require__("71c1")(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  __webpack_require__("30f1")(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });


  /***/ }),

  /***/ "1691":
  /***/ (function(module, exports) {

  // IE 8- don't enum bug keys
  module.exports = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');


  /***/ }),

  /***/ "1af6":
  /***/ (function(module, exports, __webpack_require__) {

  // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
  var $export = __webpack_require__("63b6");

  $export($export.S, 'Array', { isArray: __webpack_require__("9003") });


  /***/ }),

  /***/ "1bc3":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = __webpack_require__("f772");
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };


  /***/ }),

  /***/ "1ec9":
  /***/ (function(module, exports, __webpack_require__) {

  var isObject = __webpack_require__("f772");
  var document = __webpack_require__("e53d").document;
  // typeof document.createElement is 'object' in old IE
  var is = isObject(document) && isObject(document.createElement);
  module.exports = function (it) {
    return is ? document.createElement(it) : {};
  };


  /***/ }),

  /***/ "20fd":
  /***/ (function(module, exports, __webpack_require__) {

  var $defineProperty = __webpack_require__("d9f6");
  var createDesc = __webpack_require__("aebd");

  module.exports = function (object, index, value) {
    if (index in object) $defineProperty.f(object, index, createDesc(0, value));
    else object[index] = value;
  };


  /***/ }),

  /***/ "214f":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("b0c5");
  var redefine = __webpack_require__("2aba");
  var hide = __webpack_require__("32e9");
  var fails = __webpack_require__("79e5");
  var defined = __webpack_require__("be13");
  var wks = __webpack_require__("2b4c");
  var regexpExec = __webpack_require__("520a");

  var SPECIES = wks('species');

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    return ''.replace(re, '$<a>') !== '7';
  });

  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
    // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length === 2 && result[0] === 'a' && result[1] === 'b';
  })();

  module.exports = function (KEY, length, exec) {
    var SYMBOL = wks(KEY);

    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;
      re.exec = function () { execCalled = true; return null; };
      if (KEY === 'split') {
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES] = function () { return re; };
      }
      re[SYMBOL]('');
      return !execCalled;
    }) : undefined;

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
      (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
    ) {
      var nativeRegExpMethod = /./[SYMBOL];
      var fns = exec(
        defined,
        SYMBOL,
        ''[KEY],
        function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
          if (regexp.exec === regexpExec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              // The native String method already delegates to @@method (this
              // polyfilled function), leasing to infinite recursion.
              // We avoid it by directly calling the native @@method method.
              return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
            }
            return { done: true, value: nativeMethod.call(str, regexp, arg2) };
          }
          return { done: false };
        }
      );
      var strfn = fns[0];
      var rxfn = fns[1];

      redefine(String.prototype, KEY, strfn);
      hide(RegExp.prototype, SYMBOL, length == 2
        // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) { return rxfn.call(string, this, arg); }
        // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) { return rxfn.call(string, this); }
      );
    }
  };


  /***/ }),

  /***/ "230e":
  /***/ (function(module, exports, __webpack_require__) {

  var isObject = __webpack_require__("d3f4");
  var document = __webpack_require__("7726").document;
  // typeof document.createElement is 'object' in old IE
  var is = isObject(document) && isObject(document.createElement);
  module.exports = function (it) {
    return is ? document.createElement(it) : {};
  };


  /***/ }),

  /***/ "23c6":
  /***/ (function(module, exports, __webpack_require__) {

  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = __webpack_require__("2d95");
  var TAG = __webpack_require__("2b4c")('toStringTag');
  // ES3 wrong here
  var ARG = cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  module.exports = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? cof(O)
      // ES3 arguments fallback
      : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };


  /***/ }),

  /***/ "241e":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.13 ToObject(argument)
  var defined = __webpack_require__("25eb");
  module.exports = function (it) {
    return Object(defined(it));
  };


  /***/ }),

  /***/ "25eb":
  /***/ (function(module, exports) {

  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };


  /***/ }),

  /***/ "294c":
  /***/ (function(module, exports) {

  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };


  /***/ }),

  /***/ "2aba":
  /***/ (function(module, exports, __webpack_require__) {

  var global = __webpack_require__("7726");
  var hide = __webpack_require__("32e9");
  var has = __webpack_require__("69a8");
  var SRC = __webpack_require__("ca5a")('src');
  var $toString = __webpack_require__("fa5b");
  var TO_STRING = 'toString';
  var TPL = ('' + $toString).split(TO_STRING);

  __webpack_require__("8378").inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) has(val, 'name') || hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      hide(O, key, val);
    }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });


  /***/ }),

  /***/ "2b4c":
  /***/ (function(module, exports, __webpack_require__) {

  var store = __webpack_require__("5537")('wks');
  var uid = __webpack_require__("ca5a");
  var Symbol = __webpack_require__("7726").Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;


  /***/ }),

  /***/ "2d00":
  /***/ (function(module, exports) {

  module.exports = false;


  /***/ }),

  /***/ "2d95":
  /***/ (function(module, exports) {

  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };


  /***/ }),

  /***/ "2fdb":
  /***/ (function(module, exports, __webpack_require__) {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)

  var $export = __webpack_require__("5ca1");
  var context = __webpack_require__("d2c8");
  var INCLUDES = 'includes';

  $export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~context(this, searchString, INCLUDES)
        .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }
  });


  /***/ }),

  /***/ "30f1":
  /***/ (function(module, exports, __webpack_require__) {

  var LIBRARY = __webpack_require__("b8e3");
  var $export = __webpack_require__("63b6");
  var redefine = __webpack_require__("9138");
  var hide = __webpack_require__("35e8");
  var Iterators = __webpack_require__("481b");
  var $iterCreate = __webpack_require__("8f60");
  var setToStringTag = __webpack_require__("45f2");
  var getPrototypeOf = __webpack_require__("53e2");
  var ITERATOR = __webpack_require__("5168")('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () { return this; };

  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };


  /***/ }),

  /***/ "32a6":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.2.14 Object.keys(O)
  var toObject = __webpack_require__("241e");
  var $keys = __webpack_require__("c3a1");

  __webpack_require__("ce7e")('keys', function () {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });


  /***/ }),

  /***/ "32e9":
  /***/ (function(module, exports, __webpack_require__) {

  var dP = __webpack_require__("86cc");
  var createDesc = __webpack_require__("4630");
  module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };


  /***/ }),

  /***/ "32fc":
  /***/ (function(module, exports, __webpack_require__) {

  var document = __webpack_require__("e53d").document;
  module.exports = document && document.documentElement;


  /***/ }),

  /***/ "335c":
  /***/ (function(module, exports, __webpack_require__) {

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = __webpack_require__("6b4c");
  // eslint-disable-next-line no-prototype-builtins
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };


  /***/ }),

  /***/ "355d":
  /***/ (function(module, exports) {

  exports.f = {}.propertyIsEnumerable;


  /***/ }),

  /***/ "35e8":
  /***/ (function(module, exports, __webpack_require__) {

  var dP = __webpack_require__("d9f6");
  var createDesc = __webpack_require__("aebd");
  module.exports = __webpack_require__("8e60") ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };


  /***/ }),

  /***/ "36c3":
  /***/ (function(module, exports, __webpack_require__) {

  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = __webpack_require__("335c");
  var defined = __webpack_require__("25eb");
  module.exports = function (it) {
    return IObject(defined(it));
  };


  /***/ }),

  /***/ "3702":
  /***/ (function(module, exports, __webpack_require__) {

  // check on default Array iterator
  var Iterators = __webpack_require__("481b");
  var ITERATOR = __webpack_require__("5168")('iterator');
  var ArrayProto = Array.prototype;

  module.exports = function (it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };


  /***/ }),

  /***/ "3a38":
  /***/ (function(module, exports) {

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };


  /***/ }),

  /***/ "40c3":
  /***/ (function(module, exports, __webpack_require__) {

  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = __webpack_require__("6b4c");
  var TAG = __webpack_require__("5168")('toStringTag');
  // ES3 wrong here
  var ARG = cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  module.exports = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? cof(O)
      // ES3 arguments fallback
      : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };


  /***/ }),

  /***/ "4588":
  /***/ (function(module, exports) {

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };


  /***/ }),

  /***/ "45f2":
  /***/ (function(module, exports, __webpack_require__) {

  var def = __webpack_require__("d9f6").f;
  var has = __webpack_require__("07e3");
  var TAG = __webpack_require__("5168")('toStringTag');

  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };


  /***/ }),

  /***/ "4630":
  /***/ (function(module, exports) {

  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };


  /***/ }),

  /***/ "469f":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("6c1c");
  __webpack_require__("1654");
  module.exports = __webpack_require__("7d7b");


  /***/ }),

  /***/ "481b":
  /***/ (function(module, exports) {

  module.exports = {};


  /***/ }),

  /***/ "4aa6":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("dc62");

  /***/ }),

  /***/ "4bf8":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.13 ToObject(argument)
  var defined = __webpack_require__("be13");
  module.exports = function (it) {
    return Object(defined(it));
  };


  /***/ }),

  /***/ "4ee1":
  /***/ (function(module, exports, __webpack_require__) {

  var ITERATOR = __webpack_require__("5168")('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () { SAFE_CLOSING = true; };
    // eslint-disable-next-line no-throw-literal
    Array.from(riter, function () { throw 2; });
  } catch (e) { /* empty */ }

  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };


  /***/ }),

  /***/ "50ed":
  /***/ (function(module, exports) {

  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };


  /***/ }),

  /***/ "5147":
  /***/ (function(module, exports, __webpack_require__) {

  var MATCH = __webpack_require__("2b4c")('match');
  module.exports = function (KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) { /* empty */ }
    } return true;
  };


  /***/ }),

  /***/ "5168":
  /***/ (function(module, exports, __webpack_require__) {

  var store = __webpack_require__("dbdb")('wks');
  var uid = __webpack_require__("62a0");
  var Symbol = __webpack_require__("e53d").Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;


  /***/ }),

  /***/ "5176":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("51b6");

  /***/ }),

  /***/ "51b6":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("a3c3");
  module.exports = __webpack_require__("584a").Object.assign;


  /***/ }),

  /***/ "520a":
  /***/ (function(module, exports, __webpack_require__) {


  var regexpFlags = __webpack_require__("0bfb");

  var nativeExec = RegExp.prototype.exec;
  // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.
  var nativeReplace = String.prototype.replace;

  var patchedExec = nativeExec;

  var LAST_INDEX = 'lastIndex';

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/,
        re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
  })();

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

      match = nativeExec.call(re, str);

      if (UPDATES_LAST_INDEX_WRONG && match) {
        re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        // eslint-disable-next-line no-loop-func
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  module.exports = patchedExec;


  /***/ }),

  /***/ "53e2":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has = __webpack_require__("07e3");
  var toObject = __webpack_require__("241e");
  var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
  var ObjectProto = Object.prototype;

  module.exports = Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };


  /***/ }),

  /***/ "549b":
  /***/ (function(module, exports, __webpack_require__) {

  var ctx = __webpack_require__("d864");
  var $export = __webpack_require__("63b6");
  var toObject = __webpack_require__("241e");
  var call = __webpack_require__("b0dc");
  var isArrayIter = __webpack_require__("3702");
  var toLength = __webpack_require__("b447");
  var createProperty = __webpack_require__("20fd");
  var getIterFn = __webpack_require__("7cd6");

  $export($export.S + $export.F * !__webpack_require__("4ee1")(function (iter) { }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = getIterFn(O);
      var length, result, step, iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });


  /***/ }),

  /***/ "54a1":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("6c1c");
  __webpack_require__("1654");
  module.exports = __webpack_require__("95d5");


  /***/ }),

  /***/ "5537":
  /***/ (function(module, exports, __webpack_require__) {

  var core = __webpack_require__("8378");
  var global = __webpack_require__("7726");
  var SHARED = '__core-js_shared__';
  var store = global[SHARED] || (global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: core.version,
    mode: __webpack_require__("2d00") ? 'pure' : 'global',
    copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
  });


  /***/ }),

  /***/ "5559":
  /***/ (function(module, exports, __webpack_require__) {

  var shared = __webpack_require__("dbdb")('keys');
  var uid = __webpack_require__("62a0");
  module.exports = function (key) {
    return shared[key] || (shared[key] = uid(key));
  };


  /***/ }),

  /***/ "584a":
  /***/ (function(module, exports) {

  var core = module.exports = { version: '2.6.5' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


  /***/ }),

  /***/ "5b4e":
  /***/ (function(module, exports, __webpack_require__) {

  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = __webpack_require__("36c3");
  var toLength = __webpack_require__("b447");
  var toAbsoluteIndex = __webpack_require__("0fc9");
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };


  /***/ }),

  /***/ "5ca1":
  /***/ (function(module, exports, __webpack_require__) {

  var global = __webpack_require__("7726");
  var core = __webpack_require__("8378");
  var hide = __webpack_require__("32e9");
  var redefine = __webpack_require__("2aba");
  var ctx = __webpack_require__("9b43");
  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // extend global
      if (target) redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  global.core = core;
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  module.exports = $export;


  /***/ }),

  /***/ "5d73":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("469f");

  /***/ }),

  /***/ "5f1b":
  /***/ (function(module, exports, __webpack_require__) {


  var classof = __webpack_require__("23c6");
  var builtinExec = RegExp.prototype.exec;

   // `RegExpExec` abstract operation
  // https://tc39.github.io/ecma262/#sec-regexpexec
  module.exports = function (R, S) {
    var exec = R.exec;
    if (typeof exec === 'function') {
      var result = exec.call(R, S);
      if (typeof result !== 'object') {
        throw new TypeError('RegExp exec method returned something other than an Object or null');
      }
      return result;
    }
    if (classof(R) !== 'RegExp') {
      throw new TypeError('RegExp#exec called on incompatible receiver');
    }
    return builtinExec.call(R, S);
  };


  /***/ }),

  /***/ "626a":
  /***/ (function(module, exports, __webpack_require__) {

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = __webpack_require__("2d95");
  // eslint-disable-next-line no-prototype-builtins
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };


  /***/ }),

  /***/ "62a0":
  /***/ (function(module, exports) {

  var id = 0;
  var px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };


  /***/ }),

  /***/ "63b6":
  /***/ (function(module, exports, __webpack_require__) {

  var global = __webpack_require__("e53d");
  var core = __webpack_require__("584a");
  var ctx = __webpack_require__("d864");
  var hide = __webpack_require__("35e8");
  var has = __webpack_require__("07e3");
  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && has(exports, key)) continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? ctx(out, global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  module.exports = $export;


  /***/ }),

  /***/ "6762":
  /***/ (function(module, exports, __webpack_require__) {

  // https://github.com/tc39/Array.prototype.includes
  var $export = __webpack_require__("5ca1");
  var $includes = __webpack_require__("c366")(true);

  $export($export.P, 'Array', {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  __webpack_require__("9c6c")('includes');


  /***/ }),

  /***/ "6821":
  /***/ (function(module, exports, __webpack_require__) {

  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = __webpack_require__("626a");
  var defined = __webpack_require__("be13");
  module.exports = function (it) {
    return IObject(defined(it));
  };


  /***/ }),

  /***/ "69a8":
  /***/ (function(module, exports) {

  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };


  /***/ }),

  /***/ "6a99":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = __webpack_require__("d3f4");
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };


  /***/ }),

  /***/ "6b4c":
  /***/ (function(module, exports) {

  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };


  /***/ }),

  /***/ "6c1c":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("c367");
  var global = __webpack_require__("e53d");
  var hide = __webpack_require__("35e8");
  var Iterators = __webpack_require__("481b");
  var TO_STRING_TAG = __webpack_require__("5168")('toStringTag');

  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');

  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = Iterators.Array;
  }


  /***/ }),

  /***/ "71c1":
  /***/ (function(module, exports, __webpack_require__) {

  var toInteger = __webpack_require__("3a38");
  var defined = __webpack_require__("25eb");
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that));
      var i = toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };


  /***/ }),

  /***/ "7726":
  /***/ (function(module, exports) {

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


  /***/ }),

  /***/ "774e":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("d2d5");

  /***/ }),

  /***/ "77f1":
  /***/ (function(module, exports, __webpack_require__) {

  var toInteger = __webpack_require__("4588");
  var max = Math.max;
  var min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };


  /***/ }),

  /***/ "794b":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = !__webpack_require__("8e60") && !__webpack_require__("294c")(function () {
    return Object.defineProperty(__webpack_require__("1ec9")('div'), 'a', { get: function () { return 7; } }).a != 7;
  });


  /***/ }),

  /***/ "79aa":
  /***/ (function(module, exports) {

  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };


  /***/ }),

  /***/ "79e5":
  /***/ (function(module, exports) {

  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };


  /***/ }),

  /***/ "7cd6":
  /***/ (function(module, exports, __webpack_require__) {

  var classof = __webpack_require__("40c3");
  var ITERATOR = __webpack_require__("5168")('iterator');
  var Iterators = __webpack_require__("481b");
  module.exports = __webpack_require__("584a").getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR]
      || it['@@iterator']
      || Iterators[classof(it)];
  };


  /***/ }),

  /***/ "7d7b":
  /***/ (function(module, exports, __webpack_require__) {

  var anObject = __webpack_require__("e4ae");
  var get = __webpack_require__("7cd6");
  module.exports = __webpack_require__("584a").getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };


  /***/ }),

  /***/ "7e90":
  /***/ (function(module, exports, __webpack_require__) {

  var dP = __webpack_require__("d9f6");
  var anObject = __webpack_require__("e4ae");
  var getKeys = __webpack_require__("c3a1");

  module.exports = __webpack_require__("8e60") ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };


  /***/ }),

  /***/ "8378":
  /***/ (function(module, exports) {

  var core = module.exports = { version: '2.6.5' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


  /***/ }),

  /***/ "8436":
  /***/ (function(module, exports) {

  module.exports = function () { /* empty */ };


  /***/ }),

  /***/ "86cc":
  /***/ (function(module, exports, __webpack_require__) {

  var anObject = __webpack_require__("cb7c");
  var IE8_DOM_DEFINE = __webpack_require__("c69a");
  var toPrimitive = __webpack_require__("6a99");
  var dP = Object.defineProperty;

  exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };


  /***/ }),

  /***/ "8aae":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("32a6");
  module.exports = __webpack_require__("584a").Object.keys;


  /***/ }),

  /***/ "8e60":
  /***/ (function(module, exports, __webpack_require__) {

  // Thank's IE8 for his funny defineProperty
  module.exports = !__webpack_require__("294c")(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });


  /***/ }),

  /***/ "8f60":
  /***/ (function(module, exports, __webpack_require__) {

  var create = __webpack_require__("a159");
  var descriptor = __webpack_require__("aebd");
  var setToStringTag = __webpack_require__("45f2");
  var IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  __webpack_require__("35e8")(IteratorPrototype, __webpack_require__("5168")('iterator'), function () { return this; });

  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };


  /***/ }),

  /***/ "9003":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.2.2 IsArray(argument)
  var cof = __webpack_require__("6b4c");
  module.exports = Array.isArray || function isArray(arg) {
    return cof(arg) == 'Array';
  };


  /***/ }),

  /***/ "9138":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("35e8");


  /***/ }),

  /***/ "9306":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.2.1 Object.assign(target, source, ...)
  var getKeys = __webpack_require__("c3a1");
  var gOPS = __webpack_require__("9aa9");
  var pIE = __webpack_require__("355d");
  var toObject = __webpack_require__("241e");
  var IObject = __webpack_require__("335c");
  var $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || __webpack_require__("294c")(function () {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = gOPS.f;
    var isEnum = pIE.f;
    while (aLen > index) {
      var S = IObject(arguments[index++]);
      var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    } return T;
  } : $assign;


  /***/ }),

  /***/ "9427":
  /***/ (function(module, exports, __webpack_require__) {

  var $export = __webpack_require__("63b6");
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  $export($export.S, 'Object', { create: __webpack_require__("a159") });


  /***/ }),

  /***/ "95d5":
  /***/ (function(module, exports, __webpack_require__) {

  var classof = __webpack_require__("40c3");
  var ITERATOR = __webpack_require__("5168")('iterator');
  var Iterators = __webpack_require__("481b");
  module.exports = __webpack_require__("584a").isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined
      || '@@iterator' in O
      // eslint-disable-next-line no-prototype-builtins
      || Iterators.hasOwnProperty(classof(O));
  };


  /***/ }),

  /***/ "9aa9":
  /***/ (function(module, exports) {

  exports.f = Object.getOwnPropertySymbols;


  /***/ }),

  /***/ "9b43":
  /***/ (function(module, exports, __webpack_require__) {

  // optional / simple context binding
  var aFunction = __webpack_require__("d8e8");
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };


  /***/ }),

  /***/ "9c6c":
  /***/ (function(module, exports, __webpack_require__) {

  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');
  var ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
  module.exports = function (key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };


  /***/ }),

  /***/ "9def":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.15 ToLength
  var toInteger = __webpack_require__("4588");
  var min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };


  /***/ }),

  /***/ "9e1e":
  /***/ (function(module, exports, __webpack_require__) {

  // Thank's IE8 for his funny defineProperty
  module.exports = !__webpack_require__("79e5")(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });


  /***/ }),

  /***/ "a159":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject = __webpack_require__("e4ae");
  var dPs = __webpack_require__("7e90");
  var enumBugKeys = __webpack_require__("1691");
  var IE_PROTO = __webpack_require__("5559")('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = __webpack_require__("1ec9")('iframe');
    var i = enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    __webpack_require__("32fc").appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };

  module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };


  /***/ }),

  /***/ "a352":
  /***/ (function(module, exports) {

  module.exports = Sortable;

  /***/ }),

  /***/ "a3c3":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.3.1 Object.assign(target, source)
  var $export = __webpack_require__("63b6");

  $export($export.S + $export.F, 'Object', { assign: __webpack_require__("9306") });


  /***/ }),

  /***/ "a481":
  /***/ (function(module, exports, __webpack_require__) {


  var anObject = __webpack_require__("cb7c");
  var toObject = __webpack_require__("4bf8");
  var toLength = __webpack_require__("9def");
  var toInteger = __webpack_require__("4588");
  var advanceStringIndex = __webpack_require__("0390");
  var regExpExec = __webpack_require__("5f1b");
  var max = Math.max;
  var min = Math.min;
  var floor = Math.floor;
  var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // @@replace logic
  __webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
    return [
      // `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = defined(this);
        var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
        return fn !== undefined
          ? fn.call(searchValue, O, replaceValue)
          : $replace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        var res = maybeCallNative($replace, regexp, this, replaceValue);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);
        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);
        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;
          results.push(result);
          if (!global) break;
          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = String(result[0]);
          var position = max(min(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];

      // https://tc39.github.io/ecma262/#sec-getsubstitution
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return $replace.call(replacement, symbols, function (match, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case '$': return '$';
          case '&': return matched;
          case '`': return str.slice(0, position);
          case "'": return str.slice(tailPos);
          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default: // \d\d?
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    }
  });


  /***/ }),

  /***/ "a4bb":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("8aae");

  /***/ }),

  /***/ "a745":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("f410");

  /***/ }),

  /***/ "aae3":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.2.8 IsRegExp(argument)
  var isObject = __webpack_require__("d3f4");
  var cof = __webpack_require__("2d95");
  var MATCH = __webpack_require__("2b4c")('match');
  module.exports = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };


  /***/ }),

  /***/ "aebd":
  /***/ (function(module, exports) {

  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };


  /***/ }),

  /***/ "b0c5":
  /***/ (function(module, exports, __webpack_require__) {

  var regexpExec = __webpack_require__("520a");
  __webpack_require__("5ca1")({
    target: 'RegExp',
    proto: true,
    forced: regexpExec !== /./.exec
  }, {
    exec: regexpExec
  });


  /***/ }),

  /***/ "b0dc":
  /***/ (function(module, exports, __webpack_require__) {

  // call something on iterator step with safe closing on error
  var anObject = __webpack_require__("e4ae");
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };


  /***/ }),

  /***/ "b447":
  /***/ (function(module, exports, __webpack_require__) {

  // 7.1.15 ToLength
  var toInteger = __webpack_require__("3a38");
  var min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };


  /***/ }),

  /***/ "b8e3":
  /***/ (function(module, exports) {

  module.exports = true;


  /***/ }),

  /***/ "be13":
  /***/ (function(module, exports) {

  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };


  /***/ }),

  /***/ "c366":
  /***/ (function(module, exports, __webpack_require__) {

  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = __webpack_require__("6821");
  var toLength = __webpack_require__("9def");
  var toAbsoluteIndex = __webpack_require__("77f1");
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };


  /***/ }),

  /***/ "c367":
  /***/ (function(module, exports, __webpack_require__) {

  var addToUnscopables = __webpack_require__("8436");
  var step = __webpack_require__("50ed");
  var Iterators = __webpack_require__("481b");
  var toIObject = __webpack_require__("36c3");

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  module.exports = __webpack_require__("30f1")(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators.Arguments = Iterators.Array;

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');


  /***/ }),

  /***/ "c3a1":
  /***/ (function(module, exports, __webpack_require__) {

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys = __webpack_require__("e6f3");
  var enumBugKeys = __webpack_require__("1691");

  module.exports = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
  };


  /***/ }),

  /***/ "c649":
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  /* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return insertNodeAt; });
  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return camelize; });
  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return console; });
  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeNode; });
  /* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a481");
  /* harmony import */ var F_source_Vue_Draggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("4aa6");
  /* harmony import */ var F_source_Vue_Draggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(F_source_Vue_Draggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__);



  function getConsole() {
    if (typeof window !== "undefined") {
      return window.console;
    }

    return global.console;
  }

  var console = getConsole();

  function cached(fn) {
    var cache = F_source_Vue_Draggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default()(null);

    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  var regex = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(regex, function (_, c) {
      return c ? c.toUpperCase() : "";
    });
  });

  function removeNode(node) {
    if (node.parentElement !== null) {
      node.parentElement.removeChild(node);
    }
  }

  function insertNodeAt(fatherNode, node, position) {
    var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
    fatherNode.insertBefore(node, refNode);
  }


  /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")));

  /***/ }),

  /***/ "c69a":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
    return Object.defineProperty(__webpack_require__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
  });


  /***/ }),

  /***/ "c8ba":
  /***/ (function(module, exports) {

  var g;

  // This works in non-strict mode
  g = (function() {
  	return this;
  })();

  try {
  	// This works if eval is allowed (see CSP)
  	g = g || new Function("return this")();
  } catch (e) {
  	// This works if the window reference is available
  	if (typeof window === "object") g = window;
  }

  // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}

  module.exports = g;


  /***/ }),

  /***/ "c8bb":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("54a1");

  /***/ }),

  /***/ "ca5a":
  /***/ (function(module, exports) {

  var id = 0;
  var px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };


  /***/ }),

  /***/ "cb7c":
  /***/ (function(module, exports, __webpack_require__) {

  var isObject = __webpack_require__("d3f4");
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };


  /***/ }),

  /***/ "ce7e":
  /***/ (function(module, exports, __webpack_require__) {

  // most Object methods by ES6 should accept primitives
  var $export = __webpack_require__("63b6");
  var core = __webpack_require__("584a");
  var fails = __webpack_require__("294c");
  module.exports = function (KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
  };


  /***/ }),

  /***/ "d2c8":
  /***/ (function(module, exports, __webpack_require__) {

  // helper for String#{startsWith, endsWith, includes}
  var isRegExp = __webpack_require__("aae3");
  var defined = __webpack_require__("be13");

  module.exports = function (that, searchString, NAME) {
    if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };


  /***/ }),

  /***/ "d2d5":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("1654");
  __webpack_require__("549b");
  module.exports = __webpack_require__("584a").Array.from;


  /***/ }),

  /***/ "d3f4":
  /***/ (function(module, exports) {

  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };


  /***/ }),

  /***/ "d864":
  /***/ (function(module, exports, __webpack_require__) {

  // optional / simple context binding
  var aFunction = __webpack_require__("79aa");
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };


  /***/ }),

  /***/ "d8e8":
  /***/ (function(module, exports) {

  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };


  /***/ }),

  /***/ "d9f6":
  /***/ (function(module, exports, __webpack_require__) {

  var anObject = __webpack_require__("e4ae");
  var IE8_DOM_DEFINE = __webpack_require__("794b");
  var toPrimitive = __webpack_require__("1bc3");
  var dP = Object.defineProperty;

  exports.f = __webpack_require__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };


  /***/ }),

  /***/ "dbdb":
  /***/ (function(module, exports, __webpack_require__) {

  var core = __webpack_require__("584a");
  var global = __webpack_require__("e53d");
  var SHARED = '__core-js_shared__';
  var store = global[SHARED] || (global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: core.version,
    mode: __webpack_require__("b8e3") ? 'pure' : 'global',
    copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
  });


  /***/ }),

  /***/ "dc62":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("9427");
  var $Object = __webpack_require__("584a").Object;
  module.exports = function create(P, D) {
    return $Object.create(P, D);
  };


  /***/ }),

  /***/ "e4ae":
  /***/ (function(module, exports, __webpack_require__) {

  var isObject = __webpack_require__("f772");
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };


  /***/ }),

  /***/ "e53d":
  /***/ (function(module, exports) {

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


  /***/ }),

  /***/ "e6f3":
  /***/ (function(module, exports, __webpack_require__) {

  var has = __webpack_require__("07e3");
  var toIObject = __webpack_require__("36c3");
  var arrayIndexOf = __webpack_require__("5b4e")(false);
  var IE_PROTO = __webpack_require__("5559")('IE_PROTO');

  module.exports = function (object, names) {
    var O = toIObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };


  /***/ }),

  /***/ "f410":
  /***/ (function(module, exports, __webpack_require__) {

  __webpack_require__("1af6");
  module.exports = __webpack_require__("584a").Array.isArray;


  /***/ }),

  /***/ "f559":
  /***/ (function(module, exports, __webpack_require__) {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])

  var $export = __webpack_require__("5ca1");
  var toLength = __webpack_require__("9def");
  var context = __webpack_require__("d2c8");
  var STARTS_WITH = 'startsWith';
  var $startsWith = ''[STARTS_WITH];

  $export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
    startsWith: function startsWith(searchString /* , position = 0 */) {
      var that = context(this, searchString, STARTS_WITH);
      var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = String(searchString);
      return $startsWith
        ? $startsWith.call(that, search, index)
        : that.slice(index, index + search.length) === search;
    }
  });


  /***/ }),

  /***/ "f772":
  /***/ (function(module, exports) {

  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };


  /***/ }),

  /***/ "fa5b":
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);


  /***/ }),

  /***/ "fb15":
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  __webpack_require__.r(__webpack_exports__);

  // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
  // This file is imported into lib/wc client bundles.

  if (typeof window !== 'undefined') {
    var setPublicPath_i;
    if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
      __webpack_require__.p = setPublicPath_i[1]; // eslint-disable-line
    }
  }

  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/assign.js
  var object_assign = __webpack_require__("5176");
  var assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);

  // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
  var es6_string_starts_with = __webpack_require__("f559");

  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/keys.js
  var keys = __webpack_require__("a4bb");
  var keys_default = /*#__PURE__*/__webpack_require__.n(keys);

  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js
  var is_array = __webpack_require__("a745");
  var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js

  function _arrayWithHoles(arr) {
    if (is_array_default()(arr)) return arr;
  }
  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js
  var get_iterator = __webpack_require__("5d73");
  var get_iterator_default = /*#__PURE__*/__webpack_require__.n(get_iterator);

  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = get_iterator_default()(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }
  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js



  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }
  // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
  var es7_array_includes = __webpack_require__("6762");

  // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
  var es6_string_includes = __webpack_require__("2fdb");

  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithoutHoles.js

  function _arrayWithoutHoles(arr) {
    if (is_array_default()(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }
  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/from.js
  var from = __webpack_require__("774e");
  var from_default = /*#__PURE__*/__webpack_require__.n(from);

  // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/is-iterable.js
  var is_iterable = __webpack_require__("c8bb");
  var is_iterable_default = /*#__PURE__*/__webpack_require__.n(is_iterable);

  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArray.js


  function _iterableToArray(iter) {
    if (is_iterable_default()(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return from_default()(iter);
  }
  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js



  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }
  // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}
  var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
  var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);

  // EXTERNAL MODULE: ./src/util/helper.js
  var helper = __webpack_require__("c649");

  // CONCATENATED MODULE: ./src/vuedraggable.js










  function buildAttribute(object, propName, value) {
    if (value === undefined) {
      return object;
    }

    object = object || {};
    object[propName] = value;
    return object;
  }

  function computeVmIndex(vnodes, element) {
    return vnodes.map(function (elt) {
      return elt.elm;
    }).indexOf(element);
  }

  function _computeIndexes(slots, children, isTransition, footerOffset) {
    if (!slots) {
      return [];
    }

    var elmFromNodes = slots.map(function (elt) {
      return elt.elm;
    });
    var footerIndex = children.length - footerOffset;

    var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
      return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
    });

    return isTransition ? rawIndexes.filter(function (ind) {
      return ind !== -1;
    }) : rawIndexes;
  }

  function emit(evtName, evtData) {
    var _this = this;

    this.$nextTick(function () {
      return _this.$emit(evtName.toLowerCase(), evtData);
    });
  }

  function delegateAndEmit(evtName) {
    var _this2 = this;

    return function (evtData) {
      if (_this2.realList !== null) {
        _this2["onDrag" + evtName](evtData);
      }

      emit.call(_this2, evtName, evtData);
    };
  }

  function isTransitionName(name) {
    return ["transition-group", "TransitionGroup"].includes(name);
  }

  function vuedraggable_isTransition(slots) {
    if (!slots || slots.length !== 1) {
      return false;
    }

    var _slots = _slicedToArray(slots, 1),
        componentOptions = _slots[0].componentOptions;

    if (!componentOptions) {
      return false;
    }

    return isTransitionName(componentOptions.tag);
  }

  function getSlot(slot, scopedSlot, key) {
    return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
  }

  function computeChildrenAndOffsets(children, slot, scopedSlot) {
    var headerOffset = 0;
    var footerOffset = 0;
    var header = getSlot(slot, scopedSlot, "header");

    if (header) {
      headerOffset = header.length;
      children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
    }

    var footer = getSlot(slot, scopedSlot, "footer");

    if (footer) {
      footerOffset = footer.length;
      children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
    }

    return {
      children: children,
      headerOffset: headerOffset,
      footerOffset: footerOffset
    };
  }

  function getComponentAttributes($attrs, componentData) {
    var attributes = null;

    var update = function update(name, value) {
      attributes = buildAttribute(attributes, name, value);
    };

    var attrs = keys_default()($attrs).filter(function (key) {
      return key === "id" || key.startsWith("data-");
    }).reduce(function (res, key) {
      res[key] = $attrs[key];
      return res;
    }, {});

    update("attrs", attrs);

    if (!componentData) {
      return attributes;
    }

    var on = componentData.on,
        props = componentData.props,
        componentDataAttrs = componentData.attrs;
    update("on", on);
    update("props", props);

    assign_default()(attributes.attrs, componentDataAttrs);

    return attributes;
  }

  var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
  var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
  var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
    return "on" + evt;
  });
  var draggingElement = null;
  var vuedraggable_props = {
    options: Object,
    list: {
      type: Array,
      required: false,
      default: null
    },
    value: {
      type: Array,
      required: false,
      default: null
    },
    noTransitionOnDrag: {
      type: Boolean,
      default: false
    },
    clone: {
      type: Function,
      default: function _default(original) {
        return original;
      }
    },
    element: {
      type: String,
      default: "div"
    },
    tag: {
      type: String,
      default: null
    },
    move: {
      type: Function,
      default: null
    },
    componentData: {
      type: Object,
      required: false,
      default: null
    }
  };
  var draggableComponent = {
    name: "draggable",
    inheritAttrs: false,
    props: vuedraggable_props,
    data: function data() {
      return {
        transitionMode: false,
        noneFunctionalComponentMode: false
      };
    },
    render: function render(h) {
      var slots = this.$slots.default;
      this.transitionMode = vuedraggable_isTransition(slots);

      var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
          children = _computeChildrenAndOf.children,
          headerOffset = _computeChildrenAndOf.headerOffset,
          footerOffset = _computeChildrenAndOf.footerOffset;

      this.headerOffset = headerOffset;
      this.footerOffset = footerOffset;
      var attributes = getComponentAttributes(this.$attrs, this.componentData);
      return h(this.getTag(), attributes, children);
    },
    created: function created() {
      if (this.list !== null && this.value !== null) {
        helper["b" /* console */].error("Value and list props are mutually exclusive! Please set one or another.");
      }

      if (this.element !== "div") {
        helper["b" /* console */].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
      }

      if (this.options !== undefined) {
        helper["b" /* console */].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
      }
    },
    mounted: function mounted() {
      var _this3 = this;

      this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

      if (this.noneFunctionalComponentMode && this.transitionMode) {
        throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
      }

      var optionsAdded = {};
      eventsListened.forEach(function (elt) {
        optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
      });
      eventsToEmit.forEach(function (elt) {
        optionsAdded["on" + elt] = emit.bind(_this3, elt);
      });

      var attributes = keys_default()(this.$attrs).reduce(function (res, key) {
        res[Object(helper["a" /* camelize */])(key)] = _this3.$attrs[key];
        return res;
      }, {});

      var options = assign_default()({}, this.options, attributes, optionsAdded, {
        onMove: function onMove(evt, originalEvent) {
          return _this3.onDragMove(evt, originalEvent);
        }
      });

      !("draggable" in options) && (options.draggable = ">*");
      this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
      this.computeIndexes();
    },
    beforeDestroy: function beforeDestroy() {
      if (this._sortable !== undefined) this._sortable.destroy();
    },
    computed: {
      rootContainer: function rootContainer() {
        return this.transitionMode ? this.$el.children[0] : this.$el;
      },
      realList: function realList() {
        return this.list ? this.list : this.value;
      }
    },
    watch: {
      options: {
        handler: function handler(newOptionValue) {
          this.updateOptions(newOptionValue);
        },
        deep: true
      },
      $attrs: {
        handler: function handler(newOptionValue) {
          this.updateOptions(newOptionValue);
        },
        deep: true
      },
      realList: function realList() {
        this.computeIndexes();
      }
    },
    methods: {
      getIsFunctional: function getIsFunctional() {
        var fnOptions = this._vnode.fnOptions;
        return fnOptions && fnOptions.functional;
      },
      getTag: function getTag() {
        return this.tag || this.element;
      },
      updateOptions: function updateOptions(newOptionValue) {
        for (var property in newOptionValue) {
          var value = Object(helper["a" /* camelize */])(property);

          if (readonlyProperties.indexOf(value) === -1) {
            this._sortable.option(value, newOptionValue[property]);
          }
        }
      },
      getChildrenNodes: function getChildrenNodes() {
        if (this.noneFunctionalComponentMode) {
          return this.$children[0].$slots.default;
        }

        var rawNodes = this.$slots.default;
        return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
      },
      computeIndexes: function computeIndexes() {
        var _this4 = this;

        this.$nextTick(function () {
          _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
        });
      },
      getUnderlyingVm: function getUnderlyingVm(htmlElt) {
        var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

        if (index === -1) {
          //Edge case during move callback: related element might be
          //an element different from collection
          return null;
        }

        var element = this.realList[index];
        return {
          index: index,
          element: element
        };
      },
      getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
        var vue = _ref.__vue__;

        if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
          if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
          return vue;
        }

        return vue.$parent;
      },
      emitChanges: function emitChanges(evt) {
        var _this5 = this;

        this.$nextTick(function () {
          _this5.$emit("change", evt);
        });
      },
      alterList: function alterList(onList) {
        if (this.list) {
          onList(this.list);
          return;
        }

        var newList = _toConsumableArray(this.value);

        onList(newList);
        this.$emit("input", newList);
      },
      spliceList: function spliceList() {
        var _arguments = arguments;

        var spliceList = function spliceList(list) {
          return list.splice.apply(list, _toConsumableArray(_arguments));
        };

        this.alterList(spliceList);
      },
      updatePosition: function updatePosition(oldIndex, newIndex) {
        var updatePosition = function updatePosition(list) {
          return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
        };

        this.alterList(updatePosition);
      },
      getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
        var to = _ref2.to,
            related = _ref2.related;
        var component = this.getUnderlyingPotencialDraggableComponent(to);

        if (!component) {
          return {
            component: component
          };
        }

        var list = component.realList;
        var context = {
          list: list,
          component: component
        };

        if (to !== related && list && component.getUnderlyingVm) {
          var destination = component.getUnderlyingVm(related);

          if (destination) {
            return assign_default()(destination, context);
          }
        }

        return context;
      },
      getVmIndex: function getVmIndex(domIndex) {
        var indexes = this.visibleIndexes;
        var numberIndexes = indexes.length;
        return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
      },
      getComponent: function getComponent() {
        return this.$slots.default[0].componentInstance;
      },
      resetTransitionData: function resetTransitionData(index) {
        if (!this.noTransitionOnDrag || !this.transitionMode) {
          return;
        }

        var nodes = this.getChildrenNodes();
        nodes[index].data = null;
        var transitionContainer = this.getComponent();
        transitionContainer.children = [];
        transitionContainer.kept = undefined;
      },
      onDragStart: function onDragStart(evt) {
        this.context = this.getUnderlyingVm(evt.item);
        evt.item._underlying_vm_ = this.clone(this.context.element);
        draggingElement = evt.item;
      },
      onDragAdd: function onDragAdd(evt) {
        var element = evt.item._underlying_vm_;

        if (element === undefined) {
          return;
        }

        Object(helper["d" /* removeNode */])(evt.item);
        var newIndex = this.getVmIndex(evt.newIndex);
        this.spliceList(newIndex, 0, element);
        this.computeIndexes();
        var added = {
          element: element,
          newIndex: newIndex
        };
        this.emitChanges({
          added: added
        });
      },
      onDragRemove: function onDragRemove(evt) {
        Object(helper["c" /* insertNodeAt */])(this.rootContainer, evt.item, evt.oldIndex);

        if (evt.pullMode === "clone") {
          Object(helper["d" /* removeNode */])(evt.clone);
          return;
        }

        var oldIndex = this.context.index;
        this.spliceList(oldIndex, 1);
        var removed = {
          element: this.context.element,
          oldIndex: oldIndex
        };
        this.resetTransitionData(oldIndex);
        this.emitChanges({
          removed: removed
        });
      },
      onDragUpdate: function onDragUpdate(evt) {
        Object(helper["d" /* removeNode */])(evt.item);
        Object(helper["c" /* insertNodeAt */])(evt.from, evt.item, evt.oldIndex);
        var oldIndex = this.context.index;
        var newIndex = this.getVmIndex(evt.newIndex);
        this.updatePosition(oldIndex, newIndex);
        var moved = {
          element: this.context.element,
          oldIndex: oldIndex,
          newIndex: newIndex
        };
        this.emitChanges({
          moved: moved
        });
      },
      updateProperty: function updateProperty(evt, propertyName) {
        evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
      },
      computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
        if (!relatedContext.element) {
          return 0;
        }

        var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
          return el.style["display"] !== "none";
        });

        var currentDOMIndex = domChildren.indexOf(evt.related);
        var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
        var draggedInList = domChildren.indexOf(draggingElement) !== -1;
        return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
      },
      onDragMove: function onDragMove(evt, originalEvent) {
        var onMove = this.move;

        if (!onMove || !this.realList) {
          return true;
        }

        var relatedContext = this.getRelatedContextFromMoveEvent(evt);
        var draggedContext = this.context;
        var futureIndex = this.computeFutureIndex(relatedContext, evt);

        assign_default()(draggedContext, {
          futureIndex: futureIndex
        });

        var sendEvt = assign_default()({}, evt, {
          relatedContext: relatedContext,
          draggedContext: draggedContext
        });

        return onMove(sendEvt, originalEvent);
      },
      onDragEnd: function onDragEnd() {
        this.computeIndexes();
        draggingElement = null;
      }
    }
  };

  if (typeof window !== "undefined" && "Vue" in window) {
    window.Vue.component("draggable", draggableComponent);
  }

  /* harmony default export */ var vuedraggable = (draggableComponent);
  // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


  /* harmony default export */ var entry_lib = __webpack_exports__["default"] = (vuedraggable);



  /***/ })

  /******/ })["default"];

  });

  var draggable = unwrapExports(vuedraggable_common);

  //
   
   var script$6 = {
       name: 'history-display',
       components: {
  	 draggable
       },
       data() {
  	 return {
  	     editable: true,
  	     isDragging: false,
  	     delayedDragging: false
  	 };
       },
       computed: {
  	 dragOptions() {
  	     return {
  		 animation: 0,
  		 group: "description",
  		 disabled: !this.editable,
  		 ghostClass: "ghost"
  	     };
  	 },
  	 ...mapState([
  	 'recent', 'nodes', 'ready'
  	 ])
       },
       methods: {
  	 onMove({ relatedContext, draggedContext }) {
  	     const relatedElement = relatedContext.element;
  	     const draggedElement = draggedContext.element;
  	     return (
  		 (!relatedElement || !relatedElement.fixed) && !draggedElement.fixed
  	     );
  	 },
  	 remove_from_history: function(node_id) {
  	     this.$store.dispatch('remove_from_history',node_id);
  	 },
  	 clear_history: function() {
  	     this.$store.dispatch('clear_history');
  	 }
       }
   };

  /* script */
  const __vue_script__$6 = script$6;

  /* template */
  var __vue_render__$7 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { attrs: { id: "working_set" } },
      [
        _c("h4", [
          _vm._v("\n\t    Working set "),
          _c(
            "span",
            {
              staticClass: "badge_button",
              on: {
                click: function($event) {
                  return _vm.clear_history()
                }
              }
            },
            [_vm._v("clear")]
          )
        ]),
        _vm.ready
          ? _c(
              "draggable",
              _vm._b(
                {
                  attrs: { element: "span", move: _vm.onMove },
                  model: {
                    value: _vm.recent,
                    callback: function($$v) {
                      _vm.recent = $$v;
                    },
                    expression: "recent"
                  }
                },
                "draggable",
                _vm.dragOptions,
                false
              ),
              [
                _c(
                  "transition-group",
                  { staticClass: "list-group", attrs: { name: "no", tag: "ul" } },
                  _vm._l(_vm.recent, function(node) {
                    return _c(
                      "li",
                      { key: node.id, staticClass: "list-group-item" },
                      [
                        _c("i", {
                          class: node.fixed ? "fa fa-lock" : "fa fa-pin",
                          attrs: { "aria-hidden": "true" },
                          on: {
                            click: function($event) {
                              node.fixed = !node.fixed;
                            }
                          }
                        }),
                        _c(
                          "div",
                          { staticStyle: { width: "90%", float: "left" } },
                          [
                            _c(
                              "router-link",
                              {
                                attrs: {
                                  to: { name: "node", params: { id: node.id } }
                                }
                              },
                              [_vm._v(_vm._s(_vm.nodes[node.id].name))]
                            ),
                            _c("br"),
                            _c("span", { staticClass: "node_snippet" }, [
                              _vm._v(_vm._s(_vm.nodes[node.id].snippet))
                            ])
                          ],
                          1
                        ),
                        _c(
                          "span",
                          {
                            staticClass: "badge_button",
                            on: {
                              click: function($event) {
                                return _vm.remove_from_history(node.id)
                              }
                            }
                          },
                          [_vm._v("x")]
                        )
                      ]
                    )
                  }),
                  0
                )
              ],
              1
            )
          : _vm._e()
      ],
      1
    )
  };
  var __vue_staticRenderFns__$7 = [];
  __vue_render__$7._withStripped = true;

    /* style */
    const __vue_inject_styles__$7 = function (inject) {
      if (!inject) return
      inject("data-v-66400312_0", { source: "\n#working_set[data-v-66400312]{\n    padding-top:5px;\n    padding-left:5px;\n}\n.flip-list-move[data-v-66400312] {\n    transition: transform 0.5s;\n}\n.no-move[data-v-66400312] {\n    transition: transform 0s;\n}\n.node_snippet[data-v-66400312] {\n    color:#ccc;\n}\n.ghost[data-v-66400312] {\n    opacity: 0.5;\n    background: #c8ebfb;\n}\n.list-group[data-v-66400312] {\n    min-height: 20px;\n}\n.list-group-item[data-v-66400312] {\n    cursor: move;\n}\n.list-group-item i[data-v-66400312] {\n    cursor: pointer;\n}\n.badge_button[data-v-66400312] {\n    cursor:pointer;\n    margin-right:5px;\n    display: inline-block;\n    min-width: 10px;\n    max-width: 10%;\n    padding: 3px 7px;\n    font-size: 12px;\n    font-weight: bold;\n    line-height: 1;\n    color: #fff;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: middle;\n    background-color: #777;\n    border-radius: 10px;\n    float:right;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/components/history.vue"],"names":[],"mappings":";AAkFA;IACA,eAAA;IACA,gBAAA;AACA;AACA;IACA,0BAAA;AACA;AACA;IACA,wBAAA;AACA;AACA;IACA,UAAA;AACA;AACA;IACA,YAAA;IACA,mBAAA;AACA;AACA;IACA,gBAAA;AACA;AACA;IACA,YAAA;AACA;AACA;IACA,eAAA;AACA;AACA;IACA,cAAA;IACA,gBAAA;IACA,qBAAA;IACA,eAAA;IACA,cAAA;IACA,gBAAA;IACA,eAAA;IACA,iBAAA;IACA,cAAA;IACA,WAAA;IACA,kBAAA;IACA,mBAAA;IACA,sBAAA;IACA,sBAAA;IACA,mBAAA;IACA,WAAA;AACA","file":"history.vue","sourcesContent":["<template>\n    <div id=\"working_set\">\n\t<h4>\n\t    Working set <span v-on:click=\"clear_history()\" class=\"badge_button\">clear</span>\n\t</h4>\n\t<!-- <div v-for=\"node in recent\">\n\t     <span v-on:click=\"remove_from_history(node)\" style=\"cursor:pointer;margin-right:5px;\">[x]</span> <router-link :to=\"{name:'node', params: {id: node}}\">{{nodes && nodes[node] ? nodes[node].name : \"loading...\"}}</router-link> -->\n\t<!-- <draggable v-model=\"recent\" element=\"span\">\n\t     <li v-for=\"node in recent\">\n\t     <i :class=\"element.fixed? 'fa fa-anchor' : 'glyphicon glyphicon-pushpin'\" @click=\" element.fixed=! element.fixed\" aria-hidden=\"true\"></i>\n\t     <router-link :to=\"{name:'doc', params: {id: node}}\">{{nodes[node].name}}</router-link>\n\t     \n\t     </li>\n\t     </draggable> -->\n\t\n\t<draggable v-if=\"ready\" element=\"span\" v-model=\"recent\" v-bind=\"dragOptions\" :move=\"onMove\">\n            <transition-group name=\"no\" class=\"list-group\" tag=\"ul\">\n\t\t<li class=\"list-group-item\" v-for=\"node in recent\" :key=\"node.id\">\n\t\t    <i :class=\"node.fixed ? 'fa fa-lock' : 'fa fa-pin'\" @click=\"node.fixed = !node.fixed\" aria-hidden=\"true\"></i>\n\t\t    <div style=\"width:90%;float:left;\">\n\t\t\t<router-link :to=\"{name:'node', params: {id: node.id}}\">{{nodes[node.id].name}}</router-link>\n\t\t\t<br />\n\t\t\t<span class=\"node_snippet\">{{nodes[node.id].snippet}}</span>\n\t\t    </div>\n\t\t    <span v-on:click=\"remove_from_history(node.id)\" class=\"badge_button\">x</span>\n\t\t</li>\n            </transition-group>\n\t</draggable>\n\t<!-- </div> -->\n    </div>\n</template>\n\n<script>\n import { mapState } from 'vuex'\n import draggable from \"vuedraggable\";\n \n export default {\n     name: 'history-display',\n     components: {\n\t draggable\n     },\n     data() {\n\t return {\n\t     editable: true,\n\t     isDragging: false,\n\t     delayedDragging: false\n\t };\n     },\n     computed: {\n\t dragOptions() {\n\t     return {\n\t\t animation: 0,\n\t\t group: \"description\",\n\t\t disabled: !this.editable,\n\t\t ghostClass: \"ghost\"\n\t     };\n\t },\n\t ...mapState([\n\t 'recent', 'nodes', 'ready'\n\t ])\n     },\n     methods: {\n\t onMove({ relatedContext, draggedContext }) {\n\t     const relatedElement = relatedContext.element;\n\t     const draggedElement = draggedContext.element;\n\t     return (\n\t\t (!relatedElement || !relatedElement.fixed) && !draggedElement.fixed\n\t     );\n\t },\n\t remove_from_history: function(node_id) {\n\t     this.$store.dispatch('remove_from_history',node_id);\n\t },\n\t clear_history: function() {\n\t     this.$store.dispatch('clear_history');\n\t }\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n #working_set{\n     padding-top:5px;\n     padding-left:5px;\n }\n .flip-list-move {\n     transition: transform 0.5s;\n }\n .no-move {\n     transition: transform 0s;\n }\n .node_snippet {\n     color:#ccc;\n }\n .ghost {\n     opacity: 0.5;\n     background: #c8ebfb;\n }\n .list-group {\n     min-height: 20px;\n }\n .list-group-item {\n     cursor: move;\n }\n .list-group-item i {\n     cursor: pointer;\n }\n .badge_button {\n     cursor:pointer;\n     margin-right:5px;\n     display: inline-block;\n     min-width: 10px;\n     max-width: 10%;\n     padding: 3px 7px;\n     font-size: 12px;\n     font-weight: bold;\n     line-height: 1;\n     color: #fff;\n     text-align: center;\n     white-space: nowrap;\n     vertical-align: middle;\n     background-color: #777;\n     border-radius: 10px;\n     float:right;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$7 = "data-v-66400312";
    /* module identifier */
    const __vue_module_identifier__$7 = undefined;
    /* functional template */
    const __vue_is_functional_template__$7 = false;
    /* style inject SSR */
    

    
    var HistoryDisplay = normalizeComponent_1(
      { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
      __vue_inject_styles__$7,
      __vue_script__$6,
      __vue_scope_id__$7,
      __vue_is_functional_template__$7,
      __vue_module_identifier__$7,
      browser,
      undefined
    );

  //

  var script$7 = {
       name: 'edge-display',
       props: ['node'],
       computed: mapState([
  	 'nodes'
       ])
  };

  /* script */
  const __vue_script__$7 = script$7;

  /* template */
  var __vue_render__$8 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "edge_display" },
      [
        _vm._l(_vm.nodes[_vm.node].edges.has, function(edges, label) {
          return _c(
            "div",
            _vm._l(edges, function(edge) {
              return _vm.nodes[edge.target].auto != "yes"
                ? _c(
                    "div",
                    [
                      _vm._v("\n\t\thas " + _vm._s(label) + ": \n\t\t"),
                      _c(
                        "router-link",
                        {
                          attrs: {
                            to:
                              "./" +
                              edge.target +
                              ("dstloc" in edge && edge.dstloc != null
                                ? "/" + edge.dstloc
                                : "")
                          }
                        },
                        [_vm._v(_vm._s(_vm.nodes[edge.target].name))]
                      )
                    ],
                    1
                  )
                : _vm._e()
            }),
            0
          )
        }),
        _vm._l(_vm.nodes[_vm.node].edges.is, function(edges, label) {
          return _c(
            "div",
            _vm._l(edges, function(edge) {
              return _vm.nodes[edge.target].auto != "yes"
                ? _c(
                    "div",
                    [
                      _vm._v("\n\t\tis " + _vm._s(label) + " of: \n\t\t"),
                      _c(
                        "router-link",
                        {
                          attrs: {
                            to:
                              "./" +
                              edge.target +
                              ("dstloc" in edge && edge.dstloc != null
                                ? "/" + edge.dstloc
                                : "")
                          }
                        },
                        [_vm._v(_vm._s(_vm.nodes[edge.target].name))]
                      )
                    ],
                    1
                  )
                : _vm._e()
            }),
            0
          )
        }),
        _c("b", [_vm._v("Auto-generated:")]),
        _vm._l(_vm.nodes[_vm.node].edges.has, function(edges, label) {
          return _c(
            "div",
            _vm._l(edges, function(edge) {
              return _vm.nodes[edge.target].auto == "yes"
                ? _c(
                    "div",
                    [
                      _vm._v("\n\t\thas " + _vm._s(label) + ": \n\t\t"),
                      _c(
                        "router-link",
                        {
                          attrs: {
                            to:
                              "./" +
                              edge.target +
                              ("dstloc" in edge && edge.dstloc != null
                                ? "/" + edge.dstloc
                                : "")
                          }
                        },
                        [_vm._v(_vm._s(_vm.nodes[edge.target].name))]
                      )
                    ],
                    1
                  )
                : _vm._e()
            }),
            0
          )
        }),
        _vm._l(_vm.nodes[_vm.node].edges.is, function(edges, label) {
          return _c(
            "div",
            _vm._l(edges, function(edge) {
              return _vm.nodes[edge.target].auto == "yes"
                ? _c(
                    "div",
                    [
                      _vm._v("\n\t\tis " + _vm._s(label) + " of: \n\t\t"),
                      _c(
                        "router-link",
                        {
                          attrs: {
                            to:
                              "./" +
                              edge.target +
                              ("dstloc" in edge && edge.dstloc != null
                                ? "/" + edge.dstloc
                                : "")
                          }
                        },
                        [_vm._v(_vm._s(_vm.nodes[edge.target].name))]
                      )
                    ],
                    1
                  )
                : _vm._e()
            }),
            0
          )
        })
      ],
      2
    )
  };
  var __vue_staticRenderFns__$8 = [];
  __vue_render__$8._withStripped = true;

    /* style */
    const __vue_inject_styles__$8 = function (inject) {
      if (!inject) return
      inject("data-v-552c7996_0", { source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"edges.vue"}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$8 = "data-v-552c7996";
    /* module identifier */
    const __vue_module_identifier__$8 = undefined;
    /* functional template */
    const __vue_is_functional_template__$8 = false;
    /* style inject SSR */
    

    
    var EdgeDisplay = normalizeComponent_1(
      { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
      __vue_inject_styles__$8,
      __vue_script__$7,
      __vue_scope_id__$8,
      __vue_is_functional_template__$8,
      __vue_module_identifier__$8,
      browser,
      undefined
    );

  //

   var script$8 = {
       name: 'search',
       props: ['nodes','initquery'],
       computed: { 
  	 resultset: function() {
  	     var ans = {};
  	     for(var r of this.result) {
  		 ans[r] = this.nodes[r];
  	     }
  	     return ans;
  	 },
  	 highlightset: function() {
  	     var ans = {};
  	     for(var r of this.highlight) {
  		 ans[r] = true;
  	     }
  	     console.log(ans);
  	     return ans;
  	 },
  	 best_highlights: function() {
  	     var nodes_by_deg = [];
  	     for(var n in this.highlightset) {
  		 var targets = {};
  		 for(var label in this.nodes[n].edges.has) {
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 for(var label in this.nodes[n].edges.is) {
  		     for(var edge of this.nodes[n].edges.is[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 var deg = 0;
  		 for(var t in targets) {
  		     deg++;
  		 }
  		 nodes_by_deg.push({"node":n,"degree":deg});
  	     }
  	     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });
  	     return nodes_by_deg.slice(0,10);
  	 },
  	 best_nodes: function() {
  	     var nodes_by_deg = [];
  	     for(var n in this.resultset) {
  		 var targets = {};
  		 for(var label in this.nodes[n].edges.has) {
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 for(var label in this.nodes[n].edges.is) {
  		     for(var edge of this.nodes[n].edges.is[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     targets[target] = true;
  			 }
  		     }
  		 }
  		 var deg = 0;
  		 for(var t in targets) {
  		     deg++;
  		 }
  		 nodes_by_deg.push({"node":n,"degree":deg});
  	     }
  	     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });
  	     return nodes_by_deg.slice(0,10);
  	 },
  	 best_edges: function() {
  	     var edges_with_count = {};
  	     for(var n in this.resultset) {
  		 // only need to count the has direction since the is direction will be accounted for when iterating over the has edges of the target
  		 for(var label in this.nodes[n].edges.has) {
  		     if(!(label in edges_with_count)) {
  			 edges_with_count[label] = 0;
  		     }
  		     for(var edge of this.nodes[n].edges.has[label]) {
  			 var target = edge.target;
  			 if(target in this.resultset) {
  			     edges_with_count[label]++;
  			 }
  		     }
  		 }
  	     }
  	     var edges_by_count = [];
  	     for(var e in edges_with_count) {
  		 edges_by_count.push({"edge":e,"count":edges_with_count[e]});
  	     }
  	     edges_by_count.sort(function(a, b){return b.count-a.count;});
  	     return edges_by_count.slice(0,10);
  	 },

       },
       data() {
  	 return {
  	     entered_query: '',
  	     query: '',
  	     highlight_query: '',
  	     errormsg: '',
  	     result: [],
  	     highlight: [],
  	     mode: 'graph',
  	 }
       },
       watch: {
  	 nodes: function(val) {
  	     this.$nextTick(function () {
  		 this.search();
  	     });
  	 }
       },
       methods: {
  	 goto_node: function(e) {
  	     console.log("GOTO",e);
  	     this.$router.push("/node/"+e);
  	 },
  	 add_to_query: function(qry) {
  	     if(this.query.trim().length > 0 && this.query.trim() != "*") {
  		 this.query = "("+this.query+"),"+qry;
  	     }
  	     else {
  		 this.query = qry;
  	     }
  	     this.search();
  	 },
  	 set_query: function(qry) {
  	     this.query = qry;
  	     this.highlight_query = "";
  	     this.do_highlight();
  	     this.search();
  	 },
  	 set_highlight: function(qry) {
  	     this.highlight_query = qry;
  	     this.do_highlight();
  	 },
  	 run_search: function(qry, nodeset) {
  	     this.entered_query = qry;
  	     this.errormsg = "";
  	     if(qry.trim().length == 0) {
  		 return [];
  	     }
  	     try {
  		 var q = Vue$1.category_query.parse(qry);
  	     }
  	     catch(e){
  		 this.errormsg = e.toString();
  		 return [];
  	     }
  	     return Vue$1.category_search(q, nodeset);
  	 },
  	 search: function() {
  	     if(this.query.trim().length == 0) {
  		 this.query = "*";
  	     }
  	     var query_result = this.run_search(this.query, this.nodes);
  	     console.log(query_result);
  	     if(query_result.length == 0) {
  		 return;
  	     }
  	     if(query_result.length == 1) {
  		 this.$router.push('/node/'+query_result[0]);
  	     }
  	     else {
  		 this.result = query_result;
  		 console.log("RES",this.result);
  		 for(var i = 0; i < this.result.length; i++){
  		     if(this.nodes[this.result[i]].name == this.query.trim()) {
  			 this.$router.push('/node/'+this.result[i]);
  			 break;
  		     }
  		 }
  	     }
  	 },
  	 do_highlight: function() {
  	     this.highlight = this.run_search(this.highlight_query, this.resultset);
  	 },
  	 expand_highlight: function() {
  	     this.highlight_query = "("+this.highlight_query+")[1]";
  	     this.do_highlight();
  	 },
  	 clear_highlight: function() {
  	     this.highlight_query = "";
  	     this.do_highlight();
  	 }
       },
       mounted: function() {
  	 this.query = this.initquery;
  	 this.search();
       }
   };

  /* script */
  const __vue_script__$8 = script$8;

  /* template */
  var __vue_render__$9 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "searchbar" }, [
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.query,
            expression: "query"
          }
        ],
        attrs: { type: "text", id: "query_input" },
        domProps: { value: _vm.query },
        on: {
          keyup: function($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
            ) {
              return null
            }
            return _vm.search($event)
          },
          input: function($event) {
            if ($event.target.composing) {
              return
            }
            _vm.query = $event.target.value;
          }
        }
      }),
      _c(
        "span",
        {
          staticClass: "close_x",
          on: {
            click: function($event) {
              _vm.mode = "list";
            }
          }
        },
        [_c("span", { staticClass: "fas fa-list" })]
      ),
      _c(
        "span",
        {
          staticClass: "close_x",
          on: {
            click: function($event) {
              _vm.mode = "graph";
            }
          }
        },
        [_c("span", { staticClass: "fas fa-project-diagram" })]
      ),
      _vm.errormsg.length > 0
        ? _c("span", { staticClass: "search-error" }, [
            _vm._v(_vm._s(_vm.errormsg))
          ])
        : _vm._e(),
      _vm.mode == "graph"
        ? _c("div", [
            _c(
              "div",
              { staticStyle: { float: "left", width: "20%" } },
              [
                _vm.highlight.length > 0
                  ? _c(
                      "div",
                      [
                        _c("b", [_vm._v("Highlighted")]),
                        _vm._l(_vm.best_highlights, function(n) {
                          return _c(
                            "div",
                            { staticClass: "sidebar-item" },
                            [
                              _c(
                                "router-link",
                                { attrs: { to: "./node/" + n.node } },
                                [
                                  _vm._v(
                                    _vm._s(_vm.nodes[n.node].name) +
                                      " (" +
                                      _vm._s(n.degree) +
                                      ")"
                                  )
                                ]
                              )
                            ],
                            1
                          )
                        }),
                        _c("hr")
                      ],
                      2
                    )
                  : _vm._e(),
                _c("b", [_vm._v("Top nodes")]),
                _vm._l(_vm.best_nodes, function(n) {
                  return _c("div", { staticClass: "sidebar-item" }, [
                    _c("div", { staticStyle: { display: "inline-block" } }, [
                      _c(
                        "span",
                        {
                          staticClass: "badge_button",
                          on: {
                            click: function($event) {
                              _vm.add_to_query(
                                "((=" +
                                  _vm.nodes[n.node].name +
                                  ")[2], !(=" +
                                  _vm.nodes[n.node].name +
                                  "))"
                              );
                            }
                          }
                        },
                        [_vm._v("+")]
                      ),
                      _c(
                        "span",
                        {
                          staticClass: "badge_button",
                          on: {
                            click: function($event) {
                              _vm.add_to_query(
                                "!(=" + _vm.nodes[n.node].name + ")"
                              );
                            }
                          }
                        },
                        [_vm._v("-")]
                      )
                    ]),
                    _c(
                      "a",
                      {
                        attrs: { href: "#" },
                        on: {
                          click: function($event) {
                            _vm.set_highlight(
                              "(=" + _vm.nodes[n.node].name + ")[1]"
                            );
                          }
                        }
                      },
                      [
                        _vm._v(
                          _vm._s(_vm.nodes[n.node].name) +
                            " (" +
                            _vm._s(n.degree) +
                            ")"
                        )
                      ]
                    )
                  ])
                }),
                _c("hr"),
                _c("b", [_vm._v("Top labels")]),
                _vm._l(_vm.best_edges, function(e) {
                  return _c("div", { staticClass: "sidebar-item" }, [
                    _c("div", { staticStyle: { display: "inline-block" } }, [
                      _c(
                        "span",
                        {
                          staticClass: "badge_button",
                          on: {
                            click: function($event) {
                              _vm.add_to_query(
                                "(has " + e.edge + " / is " + e.edge + ")"
                              );
                            }
                          }
                        },
                        [_vm._v("+")]
                      ),
                      _c(
                        "span",
                        {
                          staticClass: "badge_button",
                          on: {
                            click: function($event) {
                              _vm.add_to_query("!(is " + e.edge + ")");
                            }
                          }
                        },
                        [_vm._v("-")]
                      )
                    ]),
                    _c(
                      "a",
                      {
                        attrs: { href: "#" },
                        on: {
                          click: function($event) {
                            _vm.set_highlight("(is " + e.edge + ")");
                          }
                        }
                      },
                      [_vm._v(_vm._s(e.edge) + " (" + _vm._s(e.count) + ")")]
                    )
                  ])
                })
              ],
              2
            ),
            _c(
              "div",
              { staticStyle: { float: "left", width: "80%" } },
              [
                _c("div", { staticStyle: { float: "left" } }, [
                  _vm._v("Highlight: "),
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.highlight_query,
                        expression: "highlight_query"
                      }
                    ],
                    attrs: { type: "text", id: "highlight_input" },
                    domProps: { value: _vm.highlight_query },
                    on: {
                      keyup: function($event) {
                        if (
                          !$event.type.indexOf("key") &&
                          _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                        ) {
                          return null
                        }
                        return _vm.do_highlight($event)
                      },
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.highlight_query = $event.target.value;
                      }
                    }
                  }),
                  _c(
                    "span",
                    {
                      staticClass: "close_x",
                      on: {
                        click: function($event) {
                          return _vm.do_highlight()
                        }
                      }
                    },
                    [_c("span", { staticClass: "fas fa-search" })]
                  ),
                  _c(
                    "span",
                    {
                      staticClass: "close_x",
                      on: {
                        click: function($event) {
                          return _vm.expand_highlight()
                        }
                      }
                    },
                    [_c("span", { staticClass: "fas fa-plus" })]
                  ),
                  _c(
                    "span",
                    {
                      staticClass: "close_x",
                      on: {
                        click: function($event) {
                          return _vm.clear_highlight()
                        }
                      }
                    },
                    [_c("span", { staticClass: "fas fa-backspace" })]
                  ),
                  _c(
                    "span",
                    {
                      staticClass: "close_x",
                      on: {
                        click: function($event) {
                          return _vm.set_query(_vm.highlight_query)
                        }
                      }
                    },
                    [_c("span", { staticClass: "fas fa-search-plus" })]
                  ),
                  _c(
                    "span",
                    {
                      staticClass: "close_x",
                      on: {
                        click: function($event) {
                          _vm.add_to_query("!(" + _vm.highlight_query + ")");
                        }
                      }
                    },
                    [_c("span", { staticClass: "fas fa-search-minus" })]
                  )
                ]),
                _c("br"),
                _c("br"),
                _vm.result.length > 0
                  ? _c("graph-index", {
                      attrs: {
                        nodeset: _vm.resultset,
                        highlight: _vm.highlightset
                      },
                      on: { clickedNode: _vm.goto_node }
                    })
                  : _vm._e()
              ],
              1
            )
          ])
        : _vm._e(),
      _vm.mode == "list"
        ? _c(
            "div",
            [
              _vm.result.length > 0
                ? _c("node-index", { attrs: { nodeset: _vm.resultset } })
                : _vm._e()
            ],
            1
          )
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$9 = [];
  __vue_render__$9._withStripped = true;

    /* style */
    const __vue_inject_styles__$9 = function (inject) {
      if (!inject) return
      inject("data-v-4ddbaeeb_0", { source: "\n.sidebar-item[data-v-4ddbaeeb] {\n    border:1px solid #66f;\n    border-radius:3px;\n    margin:1px;\n    overflow:hidden;\n    white-space:nowrap;\n    padding:2px;\n}\n.search-error[data-v-4ddbaeeb] {\n    font-family: monospace;\n    white-space: pre;\n    color: #e33;\n}\n.badge_button[data-v-4ddbaeeb] {\n    cursor:pointer;\n    margin-right:5px;\n    display: inline-block;\n    min-width: 10px;\n    padding: 3px 7px;\n    font-size: 12px;\n    font-weight: bold;\n    line-height: 1;\n    color: #fff;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: middle;\n    background-color: #777;\n    border-radius: 10px;\n    float:right;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/components/search/search.vue"],"names":[],"mappings":";AAqQA;IACA,qBAAA;IACA,iBAAA;IACA,UAAA;IACA,eAAA;IACA,kBAAA;IACA,WAAA;AACA;AACA;IACA,sBAAA;IACA,gBAAA;IACA,WAAA;AACA;AACA;IACA,cAAA;IACA,gBAAA;IACA,qBAAA;IACA,eAAA;IACA,gBAAA;IACA,eAAA;IACA,iBAAA;IACA,cAAA;IACA,WAAA;IACA,kBAAA;IACA,mBAAA;IACA,sBAAA;IACA,sBAAA;IACA,mBAAA;IACA,WAAA;AACA","file":"search.vue","sourcesContent":["<template>\n    <div class=\"searchbar\"> \n\t<input type=\"text\" id=\"query_input\" v-model=\"query\" v-on:keyup.enter=\"search\" />\n\t<span v-on:click=\"mode='list'\" class=\"close_x\"><span class=\"fas fa-list\"></span></span>\n\t<span v-on:click=\"mode='graph'\" class=\"close_x\"><span class=\"fas fa-project-diagram\"></span></span>\n\t<span class=\"search-error\" v-if=\"errormsg.length > 0\">{{errormsg}}</span>\n\n\n\t<div v-if=\"mode=='graph'\">\n\t    <div style=\"float:left;width:20%;\">\n\t\t<div v-if=\"highlight.length > 0\">\n\t\t    <b>Highlighted</b>\n\t\t    <div v-for=\"n in best_highlights\" class=\"sidebar-item\">\n\t\t\t<router-link :to=\"'./node/'+ n.node\">{{nodes[n.node].name}} ({{n.degree}})</router-link>\n\t\t    </div>\n\t\t    <hr />\n\t\t</div>\n\t\t<b>Top nodes</b>\n\t\t<div v-for=\"n in best_nodes\" class=\"sidebar-item\">\n\t\t    <div style=\"display:inline-block;\">\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('((=' + nodes[n.node].name + ')[2], !(=' + nodes[n.node].name + '))')\">+</span>\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('!(=' + nodes[n.node].name + ')')\">-</span>\n\t\t    </div>\n\t\t    <a href=\"#\" v-on:click=\"set_highlight('(=' + nodes[n.node].name + ')[1]')\">{{nodes[n.node].name}} ({{n.degree}})</a> \n\t\t</div>\n\t\t<hr />\n\t\t<b>Top labels</b>\n\t\t<div v-for=\"e in best_edges\" class=\"sidebar-item\">\n\t\t    <div style=\"display:inline-block;\">\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('(has ' + e.edge + ' / is ' + e.edge + ')')\">+</span>\n\t\t\t<span class=\"badge_button\" v-on:click=\"add_to_query('!(is ' + e.edge + ')')\">-</span>\n\t\t    </div>\n\t\t    <a href=\"#\" v-on:click=\"set_highlight('(is ' + e.edge + ')')\">{{e.edge}} ({{e.count}})</a>\n\t\t</div>\n\t    </div>\n\t    <div style=\"float:left;width:80%;\">\n\t\t<div style=\"float:left\">Highlight: <input type=\"text\" id=\"highlight_input\" v-model=\"highlight_query\" v-on:keyup.enter=\"do_highlight\" />\n\t\t    <span v-on:click=\"do_highlight()\" class=\"close_x\"><span class=\"fas fa-search\"></span></span>\n\t\t    <span v-on:click=\"expand_highlight()\" class=\"close_x\"><span class=\"fas fa-plus\"></span></span>\n\t\t    <span v-on:click=\"clear_highlight()\" class=\"close_x\"><span class=\"fas fa-backspace\"></span></span>\n\t\t    <span v-on:click=\"set_query(highlight_query)\" class=\"close_x\"><span class=\"fas fa-search-plus\"></span></span>\n\t\t    <span v-on:click=\"add_to_query('!('+highlight_query+')')\" class=\"close_x\"><span class=\"fas fa-search-minus\"></span></span>\n\t\t</div><br /><br />\n\t\t<graph-index :nodeset=\"resultset\" :highlight=\"highlightset\" v-if=\"result.length > 0\" v-on:clickedNode=\"goto_node\"></graph-index>\n\t    </div>\n\t</div>\n\t<div v-if=\"mode=='list'\">\n\t    <node-index :nodeset=\"resultset\" v-if=\"result.length > 0\"></node-index>\n\t</div>\n    </div>\n</template>\n\n<script>\n import Vue from 'vue'\n import { mapState } from 'vuex'\n\n export default {\n     name: 'search',\n     props: ['nodes','initquery'],\n     computed: { \n\t resultset: function() {\n\t     var ans = {};\n\t     for(var r of this.result) {\n\t\t ans[r] = this.nodes[r];\n\t     }\n\t     return ans;\n\t },\n\t highlightset: function() {\n\t     var ans = {};\n\t     for(var r of this.highlight) {\n\t\t ans[r] = true;\n\t     }\n\t     console.log(ans);\n\t     return ans;\n\t },\n\t best_highlights: function() {\n\t     var nodes_by_deg = [];\n\t     for(var n in this.highlightset) {\n\t\t var targets = {}\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t for(var label in this.nodes[n].edges.is) {\n\t\t     for(var edge of this.nodes[n].edges.is[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t var deg = 0;\n\t\t for(var t in targets) {\n\t\t     deg++;\n\t\t }\n\t\t nodes_by_deg.push({\"node\":n,\"degree\":deg});\n\t     }\n\t     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });\n\t     return nodes_by_deg.slice(0,10);\n\t },\n\t best_nodes: function() {\n\t     var nodes_by_deg = [];\n\t     for(var n in this.resultset) {\n\t\t var targets = {}\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t for(var label in this.nodes[n].edges.is) {\n\t\t     for(var edge of this.nodes[n].edges.is[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     targets[target] = true;\n\t\t\t }\n\t\t     }\n\t\t }\n\t\t var deg = 0;\n\t\t for(var t in targets) {\n\t\t     deg++;\n\t\t }\n\t\t nodes_by_deg.push({\"node\":n,\"degree\":deg});\n\t     }\n\t     nodes_by_deg.sort(function(a, b){ return b.degree - a.degree; });\n\t     return nodes_by_deg.slice(0,10);\n\t },\n\t best_edges: function() {\n\t     var edges_with_count = {};\n\t     for(var n in this.resultset) {\n\t\t var count = 0;\n\t\t // only need to count the has direction since the is direction will be accounted for when iterating over the has edges of the target\n\t\t for(var label in this.nodes[n].edges.has) {\n\t\t     if(!(label in edges_with_count)) {\n\t\t\t edges_with_count[label] = 0\n\t\t     }\n\t\t     for(var edge of this.nodes[n].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t if(target in this.resultset) {\n\t\t\t     edges_with_count[label]++;\n\t\t\t }\n\t\t     }\n\t\t }\n\t     }\n\t     var edges_by_count = [];\n\t     for(var e in edges_with_count) {\n\t\t edges_by_count.push({\"edge\":e,\"count\":edges_with_count[e]})\n\t     }\n\t     edges_by_count.sort(function(a, b){return b.count-a.count;});\n\t     return edges_by_count.slice(0,10);\n\t },\n\n     },\n     data() {\n\t return {\n\t     entered_query: '',\n\t     query: '',\n\t     highlight_query: '',\n\t     errormsg: '',\n\t     result: [],\n\t     highlight: [],\n\t     mode: 'graph',\n\t }\n     },\n     watch: {\n\t nodes: function(val) {\n\t     this.$nextTick(function () {\n\t\t this.search();\n\t     });\n\t }\n     },\n     methods: {\n\t goto_node: function(e) {\n\t     console.log(\"GOTO\",e);\n\t     this.$router.push(\"/node/\"+e);\n\t },\n\t add_to_query: function(qry) {\n\t     if(this.query.trim().length > 0 && this.query.trim() != \"*\") {\n\t\t this.query = \"(\"+this.query+\"),\"+qry;\n\t     }\n\t     else {\n\t\t this.query = qry;\n\t     }\n\t     this.search();\n\t },\n\t set_query: function(qry) {\n\t     this.query = qry;\n\t     this.highlight_query = \"\";\n\t     this.do_highlight();\n\t     this.search();\n\t },\n\t set_highlight: function(qry) {\n\t     this.highlight_query = qry;\n\t     this.do_highlight();\n\t },\n\t run_search: function(qry, nodeset) {\n\t     this.entered_query = qry;\n\t     this.errormsg = \"\";\n\t     if(qry.trim().length == 0) {\n\t\t return [];\n\t     }\n\t     try {\n\t\t var q = Vue.category_query.parse(qry);\n\t     }\n\t     catch(e){\n\t\t this.errormsg = e.toString();\n\t\t return [];\n\t     }\n\t     return Vue.category_search(q, nodeset);\n\t },\n\t search: function() {\n\t     if(this.query.trim().length == 0) {\n\t\t this.query = \"*\";\n\t     }\n\t     var query_result = this.run_search(this.query, this.nodes)\n\t     console.log(query_result);\n\t     if(query_result.length == 0) {\n\t\t return;\n\t     }\n\t     if(query_result.length == 1) {\n\t\t this.$router.push('/node/'+query_result[0]);\n\t     }\n\t     else {\n\t\t this.result = query_result;\n\t\t console.log(\"RES\",this.result);\n\t\t for(var i = 0; i < this.result.length; i++){\n\t\t     if(this.nodes[this.result[i]].name == this.query.trim()) {\n\t\t\t this.$router.push('/node/'+this.result[i]);\n\t\t\t break;\n\t\t     }\n\t\t }\n\t     }\n\t },\n\t do_highlight: function() {\n\t     this.highlight = this.run_search(this.highlight_query, this.resultset);\n\t },\n\t expand_highlight: function() {\n\t     this.highlight_query = \"(\"+this.highlight_query+\")[1]\";\n\t     this.do_highlight();\n\t },\n\t clear_highlight: function() {\n\t     this.highlight_query = \"\";\n\t     this.do_highlight();\n\t }\n     },\n     mounted: function() {\n\t this.query = this.initquery;\n\t this.search();\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n .sidebar-item {\n     border:1px solid #66f;\n     border-radius:3px;\n     margin:1px;\n     overflow:hidden;\n     white-space:nowrap;\n     padding:2px;\n }\n .search-error {\n     font-family: monospace;\n     white-space: pre;\n     color: #e33;\n }\n .badge_button {\n     cursor:pointer;\n     margin-right:5px;\n     display: inline-block;\n     min-width: 10px;\n     padding: 3px 7px;\n     font-size: 12px;\n     font-weight: bold;\n     line-height: 1;\n     color: #fff;\n     text-align: center;\n     white-space: nowrap;\n     vertical-align: middle;\n     background-color: #777;\n     border-radius: 10px;\n     float:right;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$9 = "data-v-4ddbaeeb";
    /* module identifier */
    const __vue_module_identifier__$9 = undefined;
    /* functional template */
    const __vue_is_functional_template__$9 = false;
    /* style inject SSR */
    

    
    var SearchDisplay = normalizeComponent_1(
      { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
      __vue_inject_styles__$9,
      __vue_script__$8,
      __vue_scope_id__$9,
      __vue_is_functional_template__$9,
      __vue_module_identifier__$9,
      browser,
      undefined
    );

  var domain;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.usingDomains = false;

  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active && !(this instanceof domain.Domain)) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = (type === 'error');

    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler)
      return false;

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] :
                                            [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + type + ' listeners added. ' +
                              'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');

        events = this._events;
        if (!events)
          return this;

        list = events[type];
        if (!list)
          return this;

        if (list === listener || (list.listener && list.listener === listener)) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length; i-- > 0;) {
            if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (list.length === 1) {
            list[0] = undefined;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }

          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events;

        events = this._events;
        if (!events)
          return this;

        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i = 0, key; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          do {
            this.removeListener(type, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }

        return this;
      };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === 'function')
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }

    return ret;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--)
      copy[i] = arr[i];
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  /**
   * Obliterator Iterator Class
   * ===========================
   *
   * Simple class representing the library's iterators.
   */

  /**
   * Iterator class.
   *
   * @constructor
   * @param {function} next - Next function.
   */
  function Iterator(next) {

    // Hiding the given function
    Object.defineProperty(this, '_next', {
      writable: false,
      enumerable: false,
      value: next
    });

    // Is the iterator complete?
    this.done = false;
  }

  /**
   * Next function.
   *
   * @return {object}
   */
  // NOTE: maybe this should dropped for performance?
  Iterator.prototype.next = function() {
    if (this.done)
      return {done: true};

    var step = this._next();

    if (step.done)
      this.done = true;

    return step;
  };

  /**
   * If symbols are supported, we add `next` to `Symbol.iterator`.
   */
  if (typeof Symbol !== 'undefined')
    Iterator.prototype[Symbol.iterator] = function() {
      return this;
    };

  /**
   * Returning an iterator of the given values.
   *
   * @param  {any...} values - Values.
   * @return {Iterator}
   */
  Iterator.of = function() {
    var args = arguments,
        l = args.length,
        i = 0;

    return new Iterator(function() {
      if (i >= l)
        return {done: true};

      return {done: false, value: args[i++]};
    });
  };

  /**
   * Returning an empty iterator.
   *
   * @return {Iterator}
   */
  Iterator.empty = function() {
    var iterator = new Iterator(null);
    iterator.done = true;

    return iterator;
  };

  /**
   * Returning whether the given value is an iterator.
   *
   * @param  {any} value - Value.
   * @return {boolean}
   */
  Iterator.is = function(value) {
    if (value instanceof Iterator)
      return true;

    return (
      typeof value === 'object' &&
      value !== null &&
      typeof value.next === 'function'
    );
  };

  /**
   * Exporting.
   */
  var iterator = Iterator;

  /* eslint no-constant-condition: 0 */
  /**
   * Obliterator Take Function
   * ==========================
   *
   * Function taking n or every value of the given iterator and returns them
   * into an array.
   */

  /**
   * Take.
   *
   * @param  {Iterator} iterator - Target iterator.
   * @param  {number}   [n]      - Optional number of items to take.
   * @return {array}
   */
  var take = function take(iterator, n) {
    var l = arguments.length > 1 ? n : Infinity,
        array = l !== Infinity ? new Array(l) : [],
        step,
        i = 0;

    while (true) {

      if (i === l)
        return array;

      step = iterator.next();

      if (step.done) {

        if (i !== n)
          return array.slice(0, i);

        return array;
      }

      array[i++] = step.value;
    }
  };

  /**
   * Obliterator Chain Function
   * ===========================
   *
   * Variadic function combining the given iterators.
   */


  /**
   * Chain.
   *
   * @param  {...Iterator} iterators - Target iterators.
   * @return {Iterator}
   */
  var chain = function chain() {
    var iterators = arguments,
        current,
        i = -1;

    return new iterator(function iterate() {
      if (!current) {
        i++;

        if (i >= iterators.length)
          return {done: true};

        current = iterators[i];
      }

      var step = current.next();

      if (step.done) {
        current = null;
        return iterate();
      }

      return step;
    });
  };

  /**
   * Graphology Utilities
   * =====================
   *
   * Collection of helpful functions used by the implementation.
   */

  /**
   * Very simple Object.assign-like function.
   *
   * @param  {object} target       - First object.
   * @param  {object} [...objects] - Objects to merge.
   * @return {object}
   */
  function assign() {
    const target = arguments[0] || {};

    for (let i = 1, l = arguments.length; i < l; i++) {
      if (!arguments[i])
        continue;

      for (const k in arguments[i])
        target[k] = arguments[i][k];
    }

    return target;
  }

  /**
   * Function returning the first matching edge for given path.
   * Note: this function does not check the existence of source & target. This
   * must be performed by the caller.
   *
   * @param  {Graph}  graph  - Target graph.
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   * @param  {string} type   - Type of the edge (mixed, directed or undirected).
   * @return {string|null}
   */
  function getMatchingEdge(graph, source, target, type) {
    const sourceData = graph._nodes.get(source);

    let edge = null;

    if (!sourceData)
      return edge;

    if (type === 'mixed') {
      edge = (
        (sourceData.out && sourceData.out[target]) ||
        (sourceData.undirected && sourceData.undirected[target])
      );
    }
    else if (type === 'directed') {
      edge = sourceData.out && sourceData.out[target];
    }
    else {
      edge = sourceData.undirected && sourceData.undirected[target];
    }

    return edge;
  }

  /**
   * Checks whether the given value is a Graph implementation instance.
   *
   * @param  {mixed}   value - Target value.
   * @return {boolean}
   */
  function isGraph(value) {
    return (
      value !== null &&
      typeof value === 'object' &&
      typeof value.addUndirectedEdgeWithKey === 'function' &&
      typeof value.dropNode === 'function'
    );
  }

  /**
   * Checks whether the given value is a plain object.
   *
   * @param  {mixed}   value - Target value.
   * @return {boolean}
   */
  function isPlainObject$1(value) {
    return (
      typeof value === 'object' &&
      value !== null &&
      value.constructor === Object
    );
  }

  /**
   * Pretty prints the given integer.
   *
   * @param  {number}  integer - Target integer.
   * @return {string}          - The pretty string.
   */
  function prettyPrint(integer) {
    const string = '' + integer;

    let prettyString = '';

    for (let i = 0, l = string.length; i < l; i++) {
      const j = l - i - 1;

      prettyString = string[j] + prettyString;

      if (!((i - 2) % 3) && i !== l - 1)
        prettyString = ',' + prettyString;
    }

    return prettyString;
  }

  /**
   * Creates a "private" property for the given member name by concealing it
   * using the `enumerable` option.
   *
   * @param {object} target - Target object.
   * @param {string} name   - Member name.
   */
  function privateProperty(target, name, value) {
    Object.defineProperty(target, name, {
      enumerable: false,
      configurable: false,
      writable: true,
      value
    });
  }


  /**
   * Creates a read-only property for the given member name & the given getter.
   *
   * @param {object}   target - Target object.
   * @param {string}   name   - Member name.
   * @param {mixed}    value  - The attached getter or fixed value.
   */
  function readOnlyProperty(target, name, value) {
    const descriptor = {
      enumerable: true,
      configurable: true
    };

    if (typeof value === 'function') {
      descriptor.get = value;
    }
    else {
      descriptor.value = value;
      descriptor.writable = false;
    }

    Object.defineProperty(target, name, descriptor);
  }

  /**
   * Creates a function generating incremental ids for edges.
   *
   * @return {function}
   */
  function incrementalId() {
    let i = 0;

    return () => {
      return `_geid${i++}_`;
    };
  }

  /**
   * Graphology Custom Errors
   * =========================
   *
   * Defining custom errors for ease of use & easy unit tests across
   * implementations (normalized typology rather than relying on error
   * messages to check whether the correct error was found).
   */
  class GraphError extends Error {
    constructor(message, data) {
      super();
      this.name = 'GraphError';
      this.message = message || '';
      this.data = data || {};
    }
  }

  class InvalidArgumentsGraphError extends GraphError {
    constructor(message, data) {
      super(message, data);
      this.name = 'InvalidArgumentsGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function')
        Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);
    }
  }

  class NotFoundGraphError extends GraphError {
    constructor(message, data) {
      super(message, data);
      this.name = 'NotFoundGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function')
        Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
    }
  }

  class UsageGraphError extends GraphError {
    constructor(message, data) {
      super(message, data);
      this.name = 'UsageGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function')
        Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
    }
  }

  /**
   * Graphology Internal Data Classes
   * =================================
   *
   * Internal classes hopefully reduced to structs by engines & storing
   * necessary information for nodes & edges.
   *
   * Note that those classes don't rely on the `class` keyword to avoid some
   * cruft introduced by most of ES2015 transpilers.
   */

  /**
   * MixedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function MixedNodeData(key, attributes) {

    // Attributes
    this.key = key;
    this.attributes = attributes;

    // Degrees
    this.inDegree = 0;
    this.outDegree = 0;
    this.undirectedDegree = 0;
    this.directedSelfLoops = 0;
    this.undirectedSelfLoops = 0;

    // Indices
    this.in = {};
    this.out = {};
    this.undirected = {};
  }

  /**
   * DirectedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function DirectedNodeData(key, attributes) {

    // Attributes
    this.key = key;
    this.attributes = attributes || {};

    // Degrees
    this.inDegree = 0;
    this.outDegree = 0;
    this.directedSelfLoops = 0;

    // Indices
    this.in = {};
    this.out = {};
  }

  DirectedNodeData.prototype.upgradeToMixed = function() {

    // Degrees
    this.undirectedDegree = 0;
    this.undirectedSelfLoops = 0;

    // Indices
    this.undirected = {};
  };


  /**
   * UndirectedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function UndirectedNodeData(key, attributes) {

    // Attributes
    this.key = key;
    this.attributes = attributes || {};

    // Degrees
    this.undirectedDegree = 0;
    this.undirectedSelfLoops = 0;

    // Indices
    this.undirected = {};
  }

  UndirectedNodeData.prototype.upgradeToMixed = function() {

    // Degrees
    this.inDegree = 0;
    this.outDegree = 0;
    this.directedSelfLoops = 0;

    // Indices
    this.in = {};
    this.out = {};
  };

  /**
   * DirectedEdgeData class.
   *
   * @constructor
   * @param {string}  string       - The edge's key.
   * @param {boolean} generatedKey - Was its key generated?
   * @param {string}  source       - Source of the edge.
   * @param {string}  target       - Target of the edge.
   * @param {object}  attributes   - Edge's attributes.
   */
  function DirectedEdgeData(key, generatedKey, source, target, attributes) {

    // Attributes
    this.key = key;
    this.attributes = attributes;

    // Extremities
    this.source = source;
    this.target = target;

    // Was its key generated?
    this.generatedKey = generatedKey;
  }

  /**
   * UndirectedEdgeData class.
   *
   * @constructor
   * @param {string}  string       - The edge's key.
   * @param {boolean} generatedKey - Was its key generated?
   * @param {string}  source       - Source of the edge.
   * @param {string}  target       - Target of the edge.
   * @param {object}  attributes   - Edge's attributes.
   */
  function UndirectedEdgeData(key, generatedKey, source, target, attributes) {

    // Attributes
    this.key = key;
    this.attributes = attributes;

    // Extremities
    this.source = source;
    this.target = target;

    // Was its key generated?
    this.generatedKey = generatedKey;
  }

  /**
   * Graphology Indexes Functions
   * =============================
   *
   * Bunch of functions used to compute or clear indexes.
   */

  /**
   * Function updating the 'structure' index with the given edge's data.
   * Note that in the case of the multi graph, related edges are stored in a
   * set that is the same for A -> B & B <- A.
   *
   * @param {Graph}    graph      - Target Graph instance.
   * @param {EdgeData} edgeData   - Added edge's data.
   * @param {NodeData} sourceData - Source node's data.
   * @param {NodeData} targetData - Target node's data.
   */
  function updateStructureIndex(
    graph,
    undirected,
    edgeData,
    source,
    target,
    sourceData,
    targetData
  ) {
    const multi = graph.multi;

    const outKey = undirected ? 'undirected' : 'out',
          inKey = undirected ? 'undirected' : 'in';

    // Handling source
    let edgeOrSet = sourceData[outKey][target];

    if (typeof edgeOrSet === 'undefined') {
      edgeOrSet = multi ? new Set() : edgeData;
      sourceData[outKey][target] = edgeOrSet;
    }

    if (multi)
      edgeOrSet.add(edgeData);

    // If selfLoop, we break here
    if (source === target)
      return;

    // Handling target (we won't add the edge because it was already taken
    // care of with source above)
    if (typeof targetData[inKey][source] === 'undefined')
      targetData[inKey][source] = edgeOrSet;
  }

  /**
   * Function clearing the 'structure' index data related to the given edge.
   *
   * @param {Graph}    graph    - Target Graph instance.
   * @param {EdgeData} edgeData - Dropped edge's data.
   */
  function clearEdgeFromStructureIndex(graph, undirected, edgeData) {
    const multi = graph.multi;

    const {source: sourceData, target: targetData} = edgeData;

    const source = sourceData.key,
          target = targetData.key;

    // NOTE: since the edge set is the same for source & target, we can only
    // affect source
    const outKey = undirected ? 'undirected' : 'out',
          sourceIndex = sourceData[outKey];

    const inKey = undirected ? 'undirected' : 'in';

    if (target in sourceIndex) {

      if (multi) {
        const set = sourceIndex[target];

        if (set.size === 1) {
          delete sourceIndex[target];
          delete targetData[inKey][source];
        }
        else {
          set.delete(edgeData);
        }
      }
      else
        delete sourceIndex[target];
    }

    if (multi)
      return;

    const targetIndex = targetData[inKey];

    delete targetIndex[source];
  }

  /**
   * Function clearing the whole 'structure' index.
   *
   * @param {Graph} graph - Target Graph instance.
   */
  function clearStructureIndex(graph) {
    graph._nodes.forEach(data => {

      // Clearing now useless properties
      if (typeof data.in !== 'undefined') {
        data.in = {};
        data.out = {};
      }

      if (typeof data.undirected !== 'undefined') {
        data.undirected = {};
      }
    });
  }

  /**
   * Function used to upgrade a simple `structure` index to a multi on.
   *
   * @param {Graph}  graph - Target Graph instance.
   */
  function upgradeStructureIndexToMulti(graph) {
    graph._nodes.forEach((data, node) => {

      // Directed
      if (data.out) {

        for (const neighbor in data.out) {
          const edges = new Set();
          edges.add(data.out[neighbor]);
          data.out[neighbor] = edges;
          graph._nodes.get(neighbor).in[node] = edges;
        }
      }

      // Undirected
      if (data.undirected) {
        for (const neighbor in data.undirected) {
          if (neighbor > node)
            continue;

          const edges = new Set();
          edges.add(data.undirected[neighbor]);
          data.undirected[neighbor] = edges;
          graph._nodes.get(neighbor).undirected[node] = edges;
        }
      }
    });
  }

  /**
   * Graphology Attributes methods
   * ==============================
   *
   * Attributes-related methods being exactly the same for nodes & edges,
   * we abstract them here for factorization reasons.
   */

  /**
   * Attach an attribute getter method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributeGetter(Class, method, type, EdgeDataClass) {

    /**
     * Get the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {mixed}          - The attribute's value.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, name) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 2) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + name;

        name = arguments[2];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      return data.attributes[name];
    };
  }

  /**
   * Attach an attributes getter method onto the provided class.
   *
   * @param {function} Class       - Target class.
   * @param {string}   method      - Method name.
   * @param {string}   type        - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributesGetter(Class, method, type, EdgeDataClass) {

    /**
     * Retrieves all the target element's attributes.
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     *
     * @return {object}          - The element's attributes.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 1) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + arguments[1];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      return data.attributes;
    };
  }

  /**
   * Attach an attribute checker method onto the provided class.
   *
   * @param {function} Class       - Target class.
   * @param {string}   method      - Method name.
   * @param {string}   type        - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributeChecker(Class, method, type, EdgeDataClass) {

    /**
     * Checks whether the desired attribute is set for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, name) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 2) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + name;

        name = arguments[2];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      return data.attributes.hasOwnProperty(name);
    };
  }

  /**
   * Attach an attribute setter method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributeSetter(Class, method, type, EdgeDataClass) {

    /**
     * Set the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     * @param  {mixed}  value   - New attribute value.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     * @param  {mixed}  value   - New attribute value.
     *
     * @return {Graph}          - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, name, value) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 3) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + name;

        name = arguments[2];
        value = arguments[3];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      data.attributes[name] = value;

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'set',
        meta: {
          name,
          value
        }
      });

      return this;
    };
  }

  /**
   * Attach an attribute updater method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributeUpdater(Class, method, type, EdgeDataClass) {

    /**
     * Update the desired attribute for the given element (node or edge) using
     * the provided function.
     *
     * Arity 2:
     * @param  {any}      element - Target element.
     * @param  {string}   name    - Attribute's name.
     * @param  {function} updater - Updater function.
     *
     * Arity 3 (only for edges):
     * @param  {any}      source  - Source element.
     * @param  {any}      target  - Target element.
     * @param  {string}   name    - Attribute's name.
     * @param  {function} updater - Updater function.
     *
     * @return {Graph}            - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, name, updater) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 3) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + name;

        name = arguments[2];
        updater = arguments[3];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (typeof updater !== 'function')
        throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      data.attributes[name] = updater(data.attributes[name]);

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'set',
        meta: {
          name,
          value: data.attributes[name]
        }
      });

      return this;
    };
  }

  /**
   * Attach an attribute remover method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributeRemover(Class, method, type, EdgeDataClass) {

    /**
     * Remove the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {Graph}          - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, name) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 2) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + name;

        name = arguments[2];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      delete data.attributes[name];

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'remove',
        meta: {
          name
        }
      });

      return this;
    };
  }

  /**
   * Attach an attribute replacer method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributesReplacer(Class, method, type, EdgeDataClass) {

    /**
     * Replace the attributes for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element    - Target element.
     * @param  {object} attributes - New attributes.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source     - Source element.
     * @param  {any}     target     - Target element.
     * @param  {object}  attributes - New attributes.
     *
     * @return {Graph}              - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, attributes) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 2) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + attributes;

        attributes = arguments[2];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      const oldAttributes = data.attributes;

      data.attributes = attributes;

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'replace',
        meta: {
          before: oldAttributes,
          after: attributes
        }
      });

      return this;
    };
  }

  /**
   * Attach an attribute merger method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   * @param {Class}    EdgeDataClass - Class of the edges to filter.
   */
  function attachAttributesMerger(Class, method, type, EdgeDataClass) {

    /**
     * Replace the attributes for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element    - Target element.
     * @param  {object} attributes - Attributes to merge.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source     - Source element.
     * @param  {any}     target     - Target element.
     * @param  {object}  attributes - Attributes to merge.
     *
     * @return {Graph}              - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function(element, attributes) {
      let data;

      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
        throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);

      if (arguments.length > 2) {

        if (this.multi)
          throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);

        const source = '' + element,
              target = '' + attributes;

        attributes = arguments[2];

        data = getMatchingEdge(this, source, target, type);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
      }
      else {
        element = '' + element;
        data = this._edges.get(element);

        if (!data)
          throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
      }

      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);

      if (type !== 'mixed' && !(data instanceof EdgeDataClass))
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);

      assign(data.attributes, attributes);

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'merge',
        meta: {
          data: attributes
        }
      });

      return this;
    };
  }

  /**
   * List of methods to attach.
   */
  const ATTRIBUTES_METHODS = [
    {
      name: element => `get${element}Attribute`,
      attacher: attachAttributeGetter
    },
    {
      name: element => `get${element}Attributes`,
      attacher: attachAttributesGetter
    },
    {
      name: element => `has${element}Attribute`,
      attacher: attachAttributeChecker
    },
    {
      name: element => `set${element}Attribute`,
      attacher: attachAttributeSetter
    },
    {
      name: element => `update${element}Attribute`,
      attacher: attachAttributeUpdater
    },
    {
      name: element => `remove${element}Attribute`,
      attacher: attachAttributeRemover
    },
    {
      name: element => `replace${element}Attributes`,
      attacher: attachAttributesReplacer
    },
    {
      name: element => `merge${element}Attributes`,
      attacher: attachAttributesMerger
    }
  ];

  /**
   * Attach every attributes-related methods to a Graph class.
   *
   * @param {function} Graph - Target class.
   */
  function attachAttributesMethods(Graph) {
    ATTRIBUTES_METHODS.forEach(function({name, attacher}) {

      // For edges
      attacher(
        Graph,
        name('Edge'),
        'mixed',
        DirectedEdgeData
      );

      // For directed edges
      attacher(
        Graph,
        name('DirectedEdge'),
        'directed',
        DirectedEdgeData
      );

      // For undirected edges
      attacher(
        Graph,
        name('UndirectedEdge'),
        'undirected',
        UndirectedEdgeData
      );
    });
  }

  /**
   * Graphology Edge Iteration
   * ==========================
   *
   * Attaching some methods to the Graph class to be able to iterate over a
   * graph's edges.
   */

  /**
   * Definitions.
   */
  const EDGES_ITERATION = [
    {
      name: 'edges',
      type: 'mixed'
    },
    {
      name: 'inEdges',
      type: 'directed',
      direction: 'in'
    },
    {
      name: 'outEdges',
      type: 'directed',
      direction: 'out'
    },
    {
      name: 'inboundEdges',
      type: 'mixed',
      direction: 'in'
    },
    {
      name: 'outboundEdges',
      type: 'mixed',
      direction: 'out'
    },
    {
      name: 'directedEdges',
      type: 'directed'
    },
    {
      name: 'undirectedEdges',
      type: 'undirected'
    }
  ];

  /**
   * Function collecting edges from the given object.
   *
   * @param  {array}  edges  - Edges array to populate.
   * @param  {object} object - Target object.
   * @return {array}         - The found edges.
   */
  function collect(edges, object) {
    for (const k in object) {
      if (object[k] instanceof Set)
        object[k].forEach(edgeData => edges.push(edgeData.key));
      else
        edges.push(object[k].key);
    }
  }

  /**
   * Function iterating over edges from the given object using a callback.
   *
   * @param {object}   object   - Target object.
   * @param {function} callback - Function to call.
   */
  function forEachSimple(object, callback) {
    for (const k in object) {
      const edgeData = object[k];

      callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes
      );
    }
  }

  function forEachMulti(object, callback) {
    for (const k in object) {
      object[k].forEach(edgeData => callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes
      ));
    }
  }

  /**
   * Function returning an iterator over edges from the given object.
   *
   * @param  {object}   object - Target object.
   * @return {Iterator}
   */
  function createIterator(object) {
    const keys = Object.keys(object),
          l = keys.length;

    let inner = null,
        i = 0;

    return new iterator(function next() {
      let edgeData;

      if (inner) {
        const step = inner.next();

        if (step.done) {
          inner = null;
          i++;
          return next();
        }

        edgeData = step.value;
      }
      else {
        if (i >= l)
          return {done: true};

        const k = keys[i];

        edgeData = object[k];

        if (edgeData instanceof Set) {
          inner = edgeData.values();
          return next();
        }

        i++;
      }

      return {
        done: false,
        value: [
          edgeData.key,
          edgeData.attributes,
          edgeData.source.key,
          edgeData.target.key,
          edgeData.source.attributes,
          edgeData.target.attributes
        ]
      };
    });
  }

  /**
   * Function collecting edges from the given object at given key.
   *
   * @param  {array}  edges  - Edges array to populate.
   * @param  {object} object - Target object.
   * @param  {mixed}  k      - Neighbor key.
   * @return {array}         - The found edges.
   */
  function collectForKey(edges, object, k) {

    if (!(k in object))
      return;

    if (object[k] instanceof Set)
      object[k].forEach(edgeData => edges.push(edgeData.key));
    else
      edges.push(object[k].key);

    return;
  }

  /**
   * Function iterating over the egdes from the object at given key using
   * a callback.
   *
   * @param {object}   object   - Target object.
   * @param {mixed}    k        - Neighbor key.
   * @param {function} callback - Callback to use.
   */
  function forEachForKey(object, k, callback) {

    if (!(k in object))
      return;

    if (object[k] instanceof Set)
      object[k].forEach(edgeData => callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes
      ));
    else {
      const edgeData = object[k];

      callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes
      );
    }

    return;
  }

  /**
   * Function returning an iterator over the egdes from the object at given key.
   *
   * @param  {object}   object   - Target object.
   * @param  {mixed}    k        - Neighbor key.
   * @return {Iterator}
   */
  function createIteratorForKey(object, k) {
    const v = object[k];

    if (v instanceof Set) {
      const iterator$1 = v.values();

      return new iterator(function() {
        const step = iterator$1.next();

        if (step.done)
          return step;

        const edgeData = step.value;

        return {
          done: false,
          value: [
            edgeData.key,
            edgeData.attributes,
            edgeData.source.key,
            edgeData.target.key,
            edgeData.source.attributes,
            edgeData.target.attributes
          ]
        };
      });
    }

    return iterator.of([
      v.key,
      v.attributes,
      v.source.key,
      v.target.key,
      v.source.attributes,
      v.target.attributes
    ]);
  }

  /**
   * Function creating an array of edges for the given type.
   *
   * @param  {Graph}   graph - Target Graph instance.
   * @param  {string}  type  - Type of edges to retrieve.
   * @return {array}         - Array of edges.
   */
  function createEdgeArray(graph, type) {
    if (graph.size === 0)
      return [];

    if (type === 'mixed' || type === graph.type)
      return take(graph._edges.keys(), graph._edges.size);

    const size = type === 'undirected' ?
      graph.undirectedSize :
      graph.directedSize;

    const list = new Array(size),
          mask = type === 'undirected';

    let i = 0;

    graph._edges.forEach((data, edge) => {

      if ((data instanceof UndirectedEdgeData) === mask)
        list[i++] = edge;
    });

    return list;
  }

  /**
   * Function iterating over a graph's edges using a callback.
   *
   * @param  {Graph}    graph    - Target Graph instance.
   * @param  {string}   type     - Type of edges to retrieve.
   * @param  {function} callback - Function to call.
   */
  function forEachEdge(graph, type, callback) {
    if (graph.size === 0)
      return;

    if (type === 'mixed' || type === graph.type) {
      graph._edges.forEach((data, key) => {

        const {attributes, source, target} = data;

        callback(
          key,
          attributes,
          source.key,
          target.key,
          source.attributes,
          target.attributes
        );
      });
    }
    else {
      const mask = type === 'undirected';

      graph._edges.forEach((data, key) => {
        if ((data instanceof UndirectedEdgeData) === mask) {

          const {attributes, source, target} = data;

          callback(
            key,
            attributes,
            source.key,
            target.key,
            source.attributes,
            target.attributes
          );
        }
      });
    }
  }

  /**
   * Function creating an iterator of edges for the given type.
   *
   * @param  {Graph}    graph - Target Graph instance.
   * @param  {string}   type  - Type of edges to retrieve.
   * @return {Iterator}
   */
  function createEdgeIterator(graph, type) {
    if (graph.size === 0)
      return iterator.empty();

    let iterator$1;

    if (type === 'mixed') {
      iterator$1 = graph._edges.values();

      return new iterator(function next() {
        const step = iterator$1.next();

        if (step.done)
          return step;

        const data = step.value;

        const value = [
          data.key,
          data.attributes,
          data.source.key,
          data.target.key,
          data.source.attributes,
          data.target.attributes
        ];

        return {value, done: false};
      });
    }

    iterator$1 = graph._edges.values();

    return new iterator(function next() {
      const step = iterator$1.next();

      if (step.done)
        return step;

      const data = step.value;

      if ((data instanceof UndirectedEdgeData) === (type === 'undirected')) {
        const value = [
          data.key,
          data.attributes,
          data.source.key,
          data.target.key,
          data.source.attributes,
          data.target.attributes
        ];

        return {value, done: false};
      }

      return next();
    });
  }

  /**
   * Function creating an array of edges for the given type & the given node.
   *
   * @param  {string}  type      - Type of edges to retrieve.
   * @param  {string}  direction - In or out?
   * @param  {any}     nodeData  - Target node's data.
   * @return {array}             - Array of edges.
   */
  function createEdgeArrayForNode(type, direction, nodeData) {
    const edges = [];

    if (type !== 'undirected') {
      if (direction !== 'out')
        collect(edges, nodeData.in);
      if (direction !== 'in')
        collect(edges, nodeData.out);
    }

    if (type !== 'directed') {
      collect(edges, nodeData.undirected);
    }

    return edges;
  }

  /**
   * Function iterating over a node's edges using a callback.
   *
   * @param  {boolean}  multi     - Whether the graph is multi or not.
   * @param  {string}   type      - Type of edges to retrieve.
   * @param  {string}   direction - In or out?
   * @param  {any}      nodeData  - Target node's data.
   * @param  {function} callback  - Function to call.
   */
  function forEachEdgeForNode(multi, type, direction, nodeData, callback) {
    const fn = multi ? forEachMulti : forEachSimple;

    if (type !== 'undirected') {
      if (direction !== 'out')
        fn(nodeData.in, callback);
      if (direction !== 'in')
        fn(nodeData.out, callback);
    }

    if (type !== 'directed') {
      fn(nodeData.undirected, callback);
    }
  }

  /**
   * Function iterating over a node's edges using a callback.
   *
   * @param  {string}   type      - Type of edges to retrieve.
   * @param  {string}   direction - In or out?
   * @param  {any}      nodeData  - Target node's data.
   * @return {Iterator}
   */
  function createEdgeIteratorForNode(type, direction, nodeData) {
    let iterator$1 = iterator.empty();

    if (type !== 'undirected') {
      if (direction !== 'out' && typeof nodeData.in !== 'undefined')
        iterator$1 = chain(iterator$1, createIterator(nodeData.in));
      if (direction !== 'in' && typeof nodeData.out !== 'undefined')
        iterator$1 = chain(iterator$1, createIterator(nodeData.out));
    }

    if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
      iterator$1 = chain(iterator$1, createIterator(nodeData.undirected));
    }

    return iterator$1;
  }

  /**
   * Function creating an array of edges for the given path.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {any}      target     - Target node.
   * @return {array}               - Array of edges.
   */
  function createEdgeArrayForPath(type, direction, sourceData, target) {
    const edges = [];

    if (type !== 'undirected') {

      if (typeof sourceData.in !== 'undefined' && direction !== 'out')
        collectForKey(edges, sourceData.in, target);

      if (typeof sourceData.out !== 'undefined' && direction !== 'in')
        collectForKey(edges, sourceData.out, target);
    }

    if (type !== 'directed') {
      if (typeof sourceData.undirected !== 'undefined')
        collectForKey(edges, sourceData.undirected, target);
    }

    return edges;
  }

  /**
   * Function iterating over edges for the given path using a callback.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {string}   target     - Target node.
   * @param  {function} callback   - Function to call.
   */
  function forEachEdgeForPath(type, direction, sourceData, target, callback) {
    if (type !== 'undirected') {

      if (typeof sourceData.in !== 'undefined' && direction !== 'out')
        forEachForKey(sourceData.in, target, callback);

      if (typeof sourceData.out !== 'undefined' && direction !== 'in')
        forEachForKey(sourceData.out, target, callback);
    }

    if (type !== 'directed') {
      if (typeof sourceData.undirected !== 'undefined')
        forEachForKey(sourceData.undirected, target, callback);
    }
  }

  /**
   * Function returning an iterator over edges for the given path.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {string}   target     - Target node.
   * @param  {function} callback   - Function to call.
   */
  function createEdgeIteratorForPath(type, direction, sourceData, target) {
    let iterator$1 = iterator.empty();

    if (type !== 'undirected') {

      if (
        typeof sourceData.in !== 'undefined' &&
        direction !== 'out' &&
        target in sourceData.in
      )
        iterator$1 = chain(iterator$1, createIteratorForKey(sourceData.in, target));

      if (
        typeof sourceData.out !== 'undefined' &&
        direction !== 'in' &&
        target in sourceData.out
      )
        iterator$1 = chain(iterator$1, createIteratorForKey(sourceData.out, target));
    }

    if (type !== 'directed') {
      if (
        typeof sourceData.undirected !== 'undefined' &&
        target in sourceData.undirected
      )
        iterator$1 = chain(iterator$1, createIteratorForKey(sourceData.undirected, target));
    }

    return iterator$1;
  }

  /**
   * Function attaching an edge array creator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachEdgeArrayCreator(Class, description) {
    const {
      name,
      type,
      direction
    } = description;

    /**
     * Function returning an array of certain edges.
     *
     * Arity 0: Return all the relevant edges.
     *
     * Arity 1: Return all of a node's relevant edges.
     * @param  {any}   node   - Target node.
     *
     * Arity 2: Return the relevant edges across the given path.
     * @param  {any}   source - Source node.
     * @param  {any}   target - Target node.
     *
     * @return {array|number} - The edges or the number of edges.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[name] = function(source, target) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return [];

      if (!arguments.length)
        return createEdgeArray(this, type);

      if (arguments.length === 1) {
        source = '' + source;

        const nodeData = this._nodes.get(source);

        if (typeof nodeData === 'undefined')
          throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);

        // Iterating over a node's edges
        return createEdgeArrayForNode(
          type === 'mixed' ? this.type : type,
          direction,
          nodeData
        );
      }

      if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;

        const sourceData = this._nodes.get(source);

        if (!sourceData)
          throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);

        if (!this._nodes.has(target))
          throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);

        // Iterating over the edges between source & target
        return createEdgeArrayForPath(type, direction, sourceData, target);
      }

      throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
    };
  }

  /**
   * Function attaching a edge callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachForEachEdge(Class, description) {
    const {
      name,
      type,
      direction
    } = description;

    const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

    /**
     * Function iterating over the graph's relevant edges by applying the given
     * callback.
     *
     * Arity 1: Iterate over all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Iterate over all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Iterate over the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[forEachName] = function(source, target, callback) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return;

      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(this, type, callback);
      }

      if (arguments.length === 2) {
        source = '' + source;
        callback = target;

        const nodeData = this._nodes.get(source);

        if (typeof nodeData === 'undefined')
          throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${source}" node in the graph.`);

        // Iterating over a node's edges
        // TODO: maybe attach the sub method to the instance dynamically?
        return forEachEdgeForNode(
          this.multi,
          type === 'mixed' ? this.type : type,
          direction,
          nodeData,
          callback
        );
      }

      if (arguments.length === 3) {
        source = '' + source;
        target = '' + target;

        const sourceData = this._nodes.get(source);

        if (!sourceData)
          throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${source}" source node in the graph.`);

        if (!this._nodes.has(target))
          throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${target}" target node in the graph.`);

        // Iterating over the edges between source & target
        return forEachEdgeForPath(type, direction, sourceData, target, callback);
      }

      throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);
    };
  }

  /**
   * Function attaching an edge iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachEdgeIteratorCreator(Class, description) {
    const {
      name: originalName,
      type,
      direction
    } = description;

    const name = originalName.slice(0, -1) + 'Entries';

    /**
     * Function returning an iterator over the graph's edges.
     *
     * Arity 0: Iterate over all the relevant edges.
     *
     * Arity 1: Iterate over all of a node's relevant edges.
     * @param  {any}   node   - Target node.
     *
     * Arity 2: Iterate over the relevant edges across the given path.
     * @param  {any}   source - Source node.
     * @param  {any}   target - Target node.
     *
     * @return {array|number} - The edges or the number of edges.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[name] = function(source, target) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return iterator.empty();

      if (!arguments.length)
        return createEdgeIterator(this, type);

      if (arguments.length === 1) {
        source = '' + source;

        const sourceData = this._nodes.get(source);

        if (!sourceData)
          throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);

        // Iterating over a node's edges
        return createEdgeIteratorForNode(type, direction, sourceData);
      }

      if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;

        const sourceData = this._nodes.get(source);

        if (!sourceData)
          throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);

        if (!this._nodes.has(target))
          throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);

        // Iterating over the edges between source & target
        return createEdgeIteratorForPath(type, direction, sourceData, target);
      }

      throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
    };
  }

  /**
   * Function attaching every edge iteration method to the Graph class.
   *
   * @param {function} Graph - Graph class.
   */
  function attachEdgeIterationMethods(Graph) {
    EDGES_ITERATION.forEach(description => {
      attachEdgeArrayCreator(Graph, description);
      attachForEachEdge(Graph, description);
      attachEdgeIteratorCreator(Graph, description);
    });
  }

  /**
   * Graphology Neighbor Iteration
   * ==============================
   *
   * Attaching some methods to the Graph class to be able to iterate over
   * neighbors.
   */

  /**
   * Definitions.
   */
  const NEIGHBORS_ITERATION = [
    {
      name: 'neighbors',
      type: 'mixed'
    },
    {
      name: 'inNeighbors',
      type: 'directed',
      direction: 'in'
    },
    {
      name: 'outNeighbors',
      type: 'directed',
      direction: 'out'
    },
    {
      name: 'inboundNeighbors',
      type: 'mixed',
      direction: 'in'
    },
    {
      name: 'outboundNeighbors',
      type: 'mixed',
      direction: 'out'
    },
    {
      name: 'directedNeighbors',
      type: 'directed'
    },
    {
      name: 'undirectedNeighbors',
      type: 'undirected'
    }
  ];

  /**
   * Function merging neighbors into the given set iterating over the given object.
   *
   * @param {BasicSet} neighbors - Neighbors set.
   * @param {object}   object    - Target object.
   */
  function merge(neighbors, object) {
    if (typeof object === 'undefined')
      return;

    for (const neighbor in object)
      neighbors.add(neighbor);
  }

  /**
   * Function creating an array of relevant neighbors for the given node.
   *
   * @param  {string}       type      - Type of neighbors.
   * @param  {string}       direction - Direction.
   * @param  {any}          nodeData  - Target node's data.
   * @return {Array}                  - The list of neighbors.
   */
  function createNeighborArrayForNode(type, direction, nodeData) {

    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected')
        return Object.keys(nodeData.undirected);

      if (typeof direction === 'string')
        return Object.keys(nodeData[direction]);
    }

    // Else we need to keep a set of neighbors not to return duplicates
    const neighbors = new Set();

    if (type !== 'undirected') {

      if (direction !== 'out') {
        merge(neighbors, nodeData.in);
      }
      if (direction !== 'in') {
        merge(neighbors, nodeData.out);
      }
    }

    if (type !== 'directed') {
      merge(neighbors, nodeData.undirected);
    }

    return take(neighbors.values(), neighbors.size);
  }

  /**
   * Function iterating over the given node's relevant neighbors using a
   * callback.
   *
   * @param  {string}   type      - Type of neighbors.
   * @param  {string}   direction - Direction.
   * @param  {any}      nodeData  - Target node's data.
   * @param  {function} callback  - Callback to use.
   */
  function forEachInObject(nodeData, object, callback) {
    for (const k in object) {
      let edgeData = object[k];

      if (edgeData instanceof Set)
        edgeData = edgeData.values().next().value;

      const sourceData = edgeData.source,
            targetData = edgeData.target;

      const neighborData = sourceData === nodeData ? targetData : sourceData;

      callback(
        neighborData.key,
        neighborData.attributes
      );
    }
  }

  function forEachInObjectOnce(visited, nodeData, object, callback) {
    for (const k in object) {
      let edgeData = object[k];

      if (edgeData instanceof Set)
        edgeData = edgeData.values().next().value;

      const sourceData = edgeData.source,
            targetData = edgeData.target;

      const neighborData = sourceData === nodeData ? targetData : sourceData;

      if (visited.has(neighborData.key))
        continue;

      visited.add(neighborData.key);

      callback(
        neighborData.key,
        neighborData.attributes
      );
    }
  }

  function forEachNeighborForNode(type, direction, nodeData, callback) {

    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected')
        return forEachInObject(nodeData, nodeData.undirected, callback);

      if (typeof direction === 'string')
        return forEachInObject(nodeData, nodeData[direction], callback);
    }

    // Else we need to keep a set of neighbors not to return duplicates
    const visited = new Set();

    if (type !== 'undirected') {

      if (direction !== 'out') {
        forEachInObjectOnce(visited, nodeData, nodeData.in, callback);
      }
      if (direction !== 'in') {
        forEachInObjectOnce(visited, nodeData, nodeData.out, callback);
      }
    }

    if (type !== 'directed') {
      forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);
    }
  }

  /**
   * Function returning an iterator over the given node's relevant neighbors.
   *
   * @param  {string}   type      - Type of neighbors.
   * @param  {string}   direction - Direction.
   * @param  {any}      nodeData  - Target node's data.
   * @return {Iterator}
   */
  function createObjectIterator(nodeData, object) {
    const keys = Object.keys(object),
          l = keys.length;

    let i = 0;

    return new iterator(function() {
      if (i >= l)
        return {done: true};

      let edgeData = object[keys[i++]];

      if (edgeData instanceof Set)
        edgeData = edgeData.values().next().value;

      const sourceData = edgeData.source,
            targetData = edgeData.target;

      const neighborData = sourceData === nodeData ? targetData : sourceData;

      return {
        done: false,
        value: [neighborData.key, neighborData.attributes]
      };
    });
  }

  function createDedupedObjectIterator(visited, nodeData, object) {
    const keys = Object.keys(object),
          l = keys.length;

    let i = 0;

    return new iterator(function next() {
      if (i >= l)
        return {done: true};

      let edgeData = object[keys[i++]];

      if (edgeData instanceof Set)
        edgeData = edgeData.values().next().value;

      const sourceData = edgeData.source,
            targetData = edgeData.target;

      const neighborData = sourceData === nodeData ? targetData : sourceData;

      if (visited.has(neighborData.key))
        return next();

      visited.add(neighborData.key);

      return {
        done: false,
        value: [neighborData.key, neighborData.attributes]
      };
    });
  }

  function createNeighborIterator(type, direction, nodeData) {

    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected')
        return createObjectIterator(nodeData, nodeData.undirected);

      if (typeof direction === 'string')
        return createObjectIterator(nodeData, nodeData[direction]);
    }

    let iterator$1 = iterator.empty();

    // Else we need to keep a set of neighbors not to return duplicates
    const visited = new Set();

    if (type !== 'undirected') {

      if (direction !== 'out') {
        iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData.in));
      }
      if (direction !== 'in') {
        iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData.out));
      }
    }

    if (type !== 'directed') {
      iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));
    }

    return iterator$1;
  }

  /**
   * Function returning whether the given node has target neighbor.
   *
   * @param  {Graph}        graph     - Target graph.
   * @param  {string}       type      - Type of neighbor.
   * @param  {string}       direction - Direction.
   * @param  {any}          node      - Target node.
   * @param  {any}          neighbor  - Target neighbor.
   * @return {boolean}
   */
  function nodeHasNeighbor(graph, type, direction, node, neighbor) {

    const nodeData = graph._nodes.get(node);

    if (type !== 'undirected') {

      if (direction !== 'out' && typeof nodeData.in !== 'undefined') {
        for (const k in nodeData.in)
          if (k === neighbor)
            return true;
      }
      if (direction !== 'in' && typeof nodeData.out !== 'undefined') {
        for (const k in nodeData.out)
          if (k === neighbor)
            return true;
      }
    }

    if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
      for (const k in nodeData.undirected)
          if (k === neighbor)
            return true;
    }

    return false;
  }

  /**
   * Function attaching a neighbors array creator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachNeighborArrayCreator(Class, description) {
    const {
      name,
      type,
      direction
    } = description;

    /**
     * Function returning an array or the count of certain neighbors.
     *
     * Arity 1: Return all of a node's relevant neighbors.
     * @param  {any}   node   - Target node.
     *
     * Arity 2: Return whether the two nodes are indeed neighbors.
     * @param  {any}   source - Source node.
     * @param  {any}   target - Target node.
     *
     * @return {array|number} - The neighbors or the number of neighbors.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[name] = function(node) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return [];

      if (arguments.length === 2) {
        const node1 = '' + arguments[0],
              node2 = '' + arguments[1];

        if (!this._nodes.has(node1))
          throw new NotFoundGraphError(`Graph.${name}: could not find the "${node1}" node in the graph.`);

        if (!this._nodes.has(node2))
          throw new NotFoundGraphError(`Graph.${name}: could not find the "${node2}" node in the graph.`);

        // Here, we want to assess whether the two given nodes are neighbors
        return nodeHasNeighbor(
          this,
          type,
          direction,
          node1,
          node2
        );
      }
      else if (arguments.length === 1) {
        node = '' + node;

        const nodeData = this._nodes.get(node);

        if (typeof nodeData === 'undefined')
          throw new NotFoundGraphError(`Graph.${name}: could not find the "${node}" node in the graph.`);

        // Here, we want to iterate over a node's relevant neighbors
        const neighbors = createNeighborArrayForNode(
          type === 'mixed' ? this.type : type,
          direction,
          nodeData
        );

        return neighbors;
      }

      throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);
    };
  }

  /**
   * Function attaching a neighbors callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachForEachNeighbor(Class, description) {
    const {
      name,
      type,
      direction
    } = description;

    const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

    /**
     * Function iterating over all the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[forEachName] = function(node, callback) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return;

      node = '' + node;

      const nodeData = this._nodes.get(node);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${node}" node in the graph.`);

      // Here, we want to iterate over a node's relevant neighbors
      forEachNeighborForNode(
        type === 'mixed' ? this.type : type,
        direction,
        nodeData,
        callback
      );
    };
  }

  /**
   * Function attaching a neighbors callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachNeighborIteratorCreator(Class, description) {
    const {
      name,
      type,
      direction
    } = description;

    const iteratorName = name.slice(0, -1) + 'Entries';

    /**
     * Function returning an iterator over all the relevant neighbors.
     *
     * @param  {any}      node     - Target node.
     * @return {Iterator}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[iteratorName] = function(node) {

      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
        return iterator.empty();

      node = '' + node;

      const nodeData = this._nodes.get(node);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the "${node}" node in the graph.`);

      // Here, we want to iterate over a node's relevant neighbors
      return createNeighborIterator(
        type === 'mixed' ? this.type : type,
        direction,
        nodeData
      );
    };
  }

  /**
   * Function attaching every neighbor iteration method to the Graph class.
   *
   * @param {function} Graph - Graph class.
   */
  function attachNeighborIterationMethods(Graph) {
    NEIGHBORS_ITERATION.forEach(description => {
      attachNeighborArrayCreator(Graph, description);
      attachForEachNeighbor(Graph, description);
      attachNeighborIteratorCreator(Graph, description);
    });
  }

  /**
   * Graphology Serialization Utilities
   * ===================================
   *
   * Collection of functions used to validate import-export formats & to ouput
   * them from internal graph data.
   *
   * Serialized Node:
   * {key, ?attributes}
   *
   * Serialized Edge:
   * {key?, source, target, attributes?, undirected?}
   *
   * Serialized Graph:
   * {nodes[], edges?[]}
   */

  /**
   * Formats internal node data into a serialized node.
   *
   * @param  {any}    key  - The node's key.
   * @param  {object} data - Internal node's data.
   * @return {array}       - The serialized node.
   */
  function serializeNode(key, data) {
    const serialized = {key};

    if (Object.keys(data.attributes).length)
      serialized.attributes = assign({}, data.attributes);

    return serialized;
  }

  /**
   * Formats internal edge data into a serialized edge.
   *
   * @param  {any}    key  - The edge's key.
   * @param  {object} data - Internal edge's data.
   * @return {array}       - The serialized edge.
   */
  function serializeEdge(key, data) {
    const serialized = {
      source: data.source.key,
      target: data.target.key
    };

    // We export the key unless if it was provided by the user
    if (!data.generatedKey)
      serialized.key = key;

    if (Object.keys(data.attributes).length)
      serialized.attributes = assign({}, data.attributes);

    if (data instanceof UndirectedEdgeData)
      serialized.undirected = true;

    return serialized;
  }

  /**
   * Checks whether the given value is a serialized node.
   *
   * @param  {mixed} value - Target value.
   * @return {string|null}
   */
  function validateSerializedNode(value) {
    if (!isPlainObject$1(value))
      return 'not-object';

    if (!('key' in value))
      return 'no-key';

    if ('attributes' in value &&
        (!isPlainObject$1(value.attributes) || value.attributes === null))
      return 'invalid-attributes';

    return null;
  }

  /**
   * Checks whether the given value is a serialized edge.
   *
   * @param  {mixed} value - Target value.
   * @return {string|null}
   */
  function validateSerializedEdge(value) {
    if (!isPlainObject$1(value))
      return 'not-object';

    if (!('source' in value))
      return 'no-source';

    if (!('target' in value))
      return 'no-target';

    if ('attributes' in value &&
        (!isPlainObject$1(value.attributes) || value.attributes === null))
      return 'invalid-attributes';

    if ('undirected' in value &&
        (typeof value.undirected !== 'boolean'))
      return 'invalid-undirected';

    return null;
  }

  /* eslint no-nested-ternary: 0 */

  /**
   * Enums.
   */
  const TYPES = new Set([
    'directed',
    'undirected',
    'mixed'
  ]);

  const EMITTER_PROPS = new Set([
    'domain',
    '_events',
    '_eventsCount',
    '_maxListeners'
  ]);

  const EDGE_ADD_METHODS = [
    {
      name: verb => `${verb}Edge`,
      generateKey: true
    },
    {
      name: verb => `${verb}DirectedEdge`,
      generateKey: true,
      type: 'directed'
    },
    {
      name: verb => `${verb}UndirectedEdge`,
      generateKey: true,
      type: 'undirected'
    },
    {
      name: verb => `${verb}EdgeWithKey`,
    },
    {
      name: verb => `${verb}DirectedEdgeWithKey`,
      type: 'directed'
    },
    {
      name: verb => `${verb}UndirectedEdgeWithKey`,
      type: 'undirected'
    }
  ];

  /**
   * Default options.
   */
  const DEFAULTS = {
    allowSelfLoops: true,
    edgeKeyGenerator: null,
    multi: false,
    type: 'mixed'
  };

  /**
   * Abstract functions used by the Graph class for various methods.
   */

  /**
   * Internal method used to add an arbitrary edge to the given graph.
   *
   * @param  {Graph}   graph           - Target graph.
   * @param  {string}  name            - Name of the child method for errors.
   * @param  {boolean} mustGenerateKey - Should the graph generate an id?
   * @param  {boolean} undirected      - Whether the edge is undirected.
   * @param  {any}     edge            - The edge's key.
   * @param  {any}     source          - The source node.
   * @param  {any}     target          - The target node.
   * @param  {object}  [attributes]    - Optional attributes.
   * @return {any}                     - The edge.
   *
   * @throws {Error} - Will throw if the graph is of the wrong type.
   * @throws {Error} - Will throw if the given attributes are not an object.
   * @throws {Error} - Will throw if source or target doesn't exist.
   * @throws {Error} - Will throw if the edge already exist.
   */
  function addEdge(
    graph,
    name,
    mustGenerateKey,
    undirected,
    edge,
    source,
    target,
    attributes
  ) {

    // Checking validity of operation
    if (!undirected && graph.type === 'undirected')
      throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);

    if (undirected && graph.type === 'directed')
      throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);

    if (attributes && !isPlainObject$1(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);

    // Coercion of source & target:
    source = '' + source;
    target = '' + target;
    attributes = attributes || {};

    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);

    const sourceData = graph._nodes.get(source),
          targetData = graph._nodes.get(target);

    if (!sourceData)
      throw new NotFoundGraphError(`Graph.${name}: source node "${source}" not found.`);

    if (!targetData)
      throw new NotFoundGraphError(`Graph.${name}: target node "${target}" not found.`);

    // Must the graph generate an id for this edge?
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };

    if (mustGenerateKey)
      edge = graph._edgeKeyGenerator(eventData);

    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);

    // Here, we might have a source / target collision
    if (
      !graph.multi &&
      (
        undirected ?
          typeof sourceData.undirected[target] !== 'undefined' :
          typeof sourceData.out[target] !== 'undefined'
      )
    ) {
      throw new UsageGraphError(`Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);
    }

    // Storing some data
    const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;

    const edgeData = new DataClass(
      edge,
      mustGenerateKey,
      sourceData,
      targetData,
      attributes
    );

    // Adding the edge to the internal register
    graph._edges.set(edge, edgeData);

    // Incrementing node degree counters
    if (source === target) {
      if (undirected)
        sourceData.undirectedSelfLoops++;
      else
        sourceData.directedSelfLoops++;
    }
    else {
      if (undirected) {
        sourceData.undirectedDegree++;
        targetData.undirectedDegree++;
      }
      else {
        sourceData.outDegree++;
        targetData.inDegree++;
      }
    }

    // Updating relevant index
    updateStructureIndex(
      graph,
      undirected,
      edgeData,
      source,
      target,
      sourceData,
      targetData
    );

    if (undirected)
      graph._undirectedSize++;
    else
      graph._directedSize++;

    // Emitting
    eventData.key = edge;

    graph.emit('edgeAdded', eventData);

    return edge;
  }

  /**
   * Internal method used to add an arbitrary edge to the given graph.
   *
   * @param  {Graph}   graph           - Target graph.
   * @param  {string}  name            - Name of the child method for errors.
   * @param  {boolean} mustGenerateKey - Should the graph generate an id?
   * @param  {boolean} undirected      - Whether the edge is undirected.
   * @param  {any}     edge            - The edge's key.
   * @param  {any}     source          - The source node.
   * @param  {any}     target          - The target node.
   * @param  {object}  [attributes]    - Optional attributes.
   * @return {any}                     - The edge.
   *
   * @throws {Error} - Will throw if the graph is of the wrong type.
   * @throws {Error} - Will throw if the given attributes are not an object.
   * @throws {Error} - Will throw if source or target doesn't exist.
   * @throws {Error} - Will throw if the edge already exist.
   */
  function mergeEdge(
    graph,
    name,
    mustGenerateKey,
    undirected,
    edge,
    source,
    target,
    attributes
  ) {

    // Checking validity of operation
    if (!undirected && graph.type === 'undirected')
      throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);

    if (undirected && graph.type === 'directed')
      throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);

    if (attributes && !isPlainObject$1(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);

    // Coercion of source & target:
    source = '' + source;
    target = '' + target;
    attributes = attributes || {};

    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);

    let sourceData = graph._nodes.get(source),
        targetData = graph._nodes.get(target),
        edgeData;

    // Do we need to handle duplicate?
    let alreadyExistingEdge = null;

    if (!mustGenerateKey) {
      edgeData = graph._edges.get(edge);

      if (edgeData) {

        // Here, we need to ensure, if the user gave a key, that source & target
        // are coherent
        if (
          (edgeData.source !== source || edgeData.target !== target) ||
          (undirected && (edgeData.source !== target || edgeData.target !== source))
        ) {
          throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. (${edgeData.source}, ${edgeData.target}).`);
        }

        alreadyExistingEdge = edge;
      }
    }

    let alreadyExistingEdgeData;

    // Here, we might have a source / target collision
    if (
      !alreadyExistingEdge &&
      !graph.multi &&
      sourceData &&
      (
        undirected ?
          typeof sourceData.undirected[target] !== 'undefined' :
          typeof sourceData.out[target] !== 'undefined'
      )
    ) {
      alreadyExistingEdgeData = getMatchingEdge(graph, source, target, undirected ? 'undirected' : 'directed');
    }

    // Handling duplicates
    if (alreadyExistingEdgeData) {

      // We can skip the attribute merging part if the user did not provide them
      if (!attributes)
        return alreadyExistingEdge;

      // Merging the attributes
      assign(alreadyExistingEdgeData.attributes, attributes);
      return alreadyExistingEdge;
    }

    // Must the graph generate an id for this edge?
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };

    if (mustGenerateKey)
      edge = graph._edgeKeyGenerator(eventData);

    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);

    if (!sourceData) {
      graph.addNode(source);
      sourceData = graph._nodes.get(source);

      if (source === target)
        targetData = sourceData;
    }
    if (!targetData) {
      graph.addNode(target);
      targetData = graph._nodes.get(target);
    }

    // Storing some data
    const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;

    edgeData = new DataClass(
      edge,
      mustGenerateKey,
      sourceData,
      targetData,
      attributes
    );

    // Adding the edge to the internal register
    graph._edges.set(edge, edgeData);

    // Incrementing node degree counters
    if (source === target) {
      if (undirected)
        sourceData.undirectedSelfLoops++;
      else
        sourceData.directedSelfLoops++;
    }
    else {
      if (undirected) {
        sourceData.undirectedDegree++;
        targetData.undirectedDegree++;
      }
      else {
        sourceData.outDegree++;
        targetData.inDegree++;
      }
    }

    // Updating relevant index
    updateStructureIndex(
      graph,
      undirected,
      edgeData,
      source,
      target,
      sourceData,
      targetData
    );

    if (undirected)
      graph._undirectedSize++;
    else
      graph._directedSize++;

    // Emitting
    eventData.key = edge;

    graph.emit('edgeAdded', eventData);

    return edge;
  }

  /**
   * Graph class
   *
   * @constructor
   * @param  {object}  [options] - Options:
   * @param  {boolean}   [allowSelfLoops] - Allow self loops?
   * @param  {string}    [type]           - Type of the graph.
   * @param  {boolean}   [map]            - Allow references as keys?
   * @param  {boolean}   [multi]          - Allow parallel edges?
   *
   * @throws {Error} - Will throw if the arguments are not valid.
   */
  class Graph extends EventEmitter {
    constructor(options) {
      super();

      //-- Solving options
      options = assign({}, DEFAULTS, options);

      // Enforcing options validity
      if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')
        throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got "${options.edgeKeyGenerator}".`);

      if (typeof options.multi !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`);

      if (!TYPES.has(options.type))
        throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`);

      if (typeof options.allowSelfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`);

      //-- Private properties

      // Utilities
      const NodeDataClass = options.type === 'mixed' ?
        MixedNodeData :
        (options.type === 'directed') ?
          DirectedNodeData :
          UndirectedNodeData;

      privateProperty(this, 'NodeDataClass', NodeDataClass);

      // Indexes
      privateProperty(this, '_attributes', {});
      privateProperty(this, '_nodes', new Map());
      privateProperty(this, '_edges', new Map());
      privateProperty(this, '_directedSize', 0);
      privateProperty(this, '_undirectedSize', 0);
      privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());

      // Options
      privateProperty(this, '_options', options);

      // Emitter properties
      EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));

      //-- Properties readers
      readOnlyProperty(this, 'order', () => this._nodes.size);
      readOnlyProperty(this, 'size', () => this._edges.size);
      readOnlyProperty(this, 'directedSize', () => this._directedSize);
      readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);
      readOnlyProperty(this, 'multi', this._options.multi);
      readOnlyProperty(this, 'type', this._options.type);
      readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);
    }

    /**---------------------------------------------------------------------------
     * Read
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning whether the given node is found in the graph.
     *
     * @param  {any}     node - The node.
     * @return {boolean}
     */
    hasNode(node) {
      return this._nodes.has('' + node);
    }

    /**
     * Method returning whether the given directed edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasDirectedEdge(source, target) {

      // Early termination
      if (this.type === 'undirected')
        return false;

      if (arguments.length === 1) {
        const edge = '' + source;

        const edgeData = this._edges.get(edge);

        return (
          !!edgeData &&
          edgeData instanceof DirectedEdgeData
        );
      }
      else if (arguments.length === 2) {

        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        const nodeData = this._nodes.get(source);

        if (!nodeData)
          return false;

        // Is there a directed edge pointing toward target?
        const edges = nodeData.out[target];

        if (!edges)
          return false;

        return this.multi ? !!edges.size : true;
      }

      throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
    }

    /**
     * Method returning whether the given undirected edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasUndirectedEdge(source, target) {

      // Early termination
      if (this.type === 'directed')
        return false;

      if (arguments.length === 1) {
        const edge = '' + source;

        const edgeData = this._edges.get(edge);

        return (
          !!edgeData &&
          edgeData instanceof UndirectedEdgeData
        );
      }
      else if (arguments.length === 2) {

        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        const nodeData = this._nodes.get(source);

        if (!nodeData)
          return false;

        // Is there a directed edge pointing toward target?
        const edges = nodeData.undirected[target];

        if (!edges)
          return false;

        return this.multi ? !!edges.size : true;
      }

      throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
    }

    /**
     * Method returning whether the given edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */
    hasEdge(source, target) {

      if (arguments.length === 1) {
        const edge = '' + source;

        return this._edges.has(edge);
      }
      else if (arguments.length === 2) {

        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        const nodeData = this._nodes.get(source);

        if (!nodeData)
          return false;

        // Is there a directed edge pointing toward target?
        let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];

        if (!edges)
          edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];

        if (!edges)
          return false;

        return this.multi ? !!edges.size : true;
      }

      throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
    }

    /**
     * Method returning the edge matching source & target in a directed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    directedEdge(source, target) {

      if (this.type === 'undirected')
        return;

      source = '' + source;
      target = '' + target;

      if (this.multi)
        throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${source}" source node in the graph.`);

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${target}" target node in the graph.`);

      const edgeData = (sourceData.out && sourceData.out[target]) || undefined;

      if (edgeData)
        return edgeData.key;
    }

    /**
     * Method returning the edge matching source & target in a undirected fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    undirectedEdge(source, target) {

      if (this.type === 'directed')
        return;

      source = '' + source;
      target = '' + target;

      if (this.multi)
        throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${source}" source node in the graph.`);

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${target}" target node in the graph.`);

      const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;

      if (edgeData)
        return edgeData.key;
    }

    /**
     * Method returning the edge matching source & target in a mixed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */
    edge(source, target) {
      if (this.multi)
        throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');

      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(`Graph.edge: could not find the "${source}" source node in the graph.`);

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.edge: could not find the "${target}" target node in the graph.`);

      const edgeData = (
        (sourceData.out && sourceData.out[target]) ||
        (sourceData.undirected && sourceData.undirected[target]) ||
        undefined
      );

      if (edgeData)
        return edgeData.key;
    }

    /**
     * Method returning the given node's in degree.
     *
     * @param  {any}     node      - The node's key.
     * @param  {boolean} allowSelfLoops - Count self-loops?
     * @return {number}            - The node's in degree.
     *
     * @throws {Error} - Will throw if the selfLoops arg is not boolean.
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    inDegree(node, selfLoops = true) {
      if (typeof selfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);

      node = '' + node;

      const nodeData = this._nodes.get(node);

      if (!nodeData)
        throw new NotFoundGraphError(`Graph.inDegree: could not find the "${node}" node in the graph.`);

      if (this.type === 'undirected')
        return 0;

      const loops = selfLoops ? nodeData.directedSelfLoops : 0;

      return nodeData.inDegree + loops;
    }

    /**
     * Method returning the given node's out degree.
     *
     * @param  {any}     node      - The node's key.
     * @param  {boolean} selfLoops - Count self-loops?
     * @return {number}            - The node's out degree.
     *
     * @throws {Error} - Will throw if the selfLoops arg is not boolean.
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    outDegree(node, selfLoops = true) {
      if (typeof selfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);

      node = '' + node;

      const nodeData = this._nodes.get(node);

      if (!nodeData)
        throw new NotFoundGraphError(`Graph.outDegree: could not find the "${node}" node in the graph.`);

      if (this.type === 'undirected')
        return 0;

      const loops = selfLoops ? nodeData.directedSelfLoops : 0;

      return nodeData.outDegree + loops;
    }

    /**
     * Method returning the given node's directed degree.
     *
     * @param  {any}     node      - The node's key.
     * @param  {boolean} selfLoops - Count self-loops?
     * @return {number}            - The node's directed degree.
     *
     * @throws {Error} - Will throw if the selfLoops arg is not boolean.
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    directedDegree(node, selfLoops = true) {
      if (typeof selfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);

      node = '' + node;

      if (!this.hasNode(node))
        throw new NotFoundGraphError(`Graph.directedDegree: could not find the "${node}" node in the graph.`);

      if (this.type === 'undirected')
        return 0;

      return this.inDegree(node, selfLoops) + this.outDegree(node, selfLoops);
    }

    /**
     * Method returning the given node's undirected degree.
     *
     * @param  {any}     node      - The node's key.
     * @param  {boolean} selfLoops - Count self-loops?
     * @return {number}            - The node's undirected degree.
     *
     * @throws {Error} - Will throw if the selfLoops arg is not boolean.
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    undirectedDegree(node, selfLoops = true) {
      if (typeof selfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);

      node = '' + node;

      if (!this.hasNode(node))
        throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the "${node}" node in the graph.`);

      if (this.type === 'directed')
        return 0;

      const data = this._nodes.get(node),
            loops = selfLoops ? (data.undirectedSelfLoops * 2) : 0;

      return data.undirectedDegree + loops;
    }

    /**
     * Method returning the given node's degree.
     *
     * @param  {any}     node      - The node's key.
     * @param  {boolean} selfLoops - Count self-loops?
     * @return {number}            - The node's degree.
     *
     * @throws {Error} - Will throw if the selfLoops arg is not boolean.
     * @throws {Error} - Will throw if the node isn't in the graph.
     */
    degree(node, selfLoops = true) {
      if (typeof selfLoops !== 'boolean')
        throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);

      node = '' + node;

      if (!this.hasNode(node))
        throw new NotFoundGraphError(`Graph.degree: could not find the "${node}" node in the graph.`);

      let degree = 0;

      if (this.type !== 'undirected')
        degree += this.directedDegree(node, selfLoops);

      if (this.type !== 'directed')
        degree += this.undirectedDegree(node, selfLoops);

      return degree;
    }

    /**
     * Method returning the given edge's source.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's source.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    source(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.source: could not find the "${edge}" edge in the graph.`);

      return data.source.key;
    }

    /**
     * Method returning the given edge's target.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's target.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    target(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.target: could not find the "${edge}" edge in the graph.`);

      return data.target.key;
    }

    /**
     * Method returning the given edge's extremities.
     *
     * @param  {any}   edge - The edge's key.
     * @return {array}      - The edge's extremities.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    extremities(edge) {
      edge = '' + edge;

      const edgeData = this._edges.get(edge);

      if (!edgeData)
        throw new NotFoundGraphError(`Graph.extremities: could not find the "${edge}" edge in the graph.`);

      return [
        edgeData.source.key,
        edgeData.target.key
      ];
    }

    /**
     * Given a node & an edge, returns the other extremity of the edge.
     *
     * @param  {any}   node - The node's key.
     * @param  {any}   edge - The edge's key.
     * @return {any}        - The related node.
     *
     * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
     */
    opposite(node, edge) {
      node = '' + node;
      edge = '' + edge;

      if (!this._nodes.has(node))
        throw new NotFoundGraphError(`Graph.opposite: could not find the "${node}" node in the graph.`);

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.opposite: could not find the "${edge}" edge in the graph.`);

      const {source: sourceData, target: targetData} = data;

      const source = sourceData.key,
            target = targetData.key;

      if (node !== source && node !== target)
        throw new NotFoundGraphError(`Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`);

      return node === source ? target : source;
    }

    /**
     * Method returning whether the given edge is undirected.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    undirected(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.undirected: could not find the "${edge}" edge in the graph.`);

      return data instanceof UndirectedEdgeData;
    }

    /**
     * Method returning whether the given edge is directed.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    directed(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.directed: could not find the "${edge}" edge in the graph.`);

      return data instanceof DirectedEdgeData;
    }

    /**
     * Method returning whether the given edge is a self loop.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */
    selfLoop(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.selfLoop: could not find the "${edge}" edge in the graph.`);

      return data.source === data.target;
    }

    /**---------------------------------------------------------------------------
     * Mutation
     **---------------------------------------------------------------------------
     */

    /**
     * Method used to add a node to the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     *
     * @throws {Error} - Will throw if the given node already exist.
     * @throws {Error} - Will throw if the given attributes are not an object.
     */
    addNode(node, attributes) {
      if (attributes && !isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`);

      // String coercion
      node = '' + node;
      attributes = attributes || {};

      if (this._nodes.has(node))
        throw new UsageGraphError(`Graph.addNode: the "${node}" node already exist in the graph.`);

      const data = new this.NodeDataClass(node, attributes);

      // Adding the node to internal register
      this._nodes.set(node, data);

      // Emitting
      this.emit('nodeAdded', {
        key: node,
        attributes
      });

      return node;
    }

    /**
     * Method used to merge a node into the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     */
    mergeNode(node, attributes) {
      if (attributes && !isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`);

      // String coercion
      node = '' + node;
      attributes = attributes || {};

      // If the node already exists, we merge the attributes
      let data = this._nodes.get(node);

      if (data) {
        if (attributes)
          assign(data.attributes, attributes);
        return node;
      }

      data = new this.NodeDataClass(node, attributes);

      // Adding the node to internal register
      this._nodes.set(node, data);

      // Emitting
      this.emit('nodeAdded', {
        key: node,
        attributes
      });

      return node;
    }

    /**
     * Method used to drop a single node & all its attached edges from the graph.
     *
     * @param  {any}    node - The node.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node doesn't exist.
     */
    dropNode(node) {
      node = '' + node;

      if (!this.hasNode(node))
        throw new NotFoundGraphError(`Graph.dropNode: could not find the "${node}" node in the graph.`);

      // Removing attached edges
      const edges = this.edges(node);

      // NOTE: we could go faster here
      for (let i = 0, l = edges.length; i < l; i++)
        this.dropEdge(edges[i]);

      const data = this._nodes.get(node);

      // Dropping the node from the register
      this._nodes.delete(node);

      // Emitting
      this.emit('nodeDropped', {
        key: node,
        attributes: data.attributes
      });
    }

    /**
     * Method used to drop a single edge from the graph.
     *
     * Arity 1:
     * @param  {any}    edge - The edge.
     *
     * Arity 2:
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */
    dropEdge(edge) {
      let edgeData;

      if (arguments.length > 1) {
        const source = '' + arguments[0],
              target = '' + arguments[1];

        edgeData = getMatchingEdge(this, source, target, this.type);

        if (!edgeData)
          throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`);
      }
      else {
        edge = '' + edge;

        edgeData = this._edges.get(edge);

        if (!edgeData)
          throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${edge}" edge in the graph.`);
      }

      // Dropping the edge from the register
      this._edges.delete(edgeData.key);

      // Updating related degrees
      const {
        source: sourceData,
        target: targetData,
        attributes
      } = edgeData;

      const undirected = edgeData instanceof UndirectedEdgeData;

      if (sourceData === targetData) {
        sourceData.selfLoops--;
      }
      else {
        if (undirected) {
          sourceData.undirectedDegree--;
          targetData.undirectedDegree--;
        }
        else {
          sourceData.outDegree--;
          targetData.inDegree--;
        }
      }

      // Clearing index
      clearEdgeFromStructureIndex(this, undirected, edgeData);

      if (undirected)
        this._undirectedSize--;
      else
        this._directedSize--;

      // Emitting
      this.emit('edgeDropped', {
        key: edge,
        attributes,
        source: sourceData.key,
        target: targetData.key,
        undirected
      });

      return this;
    }

    /**
     * Method used to remove every edge & every node from the graph.
     *
     * @return {Graph}
     */
    clear() {

      // Clearing edges
      this._edges.clear();

      // Clearing nodes
      this._nodes.clear();

      // Emitting
      this.emit('cleared');
    }

    /**
     * Method used to remove every edge from the graph.
     *
     * @return {Graph}
     */
    clearEdges() {

      // Clearing edges
      this._edges.clear();

      // Clearing indices
      this.clearIndex();

      // Emitting
      this.emit('edgesCleared');
    }

    /**---------------------------------------------------------------------------
     * Attributes-related methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning the desired graph's attribute.
     *
     * @param  {string} name - Name of the attribute.
     * @return {any}
     */
    getAttribute(name) {
      return this._attributes[name];
    }

    /**
     * Method returning the graph's attributes.
     *
     * @return {object}
     */
    getAttributes() {
      return this._attributes;
    }

    /**
     * Method returning whether the graph has the desired attribute.
     *
     * @param  {string}  name - Name of the attribute.
     * @return {boolean}
     */
    hasAttribute(name) {
      return this._attributes.hasOwnProperty(name);
    }

    /**
     * Method setting a value for the desired graph's attribute.
     *
     * @param  {string}  name  - Name of the attribute.
     * @param  {any}     value - Value for the attribute.
     * @return {Graph}
     */
    setAttribute(name, value) {
      this._attributes[name] = value;

      // Emitting
      this.emit('attributesUpdated', {
        type: 'set',
        meta: {
          name,
          value
        }
      });

      return this;
    }

    /**
     * Method using a function to update the desired graph's attribute's value.
     *
     * @param  {string}   name    - Name of the attribute.
     * @param  {function} updater - Function use to update the attribute's value.
     * @return {Graph}
     */
    updateAttribute(name, updater) {
      if (typeof updater !== 'function')
        throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');

      this._attributes[name] = updater(this._attributes[name]);

      // Emitting
      this.emit('attributesUpdated', {
        type: 'set',
        meta: {
          name,
          value: this._attributes[name]
        }
      });

      return this;
    }

    /**
     * Method removing the desired graph's attribute.
     *
     * @param  {string} name  - Name of the attribute.
     * @return {Graph}
     */
    removeAttribute(name) {
      delete this._attributes[name];

      // Emitting
      this.emit('attributesUpdated', {
        type: 'remove',
        meta: {
          name
        }
      });

      return this;
    }

    /**
     * Method replacing the graph's attributes.
     *
     * @param  {object} attributes - New attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */
    replaceAttributes(attributes) {
      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');

      const before = this._attributes;

      this._attributes = attributes;

      // Emitting
      this.emit('attributesUpdated', {
        type: 'replace',
        meta: {
          before,
          after: attributes
        }
      });

      return this;
    }

    /**
     * Method merging the graph's attributes.
     *
     * @param  {object} attributes - Attributes to merge.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */
    mergeAttributes(attributes) {
      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');

      this._attributes = assign(this._attributes, attributes);

      // Emitting
      this.emit('attributesUpdated', {
        type: 'merge',
        meta: {
          data: this._attributes
        }
      });

      return this;
    }

    /**
     * Method returning the desired attribute for the given node.
     *
     * @param  {any}    node - Target node.
     * @param  {string} name - Name of the attribute to get.
     * @return {any}
     *
     * @throws {Error} - Will throw if the node is not found.
     */
    getNodeAttribute(node, name) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the "${node}" node in the graph.`);

      return data.attributes[name];
    }

    /**
     * Method returning the attributes for the given node.
     *
     * @param  {any}    node - Target node.
     * @return {object}
     *
     * @throws {Error} - Will throw if the node is not found.
     */
    getNodeAttributes(node) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the "${node}" node in the graph.`);

      return data.attributes;
    }

    /**
     * Method checking whether the given attribute exists for the given node.
     *
     * @param  {any}    node - Target node.
     * @param  {string} name - Name of the attribute to check.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node is not found.
     */
    hasNodeAttribute(node, name) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the "${node}" node in the graph.`);

      return data.attributes.hasOwnProperty(name);
    }

    /**
     * Method checking setting the desired attribute for the given node.
     *
     * @param  {any}    node  - Target node.
     * @param  {string} name  - Name of the attribute to set.
     * @param  {any}    value - Value for the attribute.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if less than 3 arguments are passed.
     * @throws {Error} - Will throw if the node is not found.
     */
    setNodeAttribute(node, name, value) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the "${node}" node in the graph.`);

      if (arguments.length < 3)
        throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');

      data.attributes[name] = value;

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: node,
        type: 'set',
        meta: {
          name,
          value
        }
      });

      return this;
    }

    /**
     * Method checking setting the desired attribute for the given node.
     *
     * @param  {any}      node    - Target node.
     * @param  {string}   name    - Name of the attribute to set.
     * @param  {function} updater - Function that will update the attribute.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if less than 3 arguments are passed.
     * @throws {Error} - Will throw if updater is not a function.
     * @throws {Error} - Will throw if the node is not found.
     */
    updateNodeAttribute(node, name, updater) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the "${node}" node in the graph.`);

      if (arguments.length < 3)
        throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');

      if (typeof updater !== 'function')
        throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');

      const attributes = data.attributes;

      attributes[name] = updater(attributes[name]);

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: node,
        type: 'set',
        meta: {
          name,
          value: attributes[name]
        }
      });

      return this;
    }

    /**
     * Method removing the desired attribute for the given node.
     *
     * @param  {any}    node  - Target node.
     * @param  {string} name  - Name of the attribute to remove.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node is not found.
     */
    removeNodeAttribute(node, name) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the "${node}" node in the graph.`);

      delete data.attributes[name];

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: node,
        type: 'remove',
        meta: {
          name
        }
      });

      return this;
    }

    /**
     * Method completely replacing the attributes of the given node.
     *
     * @param  {any}    node       - Target node.
     * @param  {object} attributes - New attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node is not found.
     * @throws {Error} - Will throw if the given attributes is not a plain object.
     */
    replaceNodeAttributes(node, attributes) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the "${node}" node in the graph.`);

      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');

      const oldAttributes = data.attributes;

      data.attributes = attributes;

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: node,
        type: 'replace',
        meta: {
          before: oldAttributes,
          after: attributes
        }
      });

      return this;
    }

    /**
     * Method merging the attributes of the given node with the provided ones.
     *
     * @param  {any}    node       - Target node.
     * @param  {object} attributes - Attributes to merge.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node is not found.
     * @throws {Error} - Will throw if the given attributes is not a plain object.
     */
    mergeNodeAttributes(node, attributes) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the "${node}" node in the graph.`);

      if (!isPlainObject$1(attributes))
        throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');

      assign(data.attributes, attributes);

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: node,
        type: 'merge',
        meta: {
          data: attributes
        }
      });

      return this;
    }

    /**---------------------------------------------------------------------------
     * Iteration-related methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method iterating over the graph's adjacency using the given callback.
     *
     * @param  {function}  callback - Callback to use.
     */
    forEach(callback) {
      if (typeof callback !== 'function')
        throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');

      this._edges.forEach((edgeData, key) => {
        const sourceData = edgeData.source,
              targetData = edgeData.target;

        callback(
          sourceData.key,
          targetData.key,
          sourceData.attributes,
          targetData.attributes,
          key,
          edgeData.attributes
        );
      });
    }

    /**
     * Method returning an iterator over the graph's adjacency.
     *
     * @return {Iterator}
     */
    adjacency() {
      const iterator$1 = this._edges.values();

      return new iterator(function() {
        const step = iterator$1.next();

        if (step.done)
          return step;

        const edgeData = step.value;

        const sourceData = edgeData.source,
              targetData = edgeData.target;

        return {
          done: false,
          value: [
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes
          ]
        };
      });
    }

    /**
     * Method returning the list of the graph's nodes.
     *
     * @return {array} - The nodes.
     */
    nodes() {
      return take(this._nodes.keys(), this._nodes.size);
    }

    /**
     * Method iterating over the graph's nodes using the given callback.
     *
     * @param  {function}  callback - Callback (key, attributes, index).
     */
    forEachNode(callback) {
      if (typeof callback !== 'function')
        throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');

      this._nodes.forEach((data, key) => {
        callback(key, data.attributes);
      });
    }

    /**
     * Method returning an iterator over the graph's node entries.
     *
     * @return {Iterator}
     */
    nodeEntries() {
      const iterator$1 = this._nodes.values();

      return new iterator(() => {
        const step = iterator$1.next();

        if (step.done)
          return step;

        const data = step.value;

        return {value: [data.key, data.attributes], done: false};
      });
    }

    /**---------------------------------------------------------------------------
     * Serialization
     **---------------------------------------------------------------------------
     */

    /**
     * Method exporting the target node.
     *
     * @param  {any}   node - Target node.
     * @return {array}      - The serialized node.
     *
     * @throws {Error} - Will throw if the node is not found.
     */
    exportNode(node) {
      node = '' + node;

      const data = this._nodes.get(node);

      if (!data)
        throw new NotFoundGraphError(`Graph.exportNode: could not find the "${node}" node in the graph.`);

      return serializeNode(node, data);
    }

    /**
     * Method exporting the target edge.
     *
     * @param  {any}   edge - Target edge.
     * @return {array}      - The serialized edge.
     *
     * @throws {Error} - Will throw if the edge is not found.
     */
    exportEdge(edge) {
      edge = '' + edge;

      const data = this._edges.get(edge);

      if (!data)
        throw new NotFoundGraphError(`Graph.exportEdge: could not find the "${edge}" edge in the graph.`);

      return serializeEdge(edge, data);
    }

    /**
     * Method used to export the whole graph.
     *
     * @return {object} - The serialized graph.
     */
    export() {

      const nodes = new Array(this._nodes.size);

      let i = 0;

      this._nodes.forEach((data, key) => {
        nodes[i++] = serializeNode(key, data);
      });

      const edges = new Array(this._edges.size);

      i = 0;

      this._edges.forEach((data, key) => {
        edges[i++] = serializeEdge(key, data);
      });

      return {
        attributes: this.getAttributes(),
        nodes,
        edges
      };
    }

    /**
     * Method used to import a serialized node.
     *
     * @param  {object} data   - The serialized node.
     * @param  {boolean} merge - Whether to merge the given node.
     * @return {Graph}         - Returns itself for chaining.
     */
    importNode(data, merge = false) {

      // Validating
      const error = validateSerializedNode(data);

      if (error) {

        if (error === 'not-object')
          throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
        if (error === 'no-key')
          throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');
        if (error === 'invalid-attributes')
          throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');
      }

      // Adding the node
      const {key, attributes = {}} = data;

      if (merge)
        this.mergeNode(key, attributes);
      else
        this.addNode(key, attributes);

      return this;
    }

    /**
     * Method used to import a serialized edge.
     *
     * @param  {object}  data  - The serialized edge.
     * @param  {boolean} merge - Whether to merge the given edge.
     * @return {Graph}         - Returns itself for chaining.
     */
    importEdge(data, merge = false) {

      // Validating
      const error = validateSerializedEdge(data);

      if (error) {

        if (error === 'not-object')
          throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
        if (error === 'no-source')
          throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');
        if (error === 'no-target')
          throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');
        if (error === 'invalid-attributes')
          throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');
        if (error === 'invalid-undirected')
          throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');
      }

      // Adding the edge
      const {
        source,
        target,
        attributes = {},
        undirected = false
      } = data;

      let method;

      if ('key' in data) {
        method = merge ?
          (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :
          (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);

        method.call(
          this,
          data.key,
          source,
          target,
          attributes
        );
      }
      else {
        method = merge ?
          (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :
          (undirected ? this.addUndirectedEdge : this.addDirectedEdge);

        method.call(
          this,
          source,
          target,
          attributes
        );
      }

      return this;
    }

    /**
     * Method used to import a serialized graph.
     *
     * @param  {object|Graph} data  - The serialized graph.
     * @param  {boolean}      merge - Whether to merge data.
     * @return {Graph}              - Returns itself for chaining.
     */
    import(data, merge = false) {

      // Importing a Graph instance
      if (isGraph(data)) {

        this.import(data.export(), merge);
        return this;
      }

      // Importing a serialized graph
      if (!isPlainObject$1(data))
        throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');

      if (data.attributes) {
        if (!isPlainObject$1(data.attributes))
          throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');

        if (merge)
          this.mergeAttributes(data.attributes);
        else
          this.replaceAttributes(data.attributes);
      }

      // TODO: optimize
      if (data.nodes)
        data.nodes.forEach(node => this.importNode(node, merge));

      if (data.edges)
        data.edges.forEach(edge => this.importEdge(edge, merge));

      return this;
    }

    /**---------------------------------------------------------------------------
     * Utils
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning a null copy of the graph, i.e. a graph without nodes
     * & edges but with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The null copy.
     */
    nullCopy(options) {
      return new Graph(assign({}, this._options, options));
    }

    /**
     * Method returning an empty copy of the graph, i.e. a graph without edges but
     * with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The empty copy.
     */
    emptyCopy(options) {
      const graph = new Graph(assign({}, this._options, options));

      this._nodes.forEach((nodeData, key) => {
        nodeData = new graph.NodeDataClass(key, assign({}, nodeData.attributes));
        graph._nodes.set(key, nodeData);
      });

      return graph;
    }

    /**
     * Method returning an exact copy of the graph.
     *
     * @return {Graph} - The copy.
     */
    copy() {
      const graph = new Graph(this._options);
      graph.import(this);

      return graph;
    }

    /**
     * Method upgrading the graph to a mixed one.
     *
     * @return {Graph} - The copy.
     */
    upgradeToMixed() {
      if (this.type === 'mixed')
        return this;

      // Upgrading node data:
      // NOTE: maybe this could lead to some de-optimization by usual
      // JavaScript engines but I cannot be sure of it. Another solution
      // would be to reinstantiate the classes but this surely has a performance
      // and memory impact.
      this._nodes.forEach(data => (data.upgradeToMixed()));

      // Mutating the options & the instance
      this._options.type = 'mixed';
      readOnlyProperty(this, 'type', this._options.type);
      privateProperty(this, 'NodeDataClass', MixedNodeData);

      return this;
    }

    /**
     * Method upgrading the graph to a multi one.
     *
     * @return {Graph} - The copy.
     */
    upgradeToMulti() {
      if (this.multi)
        return this;

      // Mutating the options & the instance
      this._options.multi = true;
      readOnlyProperty(this, 'multi', true);

      // Upgrading indices
      upgradeStructureIndexToMulti(this);

      return this;
    }

    /**---------------------------------------------------------------------------
     * Indexes-related methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method used to clear the desired index to clear memory.
     *
     * @return {Graph}       - Returns itself for chaining.
     */
    clearIndex() {
      clearStructureIndex(this);
      return this;
    }

    /**---------------------------------------------------------------------------
     * Known methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method used by JavaScript to perform JSON serialization.
     *
     * @return {object} - The serialized graph.
     */
    toJSON() {
      return this.export();
    }

    /**
     * Method used to perform string coercion and returning useful information
     * about the Graph instance.
     *
     * @return {string} - String representation of the graph.
     */
    toString() {
      const pluralOrder = this.order > 1 || this.order === 0,
            pluralSize = this.size > 1 || this.size === 0;

      return `Graph<${prettyPrint(this.order)} node${pluralOrder ? 's' : ''}, ${prettyPrint(this.size)} edge${pluralSize ? 's' : ''}>`;
    }

    /**
     * Method used internally by node's console to display a custom object.
     *
     * @return {object} - Formatted object representation of the graph.
     */
    inspect() {
      const nodes = {};
      this._nodes.forEach((data, key) => {
        nodes[key] = data.attributes;
      });

      const edges = {},
            multiIndex = {};

      this._edges.forEach((data, key) => {
        const direction = data instanceof UndirectedEdgeData ? '--' : '->';

        let label = '';

        const desc = `(${data.source.key})${direction}(${data.target.key})`;

        if (!data.generatedKey) {
          label += `[${key}]: `;
        }
        else if (this.multi) {
          if (typeof multiIndex[desc] === 'undefined') {
            multiIndex[desc] = 0;
          }
          else {
            multiIndex[desc]++;
          }

          label += `${multiIndex[desc]}. `;
        }

        label += desc;

        edges[label] = data.attributes;
      });

      const dummy = {};

      for (const k in this) {
        if (this.hasOwnProperty(k) &&
            !EMITTER_PROPS.has(k) &&
            typeof this[k] !== 'function')
          dummy[k] = this[k];
      }

      dummy.attributes = this._attributes;
      dummy.nodes = nodes;
      dummy.edges = edges;

      privateProperty(dummy, 'constructor', this.constructor);

      return dummy;
    }
  }

  /**
   * Attaching custom inspect method for node >= 10.
   */
  if (typeof Symbol !== 'undefined')
    Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;

  /**
   * Attaching methods to the prototype.
   *
   * Here, we are attaching a wide variety of methods to the Graph class'
   * prototype when those are very numerous and when their creation is
   * abstracted.
   */

  /**
   * Related to edge addition.
   */
  EDGE_ADD_METHODS.forEach(method => {
    ['add', 'merge'].forEach(verb => {
      const name = method.name(verb),
            fn = verb === 'add' ? addEdge : mergeEdge;

      if (method.generateKey) {
        Graph.prototype[name] = function(source, target, attributes) {
          return fn(
            this,
            name,
            true,
            (method.type || this.type) === 'undirected',
            null,
            source,
            target,
            attributes
          );
        };
      }
      else {
        Graph.prototype[name] = function(edge, source, target, attributes) {
          return fn(
            this,
            name,
            false,
            (method.type || this.type) === 'undirected',
            edge,
            source,
            target,
            attributes
          );
        };
      }
    });
  });

  /**
   * Self iterator.
   */
  if (typeof Symbol !== 'undefined')
    Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;

  /**
   * Attributes-related.
   */
  attachAttributesMethods(Graph);

  /**
   * Edge iteration-related.
   */
  attachEdgeIterationMethods(Graph);

  /**
   * Neighbor iteration-related.
   */
  attachNeighborIterationMethods(Graph);

  /**
   * Graphology Helper Classes
   * ==========================
   *
   * Building some higher-order classes instantiating the graph with
   * predefinite options.
   */

  /**
   * Alternative constructors.
   */
  class DirectedGraph extends Graph {
    constructor(options) {
      super(
        assign({type: 'directed'}, options)
      );
    }
  }
  class UndirectedGraph extends Graph {
    constructor(options) {
      super(
        assign({type: 'undirected'}, options)
      );
    }
  }
  class MultiGraph extends Graph {
    constructor(options) {
      super(
        assign({multi: true}, options)
      );
    }
  }
  class MultiDirectedGraph extends Graph {
    constructor(options) {
      super(
        assign({multi: true, type: 'directed'}, options)
      );
    }
  }
  class MultiUndirectedGraph extends Graph {
    constructor(options) {
      super(
        assign({multi: true, type: 'undirected'}, options)
      );
    }
  }

  /**
   * Attaching static #.from method to each of the constructors.
   */
  function attachStaticFromMethod(Class) {

    /**
     * Builds a graph from serialized data or another graph's data.
     *
     * @param  {Graph|SerializedGraph} data      - Hydratation data.
     * @param  {object}                [options] - Options.
     * @return {Class}
     */
    Class.from = function(data, options) {
      const instance = new Class(options);
      instance.import(data);

      return instance;
    };
  }

  attachStaticFromMethod(Graph);
  attachStaticFromMethod(DirectedGraph);
  attachStaticFromMethod(UndirectedGraph);
  attachStaticFromMethod(MultiGraph);
  attachStaticFromMethod(MultiDirectedGraph);
  attachStaticFromMethod(MultiUndirectedGraph);

  Graph.Graph = Graph;
  Graph.DirectedGraph = DirectedGraph;
  Graph.UndirectedGraph = UndirectedGraph;
  Graph.MultiGraph = MultiGraph;
  Graph.MultiDirectedGraph = MultiDirectedGraph;
  Graph.MultiUndirectedGraph = MultiUndirectedGraph;

  Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
  Graph.NotFoundGraphError = NotFoundGraphError;
  Graph.UsageGraphError = UsageGraphError;

  /**
   * Graphology isGraph
   * ===================
   *
   * Very simple function aiming at ensuring the given variable is a
   * graphology instance.
   */

  /**
   * Checking the value is a graphology instance.
   *
   * @param  {any}     value - Target value.
   * @return {boolean}
   */
  var isGraph$1 = function isGraph(value) {
    return (
      value !== null &&
      typeof value === 'object' &&
      typeof value.addUndirectedEdgeWithKey === 'function' &&
      typeof value.dropNode === 'function' &&
      typeof value.multi === 'boolean'
    );
  };

  /* eslint no-constant-condition: 0 */
  /**
   * Graphology ForceAtlas2 Iteration
   * =================================
   *
   * Function used to perform a single iteration of the algorithm.
   */

  /**
   * Matrices properties accessors.
   */
  var NODE_X = 0,
      NODE_Y = 1,
      NODE_DX = 2,
      NODE_DY = 3,
      NODE_OLD_DX = 4,
      NODE_OLD_DY = 5,
      NODE_MASS = 6,
      NODE_CONVERGENCE = 7,
      NODE_SIZE = 8,
      NODE_FIXED = 9;

  var EDGE_SOURCE = 0,
      EDGE_TARGET = 1,
      EDGE_WEIGHT = 2;

  var REGION_NODE = 0,
      REGION_CENTER_X = 1,
      REGION_CENTER_Y = 2,
      REGION_SIZE = 3,
      REGION_NEXT_SIBLING = 4,
      REGION_FIRST_CHILD = 5,
      REGION_MASS = 6,
      REGION_MASS_CENTER_X = 7,
      REGION_MASS_CENTER_Y = 8;

  var SUBDIVISION_ATTEMPTS = 3;

  /**
   * Constants.
   */
  var PPN = 10,
      PPE = 3,
      PPR = 9;

  var MAX_FORCE = 10;

  /**
   * Function used to perform a single interation of the algorithm.
   *
   * @param  {object}       options    - Layout options.
   * @param  {Float32Array} NodeMatrix - Node data.
   * @param  {Float32Array} EdgeMatrix - Edge data.
   * @return {object}                  - Some metadata.
   */
  var iterate = function iterate(options, NodeMatrix, EdgeMatrix) {

    // Initializing variables
    var l, r, n, n1, n2, rn, e, w, g, s;

    var order = NodeMatrix.length,
        size = EdgeMatrix.length;

    var adjustSizes = options.adjustSizes;

    var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;

    var outboundAttCompensation,
        coefficient,
        xDist,
        yDist,
        ewc,
        distance,
        factor;

    var RegionMatrix = [];

    // 1) Initializing layout data
    //-----------------------------

    // Resetting positions & computing max values
    for (n = 0; n < order; n += PPN) {
      NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];
      NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];
      NodeMatrix[n + NODE_DX] = 0;
      NodeMatrix[n + NODE_DY] = 0;
    }

    // If outbound attraction distribution, compensate
    if (options.outboundAttractionDistribution) {
      outboundAttCompensation = 0;
      for (n = 0; n < order; n += PPN) {
        outboundAttCompensation += NodeMatrix[n + NODE_MASS];
      }

      outboundAttCompensation /= (order / PPN);
    }


    // 1.bis) Barnes-Hut computation
    //------------------------------

    if (options.barnesHutOptimize) {

      // Setting up
      var minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity,
          q, q2, subdivisionAttempts;

      // Computing min and max values
      for (n = 0; n < order; n += PPN) {
        minX = Math.min(minX, NodeMatrix[n + NODE_X]);
        maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);
        minY = Math.min(minY, NodeMatrix[n + NODE_Y]);
        maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);
      }

      // squarify bounds, it's a quadtree
      var dx = maxX - minX, dy = maxY - minY;
      if (dx > dy) {
        minY -= (dx - dy) / 2;
        maxY = minY + dx;
      }
      else {
        minX -= (dy - dx) / 2;
        maxX = minX + dy;
      }

      // Build the Barnes Hut root region
      RegionMatrix[0 + REGION_NODE] = -1;
      RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;
      RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;
      RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);
      RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;
      RegionMatrix[0 + REGION_FIRST_CHILD] = -1;
      RegionMatrix[0 + REGION_MASS] = 0;
      RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;
      RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;

      // Add each node in the tree
      l = 1;
      for (n = 0; n < order; n += PPN) {

        // Current region, starting with root
        r = 0;
        subdivisionAttempts = SUBDIVISION_ATTEMPTS;

        while (true) {
          // Are there sub-regions?

          // We look at first child index
          if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {

            // There are sub-regions

            // We just iterate to find a "leaf" of the tree
            // that is an empty region or a region with a single node
            // (see next case)

            // Find the quadrant of n
            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {

              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                // Top Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD];
              }
              else {

                // Bottom Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
              }
            }
            else {
              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                // Top Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
              }
              else {

                // Bottom Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
              }
            }

            // Update center of mass and mass (we only do it for non-leave regions)
            RegionMatrix[r + REGION_MASS_CENTER_X] =
              (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] +
               NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /
              (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

            RegionMatrix[r + REGION_MASS_CENTER_Y] =
              (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] +
               NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /
              (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

            RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];

            // Iterate on the right quadrant
            r = q;
            continue;
          }
          else {

            // There are no sub-regions: we are in a "leaf"

            // Is there a node in this leave?
            if (RegionMatrix[r + REGION_NODE] < 0) {

              // There is no node in region:
              // we record node n and go on
              RegionMatrix[r + REGION_NODE] = n;
              break;
            }
            else {

              // There is a node in this region

              // We will need to create sub-regions, stick the two
              // nodes (the old one r[0] and the new one n) in two
              // subregions. If they fall in the same quadrant,
              // we will iterate.

              // Create sub-regions
              RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;
              w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)

              // NOTE: we use screen coordinates
              // from Top Left to Bottom Right

              // Top Left sub-region
              g = RegionMatrix[r + REGION_FIRST_CHILD];

              RegionMatrix[g + REGION_NODE] = -1;
              RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;
              RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;
              RegionMatrix[g + REGION_SIZE] = w;
              RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
              RegionMatrix[g + REGION_FIRST_CHILD] = -1;
              RegionMatrix[g + REGION_MASS] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

              // Bottom Left sub-region
              g += PPR;
              RegionMatrix[g + REGION_NODE] = -1;
              RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;
              RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;
              RegionMatrix[g + REGION_SIZE] = w;
              RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
              RegionMatrix[g + REGION_FIRST_CHILD] = -1;
              RegionMatrix[g + REGION_MASS] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

              // Top Right sub-region
              g += PPR;
              RegionMatrix[g + REGION_NODE] = -1;
              RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;
              RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;
              RegionMatrix[g + REGION_SIZE] = w;
              RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
              RegionMatrix[g + REGION_FIRST_CHILD] = -1;
              RegionMatrix[g + REGION_MASS] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

              // Bottom Right sub-region
              g += PPR;
              RegionMatrix[g + REGION_NODE] = -1;
              RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;
              RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;
              RegionMatrix[g + REGION_SIZE] = w;
              RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];
              RegionMatrix[g + REGION_FIRST_CHILD] = -1;
              RegionMatrix[g + REGION_MASS] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
              RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

              l += 4;

              // Now the goal is to find two different sub-regions
              // for the two nodes: the one previously recorded (r[0])
              // and the one we want to add (n)

              // Find the quadrant of the old node
              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
                if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                  // Top Left quarter
                  q = RegionMatrix[r + REGION_FIRST_CHILD];
                }
                else {

                  // Bottom Left quarter
                  q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
                }
              }
              else {
                if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                  // Top Right quarter
                  q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
                }
                else {

                  // Bottom Right quarter
                  q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
                }
              }

              // We remove r[0] from the region r, add its mass to r and record it in q
              RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];
              RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];
              RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];

              RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];
              RegionMatrix[r + REGION_NODE] = -1;

              // Find the quadrant of n
              if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
                if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                  // Top Left quarter
                  q2 = RegionMatrix[r + REGION_FIRST_CHILD];
                }
                else {
                  // Bottom Left quarter
                  q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
                }
              }
              else {
                if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {

                  // Top Right quarter
                  q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
                }
                else {

                  // Bottom Right quarter
                  q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
                }
              }

              if (q === q2) {

                // If both nodes are in the same quadrant,
                // we have to try it again on this quadrant
                if (subdivisionAttempts--) {
                  r = q;
                  continue; // while
                }
                else {
                  // we are out of precision here, and we cannot subdivide anymore
                  // but we have to break the loop anyway
                  subdivisionAttempts = SUBDIVISION_ATTEMPTS;
                  break; // while
                }

              }

              // If both quadrants are different, we record n
              // in its quadrant
              RegionMatrix[q2 + REGION_NODE] = n;
              break;
            }
          }
        }
      }
    }


    // 2) Repulsion
    //--------------
    // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient

    if (options.barnesHutOptimize) {
      coefficient = options.scalingRatio;

      // Applying repulsion through regions
      for (n = 0; n < order; n += PPN) {

        // Computing leaf quad nodes iteration

        r = 0; // Starting with root region
        while (true) {

          if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {

            // The region has sub-regions

            // We run the Barnes Hut test to see if we are at the right distance
            distance = (
              (Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2)) +
              (Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2))
            );

            s = RegionMatrix[r + REGION_SIZE];

            if ((4 * s * s) / distance < thetaSquared) {

              // We treat the region as a single body, and we repulse

              xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];
              yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];

              if (adjustSizes === true) {

                //-- Linear Anti-collision Repulsion
                if (distance > 0) {
                  factor = coefficient * NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS] / distance;

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
                else if (distance < 0) {
                  factor = -coefficient * NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
              }
              else {

                //-- Linear Repulsion
                if (distance > 0) {
                  factor = coefficient * NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS] / distance;

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
              }

              // When this is done, we iterate. We have to look at the next sibling.
              r = RegionMatrix[r + REGION_NEXT_SIBLING];
              if (r < 0)
                break; // No next sibling: we have finished the tree

              continue;
            }
            else {

              // The region is too close and we have to look at sub-regions
              r = RegionMatrix[r + REGION_FIRST_CHILD];
              continue;
            }

          }
          else {

            // The region has no sub-region
            // If there is a node r[0] and it is not n, then repulse
            rn = RegionMatrix[r + REGION_NODE];

            if (rn >= 0 && rn !== n) {
              xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];
              yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];

              distance = xDist * xDist + yDist * yDist;

              if (adjustSizes === true) {

                //-- Linear Anti-collision Repulsion
                if (distance > 0) {
                  factor = coefficient * NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS] / distance;

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
                else if (distance < 0) {
                  factor = -coefficient * NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
              }
              else {

                //-- Linear Repulsion
                if (distance > 0) {
                  factor = coefficient * NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS] / distance;

                  NodeMatrix[n + NODE_DX] += xDist * factor;
                  NodeMatrix[n + NODE_DY] += yDist * factor;
                }
              }

            }

            // When this is done, we iterate. We have to look at the next sibling.
            r = RegionMatrix[r + REGION_NEXT_SIBLING];

            if (r < 0)
              break; // No next sibling: we have finished the tree

            continue;
          }
        }
      }
    }
    else {
      coefficient = options.scalingRatio;

      // Square iteration
      for (n1 = 0; n1 < order; n1 += PPN) {
        for (n2 = 0; n2 < n1; n2 += PPN) {

          // Common to both methods
          xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
          yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

          if (adjustSizes === true) {

            //-- Anticollision Linear Repulsion
            distance = Math.sqrt(xDist * xDist + yDist * yDist) -
              NodeMatrix[n1 + NODE_SIZE] -
              NodeMatrix[n2 + NODE_SIZE];

            if (distance > 0) {
              factor = coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS] /
                distance / distance;

              // Updating nodes' dx and dy
              NodeMatrix[n1 + NODE_DX] += xDist * factor;
              NodeMatrix[n1 + NODE_DY] += yDist * factor;

              NodeMatrix[n2 + NODE_DX] += xDist * factor;
              NodeMatrix[n2 + NODE_DY] += yDist * factor;
            }
            else if (distance < 0) {
              factor = 100 * coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS];

              // Updating nodes' dx and dy
              NodeMatrix[n1 + NODE_DX] += xDist * factor;
              NodeMatrix[n1 + NODE_DY] += yDist * factor;

              NodeMatrix[n2 + NODE_DX] -= xDist * factor;
              NodeMatrix[n2 + NODE_DY] -= yDist * factor;
            }
          }
          else {

            //-- Linear Repulsion
            distance = Math.sqrt(xDist * xDist + yDist * yDist);

            if (distance > 0) {
              factor = coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS] /
                distance / distance;

              // Updating nodes' dx and dy
              NodeMatrix[n1 + NODE_DX] += xDist * factor;
              NodeMatrix[n1 + NODE_DY] += yDist * factor;

              NodeMatrix[n2 + NODE_DX] -= xDist * factor;
              NodeMatrix[n2 + NODE_DY] -= yDist * factor;
            }
          }
        }
      }
    }


    // 3) Gravity
    //------------
    g = options.gravity / options.scalingRatio;
    coefficient = options.scalingRatio;
    for (n = 0; n < order; n += PPN) {
      factor = 0;

      // Common to both methods
      xDist = NodeMatrix[n + NODE_X];
      yDist = NodeMatrix[n + NODE_Y];
      distance = Math.sqrt(
        Math.pow(xDist, 2) + Math.pow(yDist, 2)
      );

      if (options.strongGravityMode) {

        //-- Strong gravity
        if (distance > 0)
          factor = coefficient * NodeMatrix[n + NODE_MASS] * g;
      }
      else {

        //-- Linear Anti-collision Repulsion n
        if (distance > 0)
          factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;
      }

      // Updating node's dx and dy
      NodeMatrix[n + NODE_DX] -= xDist * factor;
      NodeMatrix[n + NODE_DY] -= yDist * factor;
    }

    // 4) Attraction
    //---------------
    coefficient = 1 *
      (options.outboundAttractionDistribution ?
        outboundAttCompensation :
        1);

    // TODO: simplify distance
    // TODO: coefficient is always used as -c --> optimize?
    for (e = 0; e < size; e += PPE) {
      n1 = EdgeMatrix[e + EDGE_SOURCE];
      n2 = EdgeMatrix[e + EDGE_TARGET];
      w = EdgeMatrix[e + EDGE_WEIGHT];

      // Edge weight influence
      ewc = Math.pow(w, options.edgeWeightInfluence);

      // Common measures
      xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
      yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

      // Applying attraction to nodes
      if (adjustSizes === true) {

        distance = Math.sqrt(
          (Math.pow(xDist, 2) + Math.pow(yDist, 2)) -
          NodeMatrix[n1 + NODE_SIZE] -
          NodeMatrix[n2 + NODE_SIZE]
        );

        if (options.linLogMode) {
          if (options.outboundAttractionDistribution) {

            //-- LinLog Degree Distributed Anti-collision Attraction
            if (distance > 0) {
              factor = -coefficient * ewc * Math.log(1 + distance) /
              distance /
              NodeMatrix[n1 + NODE_MASS];
            }
          }
          else {

            //-- LinLog Anti-collision Attraction
            if (distance > 0) {
              factor = -coefficient * ewc * Math.log(1 + distance) / distance;
            }
          }
        }
        else {
          if (options.outboundAttractionDistribution) {

            //-- Linear Degree Distributed Anti-collision Attraction
            if (distance > 0) {
              factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];
            }
          }
          else {

            //-- Linear Anti-collision Attraction
            if (distance > 0) {
              factor = -coefficient * ewc;
            }
          }
        }
      }
      else {

        distance = Math.sqrt(
          Math.pow(xDist, 2) + Math.pow(yDist, 2)
        );

        if (options.linLogMode) {
          if (options.outboundAttractionDistribution) {

            //-- LinLog Degree Distributed Attraction
            if (distance > 0) {
              factor = -coefficient * ewc * Math.log(1 + distance) /
                distance /
                NodeMatrix[n1 + NODE_MASS];
            }
          }
          else {

            //-- LinLog Attraction
            if (distance > 0)
              factor = -coefficient * ewc * Math.log(1 + distance) / distance;
          }
        }
        else {
          if (options.outboundAttractionDistribution) {

            //-- Linear Attraction Mass Distributed
            // NOTE: Distance is set to 1 to override next condition
            distance = 1;
            factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];
          }
          else {

            //-- Linear Attraction
            // NOTE: Distance is set to 1 to override next condition
            distance = 1;
            factor = -coefficient * ewc;
          }
        }
      }

      // Updating nodes' dx and dy
      // TODO: if condition or factor = 1?
      if (distance > 0) {

        // Updating nodes' dx and dy
        NodeMatrix[n1 + NODE_DX] += xDist * factor;
        NodeMatrix[n1 + NODE_DY] += yDist * factor;

        NodeMatrix[n2 + NODE_DX] -= xDist * factor;
        NodeMatrix[n2 + NODE_DY] -= yDist * factor;
      }
    }


    // 5) Apply Forces
    //-----------------
    var force,
        swinging,
        traction,
        nodespeed,
        newX,
        newY;

    // MATH: sqrt and square distances
    if (adjustSizes === true) {

      for (n = 0; n < order; n += PPN) {
        if (!NodeMatrix[n + NODE_FIXED]) {
          force = Math.sqrt(
            Math.pow(NodeMatrix[n + NODE_DX], 2) +
            Math.pow(NodeMatrix[n + NODE_DY], 2)
          );

          if (force > MAX_FORCE) {
            NodeMatrix[n + NODE_DX] =
              NodeMatrix[n + NODE_DX] * MAX_FORCE / force;
            NodeMatrix[n + NODE_DY] =
              NodeMatrix[n + NODE_DY] * MAX_FORCE / force;
          }

          swinging = NodeMatrix[n + NODE_MASS] *
            Math.sqrt(
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
            );

          traction = Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
            (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
            (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

          nodespeed =
            0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));

          // Updating node's positon
          newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *
            (nodespeed / options.slowDown);
          NodeMatrix[n + NODE_X] = newX;

          newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *
            (nodespeed / options.slowDown);
          NodeMatrix[n + NODE_Y] = newY;
        }
      }
    }
    else {

      for (n = 0; n < order; n += PPN) {
        if (!NodeMatrix[n + NODE_FIXED]) {

          swinging = NodeMatrix[n + NODE_MASS] *
            Math.sqrt(
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
            );

          traction = Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
            (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
            (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

          nodespeed = NodeMatrix[n + NODE_CONVERGENCE] *
            Math.log(1 + traction) / (1 + Math.sqrt(swinging));

          // Updating node convergence
          NodeMatrix[n + NODE_CONVERGENCE] =
            Math.min(1, Math.sqrt(
              nodespeed *
              (Math.pow(NodeMatrix[n + NODE_DX], 2) +
               Math.pow(NodeMatrix[n + NODE_DY], 2)) /
              (1 + Math.sqrt(swinging))
            ));

          // Updating node's positon
          newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *
            (nodespeed / options.slowDown);
          NodeMatrix[n + NODE_X] = newX;

          newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *
            (nodespeed / options.slowDown);
          NodeMatrix[n + NODE_Y] = newY;
        }
      }
    }

    // We return the information about the layout (no need to return the matrices)
    return {};
  };

  /**
   * Graphology ForceAtlas2 Helpers
   * ===============================
   *
   * Miscellaneous helper functions.
   */

  /**
   * Constants.
   */
  var PPN$1 = 10,
      PPE$1 = 3;

  /**
   * Very simple Object.assign-like function.
   *
   * @param  {object} target       - First object.
   * @param  {object} [...objects] - Objects to merge.
   * @return {object}
   */
  var assign$1 = function(target) {
    target = target || {};

    var objects = Array.prototype.slice.call(arguments).slice(1),
        i,
        k,
        l;

    for (i = 0, l = objects.length; i < l; i++) {
      if (!objects[i])
        continue;

      for (k in objects[i])
        target[k] = objects[i][k];
    }

    return target;
  };

  /**
   * Function used to validate the given settings.
   *
   * @param  {object}      settings - Settings to validate.
   * @return {object|null}
   */
  var validateSettings = function(settings) {

    if ('linLogMode' in settings &&
        typeof settings.linLogMode !== 'boolean')
      return {message: 'the `linLogMode` setting should be a boolean.'};

    if ('outboundAttractionDistribution' in settings &&
        typeof settings.outboundAttractionDistribution !== 'boolean')
      return {message: 'the `outboundAttractionDistribution` setting should be a boolean.'};

    if ('adjustSizes' in settings &&
        typeof settings.adjustSizes !== 'boolean')
      return {message: 'the `adjustSizes` setting should be a boolean.'};

    if ('edgeWeightInfluence' in settings &&
        typeof settings.edgeWeightInfluence !== 'number' &&
        settings.edgeWeightInfluence < 0)
      return {message: 'the `edgeWeightInfluence` setting should be a number >= 0.'};

    if ('scalingRatio' in settings &&
        typeof settings.scalingRatio !== 'number' &&
        settings.scalingRatio < 0)
      return {message: 'the `scalingRatio` setting should be a number >= 0.'};

    if ('strongGravityMode' in settings &&
        typeof settings.strongGravityMode !== 'boolean')
      return {message: 'the `strongGravityMode` setting should be a boolean.'};

    if ('gravity' in settings &&
        typeof settings.gravity !== 'number' &&
        settings.gravity < 0)
      return {message: 'the `gravity` setting should be a number >= 0.'};

    if ('slowDown' in settings &&
        typeof settings.slowDown !== 'number' &&
        settings.slowDown < 0)
      return {message: 'the `slowDown` setting should be a number >= 0.'};

    if ('barnesHutOptimize' in settings &&
        typeof settings.barnesHutOptimize !== 'boolean')
      return {message: 'the `barnesHutOptimize` setting should be a boolean.'};

    if ('barnesHutTheta' in settings &&
        typeof settings.barnesHutTheta !== 'number' &&
        settings.barnesHutTheta < 0)
      return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};

    return null;
  };

  /**
   * Function generating a flat matrix for both nodes & edges of the given graph.
   *
   * @param  {Graph}  graph - Target graph.
   * @return {object}       - Both matrices.
   */
  var graphToByteArrays = function(graph) {
    var nodes = graph.nodes(),
        edges = graph.edges(),
        order = nodes.length,
        size = edges.length,
        index = {},
        i,
        j;

    var NodeMatrix = new Float32Array(order * PPN$1),
        EdgeMatrix = new Float32Array(size * PPE$1);

    // Iterate through nodes
    for (i = j = 0; i < order; i++) {

      // Node index
      index[nodes[i]] = j;

      // Populating byte array
      NodeMatrix[j] = graph.getNodeAttribute(nodes[i], 'x');
      NodeMatrix[j + 1] = graph.getNodeAttribute(nodes[i], 'y');
      NodeMatrix[j + 2] = 0;
      NodeMatrix[j + 3] = 0;
      NodeMatrix[j + 4] = 0;
      NodeMatrix[j + 5] = 0;
      NodeMatrix[j + 6] = 1 + graph.degree(nodes[i]);
      NodeMatrix[j + 7] = 1;
      NodeMatrix[j + 8] = graph.getNodeAttribute(nodes[i], 'size') || 1;
      NodeMatrix[j + 9] = 0;
      j += PPN$1;
    }

    // Iterate through edges
    for (i = j = 0; i < size; i++) {

      // Populating byte array
      EdgeMatrix[j] = index[graph.source(edges[i])];
      EdgeMatrix[j + 1] = index[graph.target(edges[i])];
      EdgeMatrix[j + 2] = graph.getEdgeAttribute(edges[i], 'weight') || 0;
      j += PPE$1;
    }

    return {
      nodes: NodeMatrix,
      edges: EdgeMatrix
    };
  };

  /**
   * Function applying the layout back to the graph.
   *
   * @param {Graph}        graph      - Target graph.
   * @param {Float32Array} NodeMatrix - Node matrix.
   */
  var assignLayoutChanges = function(graph, NodeMatrix) {
    var nodes = graph.nodes();

    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN$1) {
      graph.setNodeAttribute(nodes[j], 'x', NodeMatrix[i]);
      graph.setNodeAttribute(nodes[j], 'y', NodeMatrix[i + 1]);
      j++;
    }
  };

  /**
   * Function collecting the layout positions.
   *
   * @param  {Graph}        graph      - Target graph.
   * @param  {Float32Array} NodeMatrix - Node matrix.
   * @return {object}                  - Map to node positions.
   */
  var collectLayoutChanges = function(graph, NodeMatrix) {
    var nodes = graph.nodes(),
        positions = Object.create(null);

    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN$1) {
      positions[nodes[j]] = {
        x: NodeMatrix[i],
        y: NodeMatrix[i + 1]
      };

      j++;
    }

    return positions;
  };

  var helpers = {
  	assign: assign$1,
  	validateSettings: validateSettings,
  	graphToByteArrays: graphToByteArrays,
  	assignLayoutChanges: assignLayoutChanges,
  	collectLayoutChanges: collectLayoutChanges
  };

  /**
   * Graphology ForceAtlas2 Layout Default Settings
   * ===============================================
   */
  var defaults$1 = {
    linLogMode: false,
    outboundAttractionDistribution: false,
    adjustSizes: false,
    edgeWeightInfluence: 0,
    scalingRatio: 1,
    strongGravityMode: false,
    gravity: 1,
    slowDown: 1,
    barnesHutOptimize: false,
    barnesHutTheta: 0.5
  };

  /**
   * Graphology ForceAtlas2 Layout
   * ==============================
   *
   * Library endpoint.
   */




  /**
   * Asbtract function used to run a certain number of iterations.
   *
   * @param  {boolean}       assign       - Whether to assign positions.
   * @param  {Graph}         graph        - Target graph.
   * @param  {object|number} params       - If number, params.iterations, else:
   * @param  {number}          iterations - Number of iterations.
   * @param  {object}          [settings] - Settings.
   * @return {object|undefined}
   */
  function abstractSynchronousLayout(assign, graph, params) {
    if (!isGraph$1(graph))
      throw new Error('graphology-layout-forceatlas2: the given graph is not a valid graphology instance.');

    if (typeof params === 'number')
      params = {iterations: params};

    var iterations = params.iterations;

    if (typeof iterations !== 'number')
      throw new Error('graphology-layout-forceatlas2: invalid number of iterations.');

    if (iterations <= 0)
      throw new Error('graphology-layout-forceatlas2: you should provide a positive number of iterations.');

    // Validating settings
    var settings = helpers.assign({}, defaults$1, params.settings),
        validationError = helpers.validateSettings(settings);

    if (validationError)
      throw new Error('graphology-layout-forceatlas2: ' + validationError.message);

    // Building matrices
    var matrices = helpers.graphToByteArrays(graph),
        i;

    // Iterating
    for (i = 0; i < iterations; i++)
      iterate(settings, matrices.nodes, matrices.edges);

    // Applying
    if (assign) {
      helpers.assignLayoutChanges(graph, matrices.nodes);
      return;
    }

    return helpers.collectLayoutChanges(graph, matrices.nodes);
  }

  /**
   * Function returning sane layout settings for the given graph.
   *
   * @param  {Graph}  graph - Target graph.
   * @return {object}
   */
  function inferSettings(graph) {
    var order = graph.order;

    return {
      barnesHutOptimize: order > 2000,
      strongGravityMode: true,
      gravity: 0.05,
      scalingRatio: 10,
      slowDown: 1 + Math.log(order)
    };
  }

  /**
   * Exporting.
   */
  var synchronousLayout = abstractSynchronousLayout.bind(null, false);
  synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
  synchronousLayout.inferSettings = inferSettings;

  var graphologyLayoutForceatlas2 = synchronousLayout;

  var worker = createCommonjsModule(function (module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
  	module.exports = factory();
  })(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
  return /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, {
  /******/ 				configurable: false,
  /******/ 				enumerable: true,
  /******/ 				get: getter
  /******/ 			});
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 1);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports) {

  var g;

  // This works in non-strict mode
  g = (function() {
  	return this;
  })();

  try {
  	// This works if eval is allowed (see CSP)
  	g = g || Function("return this")() || (1,eval)("this");
  } catch(e) {
  	// This works if the window reference is available
  	if(typeof window === "object")
  		g = window;
  }

  // g can still be undefined, but nothing to do about it...
  // We return undefined, instead of nothing here, so it's
  // easier to handle this case. if(!global) { ...}

  module.exports = g;


  /***/ }),
  /* 1 */
  /***/ (function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(setImmediate) {/**
   * Graphology ForceAtlas2 Layout Supervisor
   * =========================================
   *
   * Supervisor class able to spawn a web worker to run the FA2 layout in a
   * separate thread not to block UI with heavy synchronous computations.
   */
  var Worker = __webpack_require__(5),
      isGraph = __webpack_require__(7),
      helpers = __webpack_require__(8);

  var DEFAULT_SETTINGS = __webpack_require__(9);

  /**
   * Class representing a FA2 layout run by a webworker.
   *
   * @constructor
   * @param  {Graph}         graph        - Target graph.
   * @param  {object|number} params       - Parameters:
   * @param  {object}          [settings] - Settings.
   */
  function FA2LayoutSupervisor(graph, params) {
    params = params || {};

    // Validation
    if (!isGraph(graph))
      throw new Error('graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance.');

    // Validating settings
    var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings),
        validationError = helpers.validateSettings(settings);

    if (validationError)
      throw new Error('graphology-layout-forceatlas2/worker: ' + validationError.message);

    // Properties
    this.worker = null;
    this.graph = graph;
    this.settings = settings;
    this.matrices = null;
    this.running = false;
    this.killed = false;

    // Binding listeners
    this.handleMessage = this.handleMessage.bind(this);

    var alreadyRespawning = false;
    var self = this;

    this.handleAddition = function() {
      if (alreadyRespawning)
        return;

      alreadyRespawning = true;

      self.spawnWorker();
      setImmediate(function() {
        alreadyRespawning = false;
      });
    };

    graph.on('nodeAdded', this.handleAddition);
    graph.on('edgeAdded', this.handleAddition);

    // Spawning worker
    this.spawnWorker();
  }

  /**
   * Internal method used to spawn the web worker.
   */
  FA2LayoutSupervisor.prototype.spawnWorker = function() {
    if (this.worker)
      this.worker.terminate();

    this.worker = new Worker();
    this.worker.addEventListener('message', this.handleMessage);

    if (this.running) {
      this.running = false;
      this.start();
    }
  };

  /**
   * Internal method used to handle the worker's messages.
   *
   * @param {object} event - Event to handle.
   */
  FA2LayoutSupervisor.prototype.handleMessage = function(event) {
    if (!this.running)
      return;

    var matrix = new Float32Array(event.data.nodes);

    helpers.assignLayoutChanges(this.graph, matrix);
    this.matrices.nodes = matrix;

    // Looping
    this.askForIterations();
  };

  /**
   * Internal method used to ask for iterations from the worker.
   *
   * @param  {boolean} withEdges - Should we send edges along?
   * @return {FA2LayoutSupervisor}
   */
  FA2LayoutSupervisor.prototype.askForIterations = function(withEdges) {
    var matrices = this.matrices;

    var payload = {
      settings: this.settings,
      nodes: matrices.nodes.buffer
    };

    var buffers = [matrices.nodes.buffer];

    if (withEdges) {
      payload.edges = matrices.edges.buffer;
      buffers.push(matrices.edges.buffer);
    }

    this.worker.postMessage(payload, buffers);

    return this;
  };

  /**
   * Method used to start the layout.
   *
   * @return {FA2LayoutSupervisor}
   */
  FA2LayoutSupervisor.prototype.start = function() {
    if (this.killed)
      throw new Error('graphology-layout-forceatlas2/worker.start: layout was killed.');

    if (this.running)
      return this;

    // Building matrices
    this.matrices = helpers.graphToByteArrays(this.graph);

    this.running = true;
    this.askForIterations(true);

    return this;
  };

  /**
   * Method used to stop the layout.
   *
   * @return {FA2LayoutSupervisor}
   */
  FA2LayoutSupervisor.prototype.stop = function() {
    this.running = false;

    return this;
  };

  /**
   * Method used to kill the layout.
   *
   * @return {FA2LayoutSupervisor}
   */
  FA2LayoutSupervisor.prototype.kill = function() {
    if (this.killed)
      return this;

    this.running = false;
    this.killed = true;

    // Clearing memory
    this.matrices = null;

    // Terminating worker
    this.worker.terminate();

    // Unbinding listeners
    this.graph.removeListener('nodeAdded', this.handleAddition);
    this.graph.removeListener('edgeAdded', this.handleAddition);
  };

  /**
   * Exporting.
   */
  module.exports = FA2LayoutSupervisor;

  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).setImmediate));

  /***/ }),
  /* 2 */
  /***/ (function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
              (typeof self !== "undefined" && self) ||
              window;
  var apply = Function.prototype.apply;

  // DOM APIs, for completeness

  exports.setTimeout = function() {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
  };
  exports.setInterval = function() {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
  };
  exports.clearTimeout =
  exports.clearInterval = function(timeout) {
    if (timeout) {
      timeout.close();
    }
  };

  function Timeout(id, clearFn) {
    this._id = id;
    this._clearFn = clearFn;
  }
  Timeout.prototype.unref = Timeout.prototype.ref = function() {};
  Timeout.prototype.close = function() {
    this._clearFn.call(scope, this._id);
  };

  // Does not start the time, just sets up the members needed.
  exports.enroll = function(item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
  };

  exports.unenroll = function(item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
  };

  exports._unrefActive = exports.active = function(item) {
    clearTimeout(item._idleTimeoutId);

    var msecs = item._idleTimeout;
    if (msecs >= 0) {
      item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout)
          item._onTimeout();
      }, msecs);
    }
  };

  // setimmediate attaches itself to the global object
  __webpack_require__(3);
  // On some exotic environments, it's not clear which object `setimmediate` was
  // able to install onto.  Search each possibility in the same order as the
  // `setimmediate` library.
  exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                         (typeof global !== "undefined" && global.setImmediate) ||
                         (this && this.setImmediate);
  exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                           (typeof global !== "undefined" && global.clearImmediate) ||
                           (this && this.clearImmediate);

  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)));

  /***/ }),
  /* 3 */
  /***/ (function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined$1) {

      if (global.setImmediate) {
          return;
      }

      var nextHandle = 1; // Spec says greater than zero
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global.document;
      var registerImmediate;

      function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }

      function clearImmediate(handle) {
          delete tasksByHandle[handle];
      }

      function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
          case 0:
              callback();
              break;
          case 1:
              callback(args[0]);
              break;
          case 2:
              callback(args[0], args[1]);
              break;
          case 3:
              callback(args[0], args[1], args[2]);
              break;
          default:
              callback.apply(undefined$1, args);
              break;
          }
      }

      function runIfPresent(handle) {
          // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
          // So if we're currently running a task, we'll need to delay this invocation.
          if (currentlyRunningATask) {
              // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
              // "too much recursion" error.
              setTimeout(runIfPresent, 0, handle);
          } else {
              var task = tasksByHandle[handle];
              if (task) {
                  currentlyRunningATask = true;
                  try {
                      run(task);
                  } finally {
                      clearImmediate(handle);
                      currentlyRunningATask = false;
                  }
              }
          }
      }

      function installNextTickImplementation() {
          registerImmediate = function(handle) {
              process.nextTick(function () { runIfPresent(handle); });
          };
      }

      function canUsePostMessage() {
          // The test against `importScripts` prevents this implementation from being installed inside a web worker,
          // where `global.postMessage` means something completely different and can't be used for this purpose.
          if (global.postMessage && !global.importScripts) {
              var postMessageIsAsynchronous = true;
              var oldOnMessage = global.onmessage;
              global.onmessage = function() {
                  postMessageIsAsynchronous = false;
              };
              global.postMessage("", "*");
              global.onmessage = oldOnMessage;
              return postMessageIsAsynchronous;
          }
      }

      function installPostMessageImplementation() {
          // Installs an event handler on `global` for the `message` event: see
          // * https://developer.mozilla.org/en/DOM/window.postMessage
          // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
              if (event.source === global &&
                  typeof event.data === "string" &&
                  event.data.indexOf(messagePrefix) === 0) {
                  runIfPresent(+event.data.slice(messagePrefix.length));
              }
          };

          if (global.addEventListener) {
              global.addEventListener("message", onGlobalMessage, false);
          } else {
              global.attachEvent("onmessage", onGlobalMessage);
          }

          registerImmediate = function(handle) {
              global.postMessage(messagePrefix + handle, "*");
          };
      }

      function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
              var handle = event.data;
              runIfPresent(handle);
          };

          registerImmediate = function(handle) {
              channel.port2.postMessage(handle);
          };
      }

      function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
              var script = doc.createElement("script");
              script.onreadystatechange = function () {
                  runIfPresent(handle);
                  script.onreadystatechange = null;
                  html.removeChild(script);
                  script = null;
              };
              html.appendChild(script);
          };
      }

      function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
              setTimeout(runIfPresent, 0, handle);
          };
      }

      // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

      // Don't get fooled by e.g. browserify environments.
      if ({}.toString.call(global.process) === "[object process]") {
          // For Node.js before 0.9
          installNextTickImplementation();

      } else if (canUsePostMessage()) {
          // For non-IE10 modern browsers
          installPostMessageImplementation();

      } else if (global.MessageChannel) {
          // For web workers, where supported
          installMessageChannelImplementation();

      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          // For IE 6–8
          installReadyStateChangeImplementation();

      } else {
          // For older browsers
          installSetTimeoutImplementation();
      }

      attachTo.setImmediate = setImmediate;
      attachTo.clearImmediate = clearImmediate;
  }(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(4)));

  /***/ }),
  /* 4 */
  /***/ (function(module, exports) {

  // shim for using process in browser
  var process = module.exports = {};

  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.

  var cachedSetTimeout;
  var cachedClearTimeout;

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  (function () {
      try {
          if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
          } else {
              cachedSetTimeout = defaultSetTimout;
          }
      } catch (e) {
          cachedSetTimeout = defaultSetTimout;
      }
      try {
          if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
          } else {
              cachedClearTimeout = defaultClearTimeout;
          }
      } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
      }
  } ());
  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }

  process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  };

  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = ''; // empty string to avoid regexp issues
  process.versions = {};

  function noop() {}

  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;

  process.listeners = function (name) { return [] };

  process.binding = function (name) {
      throw new Error('process.binding is not supported');
  };

  process.cwd = function () { return '/' };
  process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
  };
  process.umask = function() { return 0; };


  /***/ }),
  /* 5 */
  /***/ (function(module, exports, __webpack_require__) {

  module.exports = function() {
    return __webpack_require__(6)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Graphology ForceAtlas2 Layout Webworker\n * ========================================\n *\n * Web worker able to run the layout in a separate thread.\n */\nvar iterate = __webpack_require__(1);\n\nvar NODES,\n    EDGES;\n\nself.addEventListener('message', function(event) {\n  var data = event.data;\n\n  NODES = new Float32Array(data.nodes);\n\n  if (data.edges)\n    EDGES = new Float32Array(data.edges);\n\n  // Running the iteration\n  iterate(\n    data.settings,\n    NODES,\n    EDGES\n  );\n\n  // Sending result to supervisor\n  self.postMessage({\n    nodes: NODES.buffer\n  }, [NODES.buffer]);\n});\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n    NODE_Y = 1,\n    NODE_DX = 2,\n    NODE_DY = 3,\n    NODE_OLD_DX = 4,\n    NODE_OLD_DY = 5,\n    NODE_MASS = 6,\n    NODE_CONVERGENCE = 7,\n    NODE_SIZE = 8,\n    NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0,\n    EDGE_TARGET = 1,\n    EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0,\n    REGION_CENTER_X = 1,\n    REGION_CENTER_Y = 2,\n    REGION_SIZE = 3,\n    REGION_NEXT_SIBLING = 4,\n    REGION_FIRST_CHILD = 5,\n    REGION_MASS = 6,\n    REGION_MASS_CENTER_X = 7,\n    REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10,\n    PPE = 3,\n    PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n      size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation,\n      coefficient,\n      xDist,\n      yDist,\n      ewc,\n      distance,\n      factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= (order / PPN);\n  }\n\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n\n    // Setting up\n    var minX = Infinity,\n        maxX = -Infinity,\n        minY = Infinity,\n        maxY = -Infinity,\n        q, q2, subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX, dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    }\n    else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            }\n            else {\n\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          }\n          else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            }\n            else {\n\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] +\n             NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        }\n        else {\n\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          }\n          else {\n\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              }\n              else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            }\n            else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              }\n              else {\n\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              }\n              else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance = (\n            (Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2)) +\n            (Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2))\n          );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n\n            // We treat the region as a single body, and we repulse\n\n            xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  RegionMatrix[r + REGION_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0)\n              break; // No next sibling: we have finished the tree\n\n            continue;\n          }\n          else {\n\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n\n        }\n        else {\n\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] *\n                  NodeMatrix[rn + NODE_MASS] / distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0)\n            break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  }\n  else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n\n          //-- Anticollision Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] += xDist * factor;\n            NodeMatrix[n2 + NODE_DY] += yDist * factor;\n          }\n          else if (distance < 0) {\n            factor = 100 * coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n        else {\n\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor = coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS] /\n              distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(\n      Math.pow(xDist, 2) + Math.pow(yDist, 2)\n    );\n\n    if (options.strongGravityMode) {\n\n      //-- Strong gravity\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    }\n    else {\n\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient = 1 *\n    (options.outboundAttractionDistribution ?\n      outboundAttCompensation :\n      1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n\n      distance = Math.sqrt(\n        (Math.pow(xDist, 2) + Math.pow(yDist, 2)) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE]\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n            distance /\n            NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n          }\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    }\n    else {\n\n      distance = Math.sqrt(\n        Math.pow(xDist, 2) + Math.pow(yDist, 2)\n      );\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        }\n        else {\n\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n        }\n      }\n      else {\n        if (options.outboundAttractionDistribution) {\n\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n        }\n        else {\n\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n\n  // 5) Apply Forces\n  //-----------------\n  var force,\n      swinging,\n      traction,\n      nodespeed,\n      newX,\n      newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n\n    for (n = 0; n < order; n += PPN) {\n      if (!NodeMatrix[n + NODE_FIXED]) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n          Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            NodeMatrix[n + NODE_DX] * MAX_FORCE / force;\n          NodeMatrix[n + NODE_DY] =\n            NodeMatrix[n + NODE_DY] * MAX_FORCE / force;\n        }\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed =\n          0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n  else {\n\n    for (n = 0; n < order; n += PPN) {\n      if (!NodeMatrix[n + NODE_FIXED]) {\n\n        swinging = NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction = Math.sqrt(\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n          (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n          (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n        ) / 2;\n\n        nodespeed = NodeMatrix[n + NODE_CONVERGENCE] *\n          Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] =\n          Math.min(1, Math.sqrt(\n            nodespeed *\n            (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n             Math.pow(NodeMatrix[n + NODE_DY], 2)) /\n            (1 + Math.sqrt(swinging))\n          ));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\n          (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n\n\n/***/ })\n/******/ ]);", null);
  };

  /***/ }),
  /* 6 */
  /***/ (function(module, exports, __webpack_require__) {


  // http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

  var URL = window.URL || window.webkitURL;

  module.exports = function (content, url) {
    try {
      try {
        var blob;

        try {
          // BlobBuilder = Deprecated, but widely implemented
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

          blob = new BlobBuilder();

          blob.append(content);

          blob = blob.getBlob();
        } catch (e) {
          // The proposed API
          blob = new Blob([content]);
        }

        return new Worker(URL.createObjectURL(blob));
      } catch (e) {
        return new Worker('data:application/javascript,' + encodeURIComponent(content));
      }
    } catch (e) {
      if (!url) {
        throw Error('Inline worker is not supported');
      }

      return new Worker(url);
    }
  };

  /***/ }),
  /* 7 */
  /***/ (function(module, exports) {

  /**
   * Graphology isGraph
   * ===================
   *
   * Very simple function aiming at ensuring the given variable is a
   * graphology instance.
   */

  /**
   * Checking the value is a graphology instance.
   *
   * @param  {any}     value - Target value.
   * @return {boolean}
   */
  module.exports = function isGraph(value) {
    return (
      value !== null &&
      typeof value === 'object' &&
      typeof value.addUndirectedEdgeWithKey === 'function' &&
      typeof value.dropNode === 'function' &&
      typeof value.multi === 'boolean'
    );
  };


  /***/ }),
  /* 8 */
  /***/ (function(module, exports) {

  /**
   * Graphology ForceAtlas2 Helpers
   * ===============================
   *
   * Miscellaneous helper functions.
   */

  /**
   * Constants.
   */
  var PPN = 10,
      PPE = 3;

  /**
   * Very simple Object.assign-like function.
   *
   * @param  {object} target       - First object.
   * @param  {object} [...objects] - Objects to merge.
   * @return {object}
   */
  exports.assign = function(target) {
    target = target || {};

    var objects = Array.prototype.slice.call(arguments).slice(1),
        i,
        k,
        l;

    for (i = 0, l = objects.length; i < l; i++) {
      if (!objects[i])
        continue;

      for (k in objects[i])
        target[k] = objects[i][k];
    }

    return target;
  };

  /**
   * Function used to validate the given settings.
   *
   * @param  {object}      settings - Settings to validate.
   * @return {object|null}
   */
  exports.validateSettings = function(settings) {

    if ('linLogMode' in settings &&
        typeof settings.linLogMode !== 'boolean')
      return {message: 'the `linLogMode` setting should be a boolean.'};

    if ('outboundAttractionDistribution' in settings &&
        typeof settings.outboundAttractionDistribution !== 'boolean')
      return {message: 'the `outboundAttractionDistribution` setting should be a boolean.'};

    if ('adjustSizes' in settings &&
        typeof settings.adjustSizes !== 'boolean')
      return {message: 'the `adjustSizes` setting should be a boolean.'};

    if ('edgeWeightInfluence' in settings &&
        typeof settings.edgeWeightInfluence !== 'number' &&
        settings.edgeWeightInfluence < 0)
      return {message: 'the `edgeWeightInfluence` setting should be a number >= 0.'};

    if ('scalingRatio' in settings &&
        typeof settings.scalingRatio !== 'number' &&
        settings.scalingRatio < 0)
      return {message: 'the `scalingRatio` setting should be a number >= 0.'};

    if ('strongGravityMode' in settings &&
        typeof settings.strongGravityMode !== 'boolean')
      return {message: 'the `strongGravityMode` setting should be a boolean.'};

    if ('gravity' in settings &&
        typeof settings.gravity !== 'number' &&
        settings.gravity < 0)
      return {message: 'the `gravity` setting should be a number >= 0.'};

    if ('slowDown' in settings &&
        typeof settings.slowDown !== 'number' &&
        settings.slowDown < 0)
      return {message: 'the `slowDown` setting should be a number >= 0.'};

    if ('barnesHutOptimize' in settings &&
        typeof settings.barnesHutOptimize !== 'boolean')
      return {message: 'the `barnesHutOptimize` setting should be a boolean.'};

    if ('barnesHutTheta' in settings &&
        typeof settings.barnesHutTheta !== 'number' &&
        settings.barnesHutTheta < 0)
      return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};

    return null;
  };

  /**
   * Function generating a flat matrix for both nodes & edges of the given graph.
   *
   * @param  {Graph}  graph - Target graph.
   * @return {object}       - Both matrices.
   */
  exports.graphToByteArrays = function(graph) {
    var nodes = graph.nodes(),
        edges = graph.edges(),
        order = nodes.length,
        size = edges.length,
        index = {},
        i,
        j;

    var NodeMatrix = new Float32Array(order * PPN),
        EdgeMatrix = new Float32Array(size * PPE);

    // Iterate through nodes
    for (i = j = 0; i < order; i++) {

      // Node index
      index[nodes[i]] = j;

      // Populating byte array
      NodeMatrix[j] = graph.getNodeAttribute(nodes[i], 'x');
      NodeMatrix[j + 1] = graph.getNodeAttribute(nodes[i], 'y');
      NodeMatrix[j + 2] = 0;
      NodeMatrix[j + 3] = 0;
      NodeMatrix[j + 4] = 0;
      NodeMatrix[j + 5] = 0;
      NodeMatrix[j + 6] = 1 + graph.degree(nodes[i]);
      NodeMatrix[j + 7] = 1;
      NodeMatrix[j + 8] = graph.getNodeAttribute(nodes[i], 'size') || 1;
      NodeMatrix[j + 9] = 0;
      j += PPN;
    }

    // Iterate through edges
    for (i = j = 0; i < size; i++) {

      // Populating byte array
      EdgeMatrix[j] = index[graph.source(edges[i])];
      EdgeMatrix[j + 1] = index[graph.target(edges[i])];
      EdgeMatrix[j + 2] = graph.getEdgeAttribute(edges[i], 'weight') || 0;
      j += PPE;
    }

    return {
      nodes: NodeMatrix,
      edges: EdgeMatrix
    };
  };

  /**
   * Function applying the layout back to the graph.
   *
   * @param {Graph}        graph      - Target graph.
   * @param {Float32Array} NodeMatrix - Node matrix.
   */
  exports.assignLayoutChanges = function(graph, NodeMatrix) {
    var nodes = graph.nodes();

    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {
      graph.setNodeAttribute(nodes[j], 'x', NodeMatrix[i]);
      graph.setNodeAttribute(nodes[j], 'y', NodeMatrix[i + 1]);
      j++;
    }
  };

  /**
   * Function collecting the layout positions.
   *
   * @param  {Graph}        graph      - Target graph.
   * @param  {Float32Array} NodeMatrix - Node matrix.
   * @return {object}                  - Map to node positions.
   */
  exports.collectLayoutChanges = function(graph, NodeMatrix) {
    var nodes = graph.nodes(),
        positions = Object.create(null);

    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {
      positions[nodes[j]] = {
        x: NodeMatrix[i],
        y: NodeMatrix[i + 1]
      };

      j++;
    }

    return positions;
  };


  /***/ }),
  /* 9 */
  /***/ (function(module, exports) {

  /**
   * Graphology ForceAtlas2 Layout Default Settings
   * ===============================================
   */
  module.exports = {
    linLogMode: false,
    outboundAttractionDistribution: false,
    adjustSizes: false,
    edgeWeightInfluence: 0,
    scalingRatio: 1,
    strongGravityMode: false,
    gravity: 1,
    slowDown: 1,
    barnesHutOptimize: false,
    barnesHutTheta: 0.5
  };


  /***/ })
  /******/ ]);
  });
  });

  var FA2Layout = unwrapExports(worker);

  /**
   * Graphology Extent
   * ==================
   *
   * Simple function returning the extent of selected attributes of the graph.
   */


  /**
   * Function returning the extent of the selected node attributes.
   *
   * @param  {Graph}        graph     - Target graph.
   * @param  {string|array} attribute - Single or multiple attributes.
   * @return {array|object}
   */
  function nodeExtent(graph, attribute) {
    if (!isGraph$1(graph))
      throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');

    var attributes = [].concat(attribute);

    var nodes = graph.nodes(),
        node,
        data,
        value,
        key,
        a,
        i,
        l;

    var results = {};

    for (a = 0; a < attributes.length; a++) {
      key = attributes[a];

      results[key] = [Infinity, -Infinity];
    }

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      data = graph.getNodeAttributes(node);

      for (a = 0; a < attributes.length; a++) {
        key = attributes[a];
        value = data[key];

        if (value < results[key][0])
          results[key][0] = value;

        if (value > results[key][1])
          results[key][1] = value;
      }
    }

    return typeof attribute === 'string' ? results[attribute] : results;
  }

  /**
   * Function returning the extent of the selected edge attributes.
   *
   * @param  {Graph}        graph     - Target graph.
   * @param  {string|array} attribute - Single or multiple attributes.
   * @return {array|object}
   */
  function edgeExtent(graph, attribute) {
    if (!isGraph$1(graph))
      throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');

    var attributes = [].concat(attribute);

    var edges = graph.edges(),
        edge,
        data,
        value,
        key,
        a,
        i,
        l;

    var results = {};

    for (a = 0; a < attributes.length; a++) {
      key = attributes[a];

      results[key] = [Infinity, -Infinity];
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edge = edges[i];
      data = graph.getEdgeAttributes(edge);

      for (a = 0; a < attributes.length; a++) {
        key = attributes[a];
        value = data[key];

        if (value < results[key][0])
          results[key][0] = value;

        if (value > results[key][1])
          results[key][1] = value;
      }
    }

    return typeof attribute === 'string' ? results[attribute] : results;
  }

  /**
   * Exporting.
   */
  var extent = nodeExtent;
  extent.nodeExtent = nodeExtent;
  extent.edgeExtent = edgeExtent;

  var extent_1 = extent;

  var renderer = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * Renderer class.
   *
   * @constructor
   */
  var Renderer =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Renderer, _EventEmitter);

    function Renderer() {
      _classCallCheck(this, Renderer);

      return _possibleConstructorReturn(this, _getPrototypeOf(Renderer).apply(this, arguments));
    }

    return Renderer;
  }(EventEmitter.EventEmitter);

  exports["default"] = Renderer;
  });

  unwrapExports(renderer);

  var easings = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.cubicInOut = exports.cubicOut = exports.cubicIn = exports.quadraticInOut = exports.quadraticOut = exports.quadraticIn = exports.linear = void 0;

  /**
   * Sigma.js Easings
   * =================
   *
   * Handy collection of easing functions.
   */
  var linear = function linear(k) {
    return k;
  };

  exports.linear = linear;

  var quadraticIn = function quadraticIn(k) {
    return k * k;
  };

  exports.quadraticIn = quadraticIn;

  var quadraticOut = function quadraticOut(k) {
    return k * (2 - k);
  };

  exports.quadraticOut = quadraticOut;

  var quadraticInOut = function quadraticInOut(k) {
    if ((k *= 2) < 1) return 0.5 * k * k;
    return -0.5 * (--k * (k - 2) - 1);
  };

  exports.quadraticInOut = quadraticInOut;

  var cubicIn = function cubicIn(k) {
    return k * k * k;
  };

  exports.cubicIn = cubicIn;

  var cubicOut = function cubicOut(k) {
    return --k * k * k + 1;
  };

  exports.cubicOut = cubicOut;

  var cubicInOut = function cubicInOut(k) {
    if ((k *= 2) < 1) return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };

  exports.cubicInOut = cubicInOut;
  });

  unwrapExports(easings);
  var easings_1 = easings.cubicInOut;
  var easings_2 = easings.cubicOut;
  var easings_3 = easings.cubicIn;
  var easings_4 = easings.quadraticInOut;
  var easings_5 = easings.quadraticOut;
  var easings_6 = easings.quadraticIn;
  var easings_7 = easings.linear;

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isPlainObject = isPlainObject;
  exports.assign = assign;

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /**
   * Sigma.js Utils
   * ===============
   *
   * Various helper functions & classes used throughout the library.
   */

  /**
   * Checks whether the given value is a plain object.
   *
   * @param  {mixed}   value - Target value.
   * @return {boolean}
   */
  function isPlainObject(value) {
    return _typeof(value) === 'object' && value !== null && value.constructor === Object;
  }
  /**
   * Very simple recursive Object.assign-like function.
   *
   * @param  {object} target       - First object.
   * @param  {object} [...objects] - Objects to merge.
   * @return {object}
   */


  function assign(target) {
    target = target || {};

    for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {
      var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
      if (!o) continue;

      for (var k in o) {
        if (isPlainObject(o[k])) {
          target[k] = assign(target[k], o[k]);
        } else {
          target[k] = o[k];
        }
      }
    }

    return target;
  }
  });

  unwrapExports(utils);
  var utils_1 = utils.isPlainObject;
  var utils_2 = utils.assign;

  var camera = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var easings$1 = _interopRequireWildcard(easings);



  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * Defaults.
   */
  var ANIMATE_DEFAULTS = {
    easing: 'quadraticInOut',
    duration: 150
  };
  var DEFAULT_ZOOMING_RATIO = 1.5; // TODO: animate options = number polymorphism?
  // TODO: pan, zoom, unzoom, reset, rotate, zoomTo
  // TODO: add width / height to camera and add #.resize
  // TODO: bind camera to renderer rather than sigma
  // TODO: add #.graphToDisplay, #.displayToGraph, batch methods later

  /**
   * Camera class
   *
   * @constructor
   */

  var Camera =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Camera, _EventEmitter);

    function Camera() {
      var _this;

      _classCallCheck(this, Camera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this)); // Properties

      _this.x = 0.5;
      _this.y = 0.5;
      _this.angle = 0;
      _this.ratio = 1; // State

      _this.nextFrame = null;
      _this.previousState = _this.getState();
      _this.enabled = true;
      return _this;
    }
    /**
     * Method used to enable the camera.
     *
     * @return {Camera}
     */


    _createClass(Camera, [{
      key: "enable",
      value: function enable() {
        this.enabled = true;
        return this;
      }
      /**
       * Method used to disable the camera.
       *
       * @return {Camera}
       */

    }, {
      key: "disable",
      value: function disable() {
        this.enabled = false;
        return this;
      }
      /**
       * Method used to retrieve the camera's current state.
       *
       * @return {object}
       */

    }, {
      key: "getState",
      value: function getState() {
        return {
          x: this.x,
          y: this.y,
          angle: this.angle,
          ratio: this.ratio
        };
      }
      /**
       * Method used to retrieve the camera's previous state.
       *
       * @return {object}
       */

    }, {
      key: "getPreviousState",
      value: function getPreviousState() {
        var state = this.previousState;
        return {
          x: state.x,
          y: state.y,
          angle: state.angle,
          ratio: state.ratio
        };
      }
      /**
       * Method used to check whether the camera is currently being animated.
       *
       * @return {boolean}
       */

    }, {
      key: "isAnimated",
      value: function isAnimated() {
        return !!this.nextFrame;
      }
      /**
       * Method returning the coordinates of a point from the graph frame to the
       * viewport.
       *
       * @param  {object} dimensions - Dimensions of the viewport.
       * @param  {number} x          - The X coordinate.
       * @param  {number} y          - The Y coordinate.
       * @return {object}            - The point coordinates in the viewport.
       */
      // TODO: assign to gain one object
      // TODO: angles

    }, {
      key: "graphToViewport",
      value: function graphToViewport(dimensions, x, y) {
        var smallestDimension = Math.min(dimensions.width, dimensions.height);
        var dx = smallestDimension / dimensions.width,
            dy = smallestDimension / dimensions.height; // TODO: we keep on the upper left corner!
        // TODO: how to normalize sizes?

        return {
          x: (x - this.x + this.ratio / 2 / dx) * (smallestDimension / this.ratio),
          y: (this.y - y + this.ratio / 2 / dy) * (smallestDimension / this.ratio)
        };
      }
      /**
       * Method returning the coordinates of a point from the viewport frame to the
       * graph frame.
       *
       * @param  {object} dimensions - Dimensions of the viewport.
       * @param  {number} x          - The X coordinate.
       * @param  {number} y          - The Y coordinate.
       * @return {object}            - The point coordinates in the graph frame.
       */
      // TODO: angles

    }, {
      key: "viewportToGraph",
      value: function viewportToGraph(dimensions, x, y) {
        var smallestDimension = Math.min(dimensions.width, dimensions.height);
        var dx = smallestDimension / dimensions.width,
            dy = smallestDimension / dimensions.height;
        return {
          x: this.ratio / smallestDimension * x + this.x - this.ratio / 2 / dx,
          y: -(this.ratio / smallestDimension * y - this.y - this.ratio / 2 / dy)
        };
      }
      /**
       * Method returning the abstract rectangle containing the graph according
       * to the camera's state.
       *
       * @return {object} - The view's rectangle.
       */
      // TODO: angle

    }, {
      key: "viewRectangle",
      value: function viewRectangle(dimensions) {
        // TODO: reduce relative margin?
        var marginX = 0 * dimensions.width / 8,
            marginY = 0 * dimensions.height / 8;
        var p1 = this.viewportToGraph(dimensions, 0 - marginX, 0 - marginY),
            p2 = this.viewportToGraph(dimensions, dimensions.width + marginX, 0 - marginY),
            h = this.viewportToGraph(dimensions, 0, dimensions.height + marginY);
        return {
          x1: p1.x,
          y1: p1.y,
          x2: p2.x,
          y2: p2.y,
          height: p2.y - h.y
        };
      }
      /**
       * Method used to set the camera's state.
       *
       * @param  {object} state - New state.
       * @return {Camera}
       */

    }, {
      key: "setState",
      value: function setState(state) {
        if (!this.enabled) return this; // TODO: validations
        // TODO: update by function
        // Keeping track of last state

        this.previousState = this.getState();
        if ('x' in state) this.x = state.x;
        if ('y' in state) this.y = state.y;
        if ('angle' in state) this.angle = state.angle;
        if ('ratio' in state) this.ratio = state.ratio; // Emitting
        // TODO: don't emit if nothing changed?

        this.emit('updated', this.getState());
        return this;
      }
      /**
       * Method used to animate the camera.
       *
       * @param  {object}   state      - State to reach eventually.
       * @param  {object}   options    - Options:
       * @param  {number}     duration - Duration of the animation.
       * @param  {function} callback   - Callback
       * @return {function}            - Return a function to cancel the animation.
       */

    }, {
      key: "animate",
      value: function animate(state, options, callback) {
        var _this2 = this;

        if (!this.enabled) return this; // TODO: validation

        options = (0, utils.assign)({}, ANIMATE_DEFAULTS, options);
        var easing = typeof options.easing === 'function' ? options.easing : easings$1[options.easing]; // Canceling previous animation if needed

        if (this.nextFrame) cancelAnimationFrame(this.nextFrame); // State

        var start = Date.now(),
            initialState = this.getState(); // Function performing the animation

        var fn = function fn() {
          var t = (Date.now() - start) / options.duration; // The animation is over:

          if (t >= 1) {
            _this2.nextFrame = null;

            _this2.setState(state);

            if (typeof callback === 'function') callback();
            return;
          }

          var coefficient = easing(t);
          var newState = {};
          if ('x' in state) newState.x = initialState.x + (state.x - initialState.x) * coefficient;
          if ('y' in state) newState.y = initialState.y + (state.y - initialState.y) * coefficient;
          if ('angle' in state) newState.angle = initialState.angle + (state.angle - initialState.angle) * coefficient;
          if ('ratio' in state) newState.ratio = initialState.ratio + (state.ratio - initialState.ratio) * coefficient;

          _this2.setState(newState);

          _this2.nextFrame = requestAnimationFrame(fn);
        };

        if (this.nextFrame) {
          cancelAnimationFrame(this.nextFrame);
          this.nextFrame = requestAnimationFrame(fn);
        } else {
          fn();
        }
      }
      /**
       * Method used to zoom the camera.
       *
       * @param  {number|object} factorOrOptions - Factor or options.
       * @return {function}
       */

    }, {
      key: "animatedZoom",
      value: function animatedZoom(factorOrOptions) {
        if (!factorOrOptions) {
          return this.animate({
            ratio: this.ratio / DEFAULT_ZOOMING_RATIO
          });
        } else {
          if (typeof factorOrOptions === 'number') return this.animate({
            ratio: this.ratio / factorOrOptions
          });else return this.animate({
            ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
          }, factorOrOptions);
        }
      }
      /**
       * Method used to unzoom the camera.
       *
       * @param  {number|object} factorOrOptions - Factor or options.
       * @return {function}
       */

    }, {
      key: "animatedUnzoom",
      value: function animatedUnzoom(factorOrOptions) {
        if (!factorOrOptions) {
          return this.animate({
            ratio: this.ratio * DEFAULT_ZOOMING_RATIO
          });
        } else {
          if (typeof factorOrOptions === 'number') return this.animate({
            ratio: this.ratio * factorOrOptions
          });else return this.animate({
            ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
          }, factorOrOptions);
        }
      }
      /**
       * Method used to reset the camera.
       *
       * @param  {object} options - Options.
       * @return {function}
       */

    }, {
      key: "animatedReset",
      value: function animatedReset(options) {
        return this.animate({
          x: 0.5,
          y: 0.5,
          ratio: 1,
          angle: 0
        }, options);
      }
    }]);

    return Camera;
  }(EventEmitter.EventEmitter);

  exports["default"] = Camera;
  });

  unwrapExports(camera);

  var captor = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var Captor =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Captor, _EventEmitter);

    function Captor(container, camera) {
      var _this;

      _classCallCheck(this, Captor);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Captor).call(this)); // Properties

      _this.container = container;
      _this.camera = camera;
      return _this;
    }

    return Captor;
  }(EventEmitter.EventEmitter);

  exports["default"] = Captor;
  });

  unwrapExports(captor);

  var utils$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createElement = createElement;
  exports.getPixelRatio = getPixelRatio;
  exports.createNormalizationFunction = createNormalizationFunction;

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  /**
   * Sigma.js Rendering Utils
   * ===========================
   *
   * Helpers used by most renderers.
   */

  /**
   * Function used to create DOM elements easily.
   *
   * @param  {string} tag        - Tag name of the element to create.
   * @param  {object} attributes - Attributes map.
   * @return {HTMLElement}
   */
  function createElement(tag, attributes) {
    var element = document.createElement(tag);
    if (!attributes) return element;

    for (var k in attributes) {
      if (k === 'style') {
        for (var s in attributes[k]) {
          element.style[s] = attributes[k][s];
        }
      } else {
        element.setAttribute(k, attributes[k]);
      }
    }

    return element;
  }
  /**
   * Function returning the browser's pixel ratio.
   *
   * @return {number}
   */


  function getPixelRatio() {
    var screen = window.screen;
    if (typeof screen.deviceXDPI !== 'undefined' && typeof screen.logicalXDPI !== 'undefined' && screen.deviceXDPI > screen.logicalXDPI) return screen.systemXDPI / screen.logicalXDPI;else if (typeof window.devicePixelRatio !== 'undefined') return window.devicePixelRatio;
    return 1;
  }
  /**
   * Factory returning a function normalizing the given node's position & size.
   *
   * @param  {object}   extent  - Extent of the graph.
   * @return {function}
   */


  function createNormalizationFunction(extent) {
    var _extent$x = _slicedToArray(extent.x, 2),
        minX = _extent$x[0],
        maxX = _extent$x[1],
        _extent$y = _slicedToArray(extent.y, 2),
        minY = _extent$y[0],
        maxY = _extent$y[1];

    var ratio = Math.max(maxX - minX, maxY - minY);
    if (ratio === 0) ratio = 1;
    var dX = (maxX + minX) / 2,
        dY = (maxY + minY) / 2;

    var fn = function fn(data) {
      return {
        x: 0.5 + (data.x - dX) / ratio,
        y: 0.5 + (data.y - dY) / ratio
      };
    }; // TODO: possibility to apply this in batch over array of indices


    fn.applyTo = function (data) {
      data.x = 0.5 + (data.x - dX) / ratio;
      data.y = 0.5 + (data.y - dY) / ratio;
    };

    fn.inverse = function (data) {
      return {
        x: dX + ratio * (data.x - 0.5),
        y: dY + ratio * (data.y - 0.5)
      };
    };

    fn.ratio = ratio;
    return fn;
  }
  });

  unwrapExports(utils$1);
  var utils_1$1 = utils$1.createElement;
  var utils_2$1 = utils$1.getPixelRatio;
  var utils_3 = utils$1.createNormalizationFunction;

  var utils$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getX = getX;
  exports.getY = getY;
  exports.getWidth = getWidth;
  exports.getHeight = getHeight;
  exports.getCenter = getCenter;
  exports.getMouseCoords = getMouseCoords;
  exports.getWheelDelta = getWheelDelta;



  /**
   * Sigma.js Captor Utils
   * ======================
   *
   * Miscellenous helper functions related to the captors.
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {number}     The local X value of the mouse.
   */
  function getX(e) {
    if (typeof e.offsetX !== 'undefined') return e.offsetX;
    if (typeof e.layerX !== 'undefined') return e.layerX;
    if (typeof e.clientX !== 'undefined') return e.clientX;
    throw new Error('sigma/captors/utils.getX: could not extract x from event.');
  }
  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {number}     The local Y value of the mouse.
   */


  function getY(e) {
    if (typeof e.offsetY !== 'undefined') return e.offsetY;
    if (typeof e.layerY !== 'undefined') return e.layerY;
    if (typeof e.clientY !== 'undefined') return e.clientY;
    throw new Error('sigma/captors/utils.getY: could not extract y from event.');
  }
  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {number}     The width of the event's target.
   */


  function getWidth(e) {
    var w = !e.target.ownerSVGElement ? e.target.width : e.target.ownerSVGElement.width;
    if (typeof w === 'number') return w;
    if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;
    throw new Error('sigma/captors/utils.getWidth: could not extract width from event.');
  }
  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {number}     The height of the event's target.
   */


  function getHeight(e) {
    var w = !e.target.ownerSVGElement ? e.target.height : e.target.ownerSVGElement.height;
    if (typeof w === 'number') return w;
    if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;
    throw new Error('sigma/captors/utils.getHeight: could not extract height from event.');
  }
  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {object}     The center of the event's target.
   */


  function getCenter(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 : (0, utils$1.getPixelRatio)();
    return {
      x: getWidth(e) / (2 * ratio),
      y: getHeight(e) / (2 * ratio)
    };
  }
  /**
   * Convert mouse coords to sigma coords.
   *
   * @param  {event}   e   - A mouse or touch event.
   * @param  {number}  [x] - The x coord to convert
   * @param  {number}  [y] - The y coord to convert
   *
   * @return {object}
   */


  function getMouseCoords(e) {
    return {
      x: getX(e),
      y: getY(e),
      clientX: e.clientX,
      clientY: e.clientY,
      ctrlKey: e.ctrlKey,
      metaKey: e.metaKey,
      altKey: e.altKey,
      shiftKey: e.shiftKey
    };
  }
  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e - A mouse or touch event.
   * @return {number}     The wheel delta of the mouse.
   */


  function getWheelDelta(e) {
    if (typeof e.wheelDelta !== 'undefined') return e.wheelDelta / 360;
    if (typeof e.detail !== 'undefined') return e.detail / -9;
    throw new Error('sigma/captors/utils.getDelta: could not extract delta from event.');
  }
  });

  unwrapExports(utils$2);
  var utils_1$2 = utils$2.getX;
  var utils_2$2 = utils$2.getY;
  var utils_3$1 = utils$2.getWidth;
  var utils_4 = utils$2.getHeight;
  var utils_5 = utils$2.getCenter;
  var utils_6 = utils$2.getMouseCoords;
  var utils_7 = utils$2.getWheelDelta;

  var mouse = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _camera = _interopRequireDefault(camera);

  var _captor = _interopRequireDefault(captor);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * Constants.
   */
  var DRAG_TIMEOUT = 200,
      MOUSE_INERTIA_DURATION = 200,
      MOUSE_INERTIA_RATIO = 3,
      MOUSE_ZOOM_DURATION = 200,
      ZOOMING_RATIO = 1.7,
      DOUBLE_CLICK_TIMEOUT = 300,
      DOUBLE_CLICK_ZOOMING_RATIO = 2.2,
      DOUBLE_CLICK_ZOOMING_DURATION = 200;
  /**
   * Mouse captor class.
   *
   * @constructor
   */

  var MouseCaptor =
  /*#__PURE__*/
  function (_Captor) {
    _inherits(MouseCaptor, _Captor);

    function MouseCaptor(container, camera) {
      var _this;

      _classCallCheck(this, MouseCaptor);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MouseCaptor).call(this, container, camera)); // Properties

      _this.container = container;
      _this.camera = camera; // State

      _this.enabled = true;
      _this.hasDragged = false;
      _this.downStartTime = null;
      _this.lastMouseX = null;
      _this.lastMouseY = null;
      _this.isMouseDown = false;
      _this.isMoving = false;
      _this.movingTimeout = null;
      _this.startCameraState = null;
      _this.lastCameraState = null;
      _this.clicks = 0;
      _this.doubleClickTimeout = null;
      _this.wheelLock = false; // Binding methods

      _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
      _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));
      _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));
      _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));
      _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));
      _this.handleOut = _this.handleOut.bind(_assertThisInitialized(_this)); // Binding events

      container.addEventListener('click', _this.handleClick, false);
      container.addEventListener('mousedown', _this.handleDown, false);
      container.addEventListener('mousemove', _this.handleMove, false);
      container.addEventListener('DOMMouseScroll', _this.handleWheel, false);
      container.addEventListener('mousewheel', _this.handleWheel, false);
      container.addEventListener('mouseout', _this.handleOut, false);
      document.addEventListener('mouseup', _this.handleUp, false);
      return _this;
    }

    _createClass(MouseCaptor, [{
      key: "kill",
      value: function kill() {
        var container = this.container;
        container.removeEventListener('click', this.handleClick);
        container.removeEventListener('mousedown', this.handleDown);
        container.removeEventListener('mousemove', this.handleMove);
        container.removeEventListener('DOMMouseScroll', this.handleWheel);
        container.removeEventListener('mousewheel', this.handleWheel);
        container.removeEventListener('mouseout', this.handleOut);
        document.removeEventListener('mouseup', this.handleUp);
      }
    }, {
      key: "handleClick",
      value: function handleClick(e) {
        var _this2 = this;

        if (!this.enabled) return;
        this.clicks++;

        if (this.clicks === 2) {
          this.clicks = 0;
          clearTimeout(this.doubleClickTimeout);
          this.doubleClickTimeout = null;
          return this.handleDoubleClick(e);
        }

        setTimeout(function () {
          _this2.clicks = 0;
          _this2.doubleClickTimeout = null;
        }, DOUBLE_CLICK_TIMEOUT); // NOTE: this is here to prevent click events on drag

        if (!this.hasDragged) this.emit('click', (0, utils$2.getMouseCoords)(e));
      }
    }, {
      key: "handleDoubleClick",
      value: function handleDoubleClick(e) {
        if (!this.enabled) return;
        var center = (0, utils$2.getCenter)(e);
        var cameraState = this.camera.getState();
        var newRatio = cameraState.ratio / DOUBLE_CLICK_ZOOMING_RATIO; // TODO: factorize

        var dimensions = {
          width: this.container.offsetWidth,
          height: this.container.offsetHeight
        };
        var clickX = (0, utils$2.getX)(e),
            clickY = (0, utils$2.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy
        // TODO: factorize pan & zoomTo

        var cameraWithNewRatio = new _camera["default"]();
        cameraWithNewRatio.ratio = newRatio;
        cameraWithNewRatio.x = cameraState.x;
        cameraWithNewRatio.y = cameraState.y;
        var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),
            centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);
        var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),
            centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);
        var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,
            deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;
        this.camera.animate({
          x: cameraState.x - deltaX,
          y: cameraState.y - deltaY,
          ratio: newRatio
        }, {
          easing: 'quadraticInOut',
          duration: DOUBLE_CLICK_ZOOMING_DURATION
        });
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        e.stopPropagation();
        return false;
      }
    }, {
      key: "handleDown",
      value: function handleDown(e) {
        if (!this.enabled) return;
        this.startCameraState = this.camera.getState();
        this.lastCameraState = this.startCameraState;
        this.lastMouseX = (0, utils$2.getX)(e);
        this.lastMouseY = (0, utils$2.getY)(e);
        this.hasDragged = false;
        this.downStartTime = Date.now(); // TODO: dispatch events

        switch (e.which) {
          default:
            // Left button pressed
            this.isMouseDown = true;
            this.emit('mousedown', (0, utils$2.getMouseCoords)(e));
        }
      }
    }, {
      key: "handleUp",
      value: function handleUp(e) {
        var _this3 = this;

        if (!this.enabled || !this.isMouseDown) return;
        this.isMouseDown = false;

        if (this.movingTimeout) {
          this.movingTimeout = null;
          clearTimeout(this.movingTimeout);
        }

        var x = (0, utils$2.getX)(e),
            y = (0, utils$2.getY)(e);
        var cameraState = this.camera.getState(),
            previousCameraState = this.camera.getPreviousState();

        if (this.isMoving) {
          this.camera.animate({
            x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),
            y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)
          }, {
            duration: MOUSE_INERTIA_DURATION,
            easing: 'quadraticOut'
          });
        } else if (this.lastMouseX !== x || this.lastMouseY !== y) {
          this.camera.setState({
            x: cameraState.x,
            y: cameraState.y
          });
        }

        this.isMoving = false;
        setImmediate(function () {
          return _this3.hasDragged = false;
        });
        this.emit('mouseup', (0, utils$2.getMouseCoords)(e));
      }
    }, {
      key: "handleMove",
      value: function handleMove(e) {
        var _this4 = this;

        if (!this.enabled) return;
        this.emit('mousemove', (0, utils$2.getMouseCoords)(e));

        if (this.isMouseDown) {
          // TODO: dispatch events
          this.isMoving = true;
          this.hasDragged = true;
          if (this.movingTimeout) clearTimeout(this.movingTimeout);
          this.movingTimeout = setTimeout(function () {
            _this4.movingTimeout = null;
            _this4.isMoving = false;
          }, DRAG_TIMEOUT);
          var dimensions = {
            width: this.container.offsetWidth,
            height: this.container.offsetHeight
          };
          var eX = (0, utils$2.getX)(e),
              eY = (0, utils$2.getY)(e);
          var lastMouse = this.camera.viewportToGraph(dimensions, this.lastMouseX, this.lastMouseY);
          var mouse = this.camera.viewportToGraph(dimensions, eX, eY);
          var offsetX = lastMouse.x - mouse.x,
              offsetY = lastMouse.y - mouse.y;
          var cameraState = this.camera.getState();
          var x = cameraState.x + offsetX,
              y = cameraState.y + offsetY;
          this.camera.setState({
            x: x,
            y: y
          });
          this.lastMouseX = eX;
          this.lastMouseY = eY;
        }

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        e.stopPropagation();
        return false;
      }
    }, {
      key: "handleWheel",
      value: function handleWheel(e) {
        var _this5 = this;

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        e.stopPropagation();
        if (!this.enabled) return false;
        var delta = (0, utils$2.getWheelDelta)(e);
        if (!delta) return false;
        if (this.wheelLock) return false;
        this.wheelLock = true; // TODO: handle max zoom

        var ratio = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;
        var cameraState = this.camera.getState();
        var newRatio = ratio * cameraState.ratio;
        var center = (0, utils$2.getCenter)(e);
        var dimensions = {
          width: this.container.offsetWidth,
          height: this.container.offsetHeight
        };
        var clickX = (0, utils$2.getX)(e),
            clickY = (0, utils$2.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy
        // TODO: factorize pan & zoomTo

        var cameraWithNewRatio = new _camera["default"]();
        cameraWithNewRatio.ratio = newRatio;
        cameraWithNewRatio.x = cameraState.x;
        cameraWithNewRatio.y = cameraState.y;
        var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),
            centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);
        var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),
            centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);
        var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,
            deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;
        this.camera.animate({
          x: cameraState.x - deltaX,
          y: cameraState.y - deltaY,
          ratio: newRatio
        }, {
          easing: 'linear',
          duration: MOUSE_ZOOM_DURATION
        }, function () {
          return _this5.wheelLock = false;
        });
        return false;
      }
    }, {
      key: "handleOut",
      value: function handleOut() {// TODO: dispatch event
      }
    }]);

    return MouseCaptor;
  }(_captor["default"]);

  exports["default"] = MouseCaptor;
  });

  unwrapExports(mouse);

  /**
   * Extend function
   * ================
   *
   * Function used to push a bunch of values into an array at once.
   *
   * Its strategy is to mutate target array's length then setting the new indices
   * to be the values to add.
   *
   * A benchmark proved that it is faster than the following strategies:
   *   1) `array.push.apply(array, values)`.
   *   2) A loop of pushes.
   *   3) `array = array.concat(values)`, obviously.
   *
   * Intuitively, this is correct because when adding a lot of elements, the
   * chosen strategies does not need to handle the `arguments` object to
   * execute #.apply's variadicity and because the array know its final length
   * at the beginning, avoiding potential multiple reallocations of the underlying
   * contiguous array. Some engines may be able to optimize the loop of push
   * operations but empirically they don't seem to do so.
   */

  /**
   * Extends the target array with the given values.
   *
   * @param  {array} array  - Target array.
   * @param  {array} values - Values to add.
   */
  var extend$3 = function extend(array, values) {
    var l2 = values.length;

    if (l2 === 0)
      return;

    var l1 = array.length;

    array.length += l2;

    for (var i = 0; i < l2; i++)
      array[l1 + i] = values[i];
  };

  var quadtree = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _extend = _interopRequireDefault(extend$3);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // TODO: should not ask the quadtree when the camera has the whole graph in
  // sight.
  // TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)
  // TODO: jsdoc
  // TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size
  // TODO: filtering unwanted labels beforehand through the filter function
  // NOTE: this is basically a MX-CIF Quadtree at this point
  // NOTE: need to explore R-Trees for edges
  // NOTE: need to explore 2d segment tree for edges
  // NOTE: probably can do faster using spatial hashing

  /**
   * Constants.
   *
   * Note that since we are representing a static 4-ary tree, the indices of the
   * quadrants are the following:
   *   - TOP_LEFT:     4i + b
   *   - TOP_RIGHT:    4i + 2b
   *   - BOTTOM_LEFT:  4i + 3b
   *   - BOTTOM_RIGHT: 4i + 4b
   */
  var BLOCKS = 4,
      MAX_LEVEL = 5;
  var X_OFFSET = 0,
      Y_OFFSET = 1,
      WIDTH_OFFSET = 2,
      HEIGHT_OFFSET = 3;
  var TOP_LEFT = 1,
      TOP_RIGHT = 2,
      BOTTOM_LEFT = 3,
      BOTTOM_RIGHT = 4;
  /**
   * Geometry helpers.
   */

  /**
   * Function returning whether the given rectangle is axis-aligned.
   *
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {boolean}
   */

  function isAxisAligned(x1, y1, x2, y2) {
    return x1 === x2 || y1 === y2;
  }

  function squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {
    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;
  }

  function rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {
    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;
  }

  function pointIsInQuad(x, y, qx, qy, qw, qh) {
    var xmp = qx + qw / 2,
        ymp = qy + qh / 2,
        top = y < ymp,
        left = x < xmp;
    return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;
  }
  /**
   * Helper functions that are not bound to the class so an external user
   * cannot mess with them.
   */


  function buildQuadrants(maxLevel, data) {
    // [block, level]
    var stack = [0, 0];

    while (stack.length) {
      var level = stack.pop(),
          block = stack.pop();
      var topLeftBlock = 4 * block + BLOCKS,
          topRightBlock = 4 * block + 2 * BLOCKS,
          bottomLeftBlock = 4 * block + 3 * BLOCKS,
          bottomRightBlock = 4 * block + 4 * BLOCKS;
      var x = data[block + X_OFFSET],
          y = data[block + Y_OFFSET],
          width = data[block + WIDTH_OFFSET],
          height = data[block + HEIGHT_OFFSET],
          hw = width / 2,
          hh = height / 2;
      data[topLeftBlock + X_OFFSET] = x;
      data[topLeftBlock + Y_OFFSET] = y;
      data[topLeftBlock + WIDTH_OFFSET] = hw;
      data[topLeftBlock + HEIGHT_OFFSET] = hh;
      data[topRightBlock + X_OFFSET] = x + hw;
      data[topRightBlock + Y_OFFSET] = y;
      data[topRightBlock + WIDTH_OFFSET] = hw;
      data[topRightBlock + HEIGHT_OFFSET] = hh;
      data[bottomLeftBlock + X_OFFSET] = x;
      data[bottomLeftBlock + Y_OFFSET] = y + hh;
      data[bottomLeftBlock + WIDTH_OFFSET] = hw;
      data[bottomLeftBlock + HEIGHT_OFFSET] = hh;
      data[bottomRightBlock + X_OFFSET] = x + hw;
      data[bottomRightBlock + Y_OFFSET] = y + hh;
      data[bottomRightBlock + WIDTH_OFFSET] = hw;
      data[bottomRightBlock + HEIGHT_OFFSET] = hh;

      if (level < maxLevel - 1) {
        stack.push(bottomRightBlock, level + 1);
        stack.push(bottomLeftBlock, level + 1);
        stack.push(topRightBlock, level + 1);
        stack.push(topLeftBlock, level + 1);
      }
    }
  }

  function insertNode(maxLevel, data, containers, key, x, y, size) {
    var x1 = x - size,
        y1 = y - size,
        w = size * 2;
    var level = 0,
        block = 0;

    while (true) {
      // If we reached max level
      if (level >= maxLevel) {
        containers[block] = containers[block] || [];
        containers[block].push(key);
        return;
      }

      var topLeftBlock = 4 * block + BLOCKS,
          topRightBlock = 4 * block + 2 * BLOCKS,
          bottomLeftBlock = 4 * block + 3 * BLOCKS,
          bottomRightBlock = 4 * block + 4 * BLOCKS;
      var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);
      var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);
      var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);
      var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);
      var collisions = collidingWithTopLeft + collidingWithTopRight + collidingWithBottomLeft + collidingWithBottomRight; // If we don't have at least a collision, there is an issue

      if (collisions === 0) throw new Error("sigma/quadtree.insertNode: no collision (level: ".concat(level, ", key: ").concat(key, ", x: ").concat(x, ", y: ").concat(y, ", size: ").concat(size, ").")); // If we have 3 collisions, we have a geometry problem obviously

      if (collisions === 3) throw new Error("sigma/quadtree.insertNode: 3 impossible collisions (level: ".concat(level, ", key: ").concat(key, ", x: ").concat(x, ", y: ").concat(y, ", size: ").concat(size, ").")); // If we have more that one collision, we stop here and store the node
      // in the relevant containers

      if (collisions > 1) {
        // NOTE: this is a nice way to optimize for hover, but not for frustum
        // since it requires to uniq the collected nodes
        // if (collisions < 4) {
        //   // If we intersect two quads, we place the node in those two
        //   if (collidingWithTopLeft) {
        //     containers[topLeftBlock] = containers[topLeftBlock] || [];
        //     containers[topLeftBlock].push(key);
        //   }
        //   if (collidingWithTopRight) {
        //     containers[topRightBlock] = containers[topRightBlock] || [];
        //     containers[topRightBlock].push(key);
        //   }
        //   if (collidingWithBottomLeft) {
        //     containers[bottomLeftBlock] = containers[bottomLeftBlock] || [];
        //     containers[bottomLeftBlock].push(key);
        //   }
        //   if (collidingWithBottomRight) {
        //     containers[bottomRightBlock] = containers[bottomRightBlock] || [];
        //     containers[bottomRightBlock].push(key);
        //   }
        // }
        // else {
        //   // Else we keep the node where it is to avoid more pointless computations
        //   containers[block] = containers[block] || [];
        //   containers[block].push(key);
        // }
        containers[block] = containers[block] || [];
        containers[block].push(key);
        return;
      } else {
        level++;
      } // Else we recurse into the correct quads


      if (collidingWithTopLeft) block = topLeftBlock;
      if (collidingWithTopRight) block = topRightBlock;
      if (collidingWithBottomLeft) block = bottomLeftBlock;
      if (collidingWithBottomRight) block = bottomRightBlock;
    }
  }

  function getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {
    // [block, level]
    var stack = [0, 0];
    var collectedNodes = [];
    var container;

    while (stack.length) {
      var level = stack.pop(),
          block = stack.pop(); // Collecting nodes

      container = containers[block];
      if (container) (0, _extend["default"])(collectedNodes, container); // If we reached max level

      if (level >= maxLevel) continue;
      var topLeftBlock = 4 * block + BLOCKS,
          topRightBlock = 4 * block + 2 * BLOCKS,
          bottomLeftBlock = 4 * block + 3 * BLOCKS,
          bottomRightBlock = 4 * block + 4 * BLOCKS;
      var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);
      var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);
      var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);
      var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);
      if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);
      if (collidingWithTopRight) stack.push(topRightBlock, level + 1);
      if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);
      if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);
    }

    return collectedNodes;
  }
  /**
   * QuadTree class.
   *
   * @constructor
   * @param {object} boundaries - The graph boundaries.
   */


  var QuadTree =
  /*#__PURE__*/
  function () {
    function QuadTree(params) {
      _classCallCheck(this, QuadTree);

      params = params || {}; // Allocating the underlying byte array

      var L = Math.pow(4, MAX_LEVEL);
      this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));
      this.containers = {};
      this.cache = null;
      this.lastRectangle = null;
      if (params.boundaries) this.resize(params.boundaries);else this.resize({
        x: 0,
        y: 0,
        width: 1,
        height: 1
      });
      if (typeof params.filter === 'function') this.nodeFilter = params.filter;
    }

    _createClass(QuadTree, [{
      key: "add",
      value: function add(key, x, y, size) {
        insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);
        return this;
      }
    }, {
      key: "resize",
      value: function resize(boundaries) {
        this.clear(); // Building the quadrants

        this.data[X_OFFSET] = boundaries.x;
        this.data[Y_OFFSET] = boundaries.y;
        this.data[WIDTH_OFFSET] = boundaries.width;
        this.data[HEIGHT_OFFSET] = boundaries.height;
        buildQuadrants(MAX_LEVEL, this.data);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.containers = {};
        return this;
      }
    }, {
      key: "point",
      value: function point(x, y) {
        var nodes = [];
        var block = 0,
            level = 0;

        do {
          if (this.containers[block]) nodes.push.apply(nodes, this.containers[block]);
          var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);
          block = 4 * block + quad * BLOCKS;
          level++;
        } while (level <= MAX_LEVEL);

        return nodes;
      }
    }, {
      key: "rectangle",
      value: function rectangle(x1, y1, x2, y2, height) {
        var lr = this.lastRectangle;

        if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {
          return this.cache;
        }

        this.lastRectangle = {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          height: height
        }; // Is the rectangle axis aligned?

        if (!isAxisAligned(x1, y1, x2, y2)) throw new Error('sigma/quadtree.rectangle: shifted view is not yet implemented.');
        var collectedNodes = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);
        this.cache = collectedNodes;
        return this.cache;
      }
    }]);

    return QuadTree;
  }();

  exports["default"] = QuadTree;
  });

  unwrapExports(quadtree);

  var displayData = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EdgeDisplayData = exports.NodeDisplayData = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /**
   * Sigma.js Display Data Classes
   * ==============================
   *
   * Classes representing nodes & edges display data aiming at facilitating
   * the engine's memory representation and keep them in a pool to avoid
   * requiring to allocate memory too often.
   *
   * NOTE: it's possible to optimize this further by maintaining display data
   * in byte arrays but this would prove more tedious for the rendering logic
   * afterwards.
   */
  var NodeDisplayData =
  /*#__PURE__*/
  function () {
    function NodeDisplayData(index, settings) {
      _classCallCheck(this, NodeDisplayData);

      this.index = index;
      this.x = 0;
      this.y = 0;
      this.size = 2;
      this.color = settings.defaultNodeColor;
      this.hidden = false;
      this.label = '';
    }

    _createClass(NodeDisplayData, [{
      key: "assign",
      value: function assign(data) {
        for (var key in data) {
          this[key] = data[key];
        }
      }
    }]);

    return NodeDisplayData;
  }();

  exports.NodeDisplayData = NodeDisplayData;

  var EdgeDisplayData =
  /*#__PURE__*/
  function () {
    function EdgeDisplayData(index, settings) {
      _classCallCheck(this, EdgeDisplayData);

      this.index = index;
      this.size = 1;
      this.color = settings.defaultEdgeColor;
      this.hidden = false;
      this.label = '';
    }

    _createClass(EdgeDisplayData, [{
      key: "assign",
      value: function assign(data) {
        for (var key in data) {
          this[key] = data[key];
        }
      }
    }]);

    return EdgeDisplayData;
  }();

  exports.EdgeDisplayData = EdgeDisplayData;
  });

  unwrapExports(displayData);
  var displayData_1 = displayData.EdgeDisplayData;
  var displayData_2 = displayData.NodeDisplayData;

  var matrices = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.identity = identity;
  exports.scale = scale;
  exports.rotate = rotate;
  exports.translate = translate;
  exports.multiply = multiply;

  /**
   * Sigma.js WebGL Matrices Helpers
   * ================================
   *
   * Matrices-related helper functions used by sigma's WebGL renderer.
   */
  function identity() {
    return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
  } // TODO: optimize


  function scale(m, x, y) {
    m[0] = x;
    m[4] = arguments.length > 2 ? y : x;
    return m;
  }

  function rotate(m, r) {
    var s = Math.sin(r),
        c = Math.cos(r);
    m[0] = c;
    m[1] = s;
    m[3] = -s;
    m[4] = c;
    return m;
  }

  function translate(m, x, y) {
    m[6] = x;
    m[7] = y;
    return m;
  }

  function multiply(a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    a[0] = b00 * a00 + b01 * a10 + b02 * a20;
    a[1] = b00 * a01 + b01 * a11 + b02 * a21;
    a[2] = b00 * a02 + b01 * a12 + b02 * a22;
    a[3] = b10 * a00 + b11 * a10 + b12 * a20;
    a[4] = b10 * a01 + b11 * a11 + b12 * a21;
    a[5] = b10 * a02 + b11 * a12 + b12 * a22;
    a[6] = b20 * a00 + b21 * a10 + b22 * a20;
    a[7] = b20 * a01 + b21 * a11 + b22 * a21;
    a[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return a;
  }
  });

  unwrapExports(matrices);
  var matrices_1 = matrices.identity;
  var matrices_2 = matrices.scale;
  var matrices_3 = matrices.rotate;
  var matrices_4 = matrices.translate;
  var matrices_5 = matrices.multiply;

  var utils$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.floatColor = floatColor;
  exports.matrixFromCamera = matrixFromCamera;
  exports.extractPixel = extractPixel;
  exports.canUse32BitsIndices = canUse32BitsIndices;



  /**
   * Sigma.js WebGL Renderer Utils
   * ==============================
   *
   * Miscelleanous helper functions used by sigma's WebGL renderer.
   */

  /**
   * Memoized function returning a float-encoded color from various string
   * formats describing colors.
   */
  var FLOAT_COLOR_CACHE = {};
  var INT8 = new Int8Array(4);
  var INT32 = new Int32Array(INT8.buffer, 0, 1);
  var FLOAT32 = new Float32Array(INT8.buffer, 0, 1);
  var RGBA_TEST_REGEX = /^\s*rgba?\s*\(/;
  var RGBA_EXTRACT_REGEX = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;

  function floatColor(val) {
    // If the color is already computed, we yield it
    if (typeof FLOAT_COLOR_CACHE[val] !== 'undefined') return FLOAT_COLOR_CACHE[val];
    var r = 0,
        g = 0,
        b = 0,
        a = 1; // Handling hexadecimal notation

    if (val[0] === '#') {
      if (val.length === 4) {
        r = parseInt(val.charAt(1) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(2), 16);
        b = parseInt(val.charAt(3) + val.charAt(3), 16);
      } else {
        r = parseInt(val.charAt(1) + val.charAt(2), 16);
        g = parseInt(val.charAt(3) + val.charAt(4), 16);
        b = parseInt(val.charAt(5) + val.charAt(6), 16);
      }
    } // Handling rgb notation
    else if (RGBA_TEST_REGEX.test(val)) {
        var match = val.match(RGBA_EXTRACT_REGEX);
        r = +match[1];
        g = +match[2];
        b = +match[3];
        if (match[4]) a = +match[4];
      }

    a = a * 255 | 0;
    var bits = (a << 24 | b << 16 | g << 8 | r) & 0xfeffffff;
    INT32[0] = bits;
    var color = FLOAT32[0];
    FLOAT_COLOR_CACHE[val] = color;
    return color;
  }
  /**
   * Function returning a matrix from the current state of the camera.
   */
  // TODO: it's possible to optimize this drastically!


  function matrixFromCamera(state, dimensions) {
    var angle = state.angle,
        ratio = state.ratio,
        x = state.x,
        y = state.y;
    var width = dimensions.width,
        height = dimensions.height;
    var matrix = (0, matrices.identity)();
    var smallestDimension = Math.min(width, height);
    var cameraCentering = (0, matrices.translate)((0, matrices.identity)(), -x, -y),
        cameraScaling = (0, matrices.scale)((0, matrices.identity)(), 1 / ratio),
        cameraRotation = (0, matrices.rotate)((0, matrices.identity)(), -angle),
        viewportScaling = (0, matrices.scale)((0, matrices.identity)(), 2 * (smallestDimension / width), 2 * (smallestDimension / height)); // Logical order is reversed

    (0, matrices.multiply)(matrix, viewportScaling);
    (0, matrices.multiply)(matrix, cameraRotation);
    (0, matrices.multiply)(matrix, cameraScaling);
    (0, matrices.multiply)(matrix, cameraCentering);
    return matrix;
  }
  /**
   * Function extracting the color at the given pixel.
   */


  function extractPixel(gl, x, y, array) {
    var data = array || new Uint8Array(4);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
    return data;
  }
  /**
   * Function used to know whether given webgl context can use 32 bits indices.
   */


  function canUse32BitsIndices(gl) {
    var webgl2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
    return webgl2 || !!gl.getExtension('OES_element_index_uint');
  }
  });

  unwrapExports(utils$3);
  var utils_1$3 = utils$3.floatColor;
  var utils_2$3 = utils$3.matrixFromCamera;
  var utils_3$2 = utils$3.extractPixel;
  var utils_4$1 = utils$3.canUse32BitsIndices;

  var labels = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.labelsToDisplayFromGrid = labelsToDisplayFromGrid;
  exports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;

  var _camera = _interopRequireDefault(camera);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  /**
   * Sigma.js Labels Heuristics
   * ===========================
   *
   * Miscelleneous heuristics related to label display.
   */

  /**
   * Constants.
   */
  // Dimensions of a normal cell
  var DEFAULT_CELL = {
    width: 250,
    height: 175
  }; // Dimensions of an unzoomed cell. This one is usually larger than the normal
  // one to account for the fact that labels will more likely collide.

  var DEFAULT_UNZOOMED_CELL = {
    width: 400,
    height: 300
  };
  /**
   * Helpers.
   */

  function collision(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
  } // TODO: cache camera position of selected nodes to avoid costly computations
  // in anti-collision step
  // TOOD: document a little bit more so future people can understand this mess

  /**
   * Label grid heuristic selecting labels to display.
   *
   * @param  {object} params                 - Parameters:
   * @param  {object}   cache                - Cache storing nodes' data.
   * @param  {Camera}   camera               - The renderer's camera.
   * @param  {Set}      displayedLabels      - Currently displayed labels.
   * @param  {Array}    visibleNodes         - Nodes visible for this render.
   * @param  {Graph}    graph                - The rendered graph.
   * @return {Array}                         - The selected labels.
   */


  function labelsToDisplayFromGrid(params) {
    var cache = params.cache,
        camera = params.camera,
        userCell = params.cell,
        dimensions = params.dimensions,
        displayedLabels = params.displayedLabels,
        _params$fontSize = params.fontSize,
        fontSize = _params$fontSize === void 0 ? 14 : _params$fontSize,
        graph = params.graph,
        _params$renderedSizeT = params.renderedSizeThreshold,
        renderedSizeThreshold = _params$renderedSizeT === void 0 ? -Infinity : _params$renderedSizeT,
        visibleNodes = params.visibleNodes;
    var cameraState = camera.getState(),
        previousCameraState = camera.getPreviousState();
    var previousCamera = new _camera["default"]();
    previousCamera.setState(previousCameraState); // TODO: should factorize. This same code is used quite a lot throughout the codebase
    // TODO: POW RATIO is currently default 0.5 and harcoded

    var sizeRatio = Math.pow(cameraState.ratio, 0.5); // Camera hasn't moved?

    var still = cameraState.x === previousCameraState.x && cameraState.y === previousCameraState.y && cameraState.ratio === previousCameraState.ratio; // State

    var zooming = cameraState.ratio < previousCameraState.ratio,
        panning = cameraState.x !== previousCameraState.x || cameraState.y !== previousCameraState.y,
        unzooming = cameraState.ratio > previousCameraState.ratio,
        unzoomedPanning = !zooming && !unzooming && cameraState.ratio >= 1,
        zoomedPanning = panning && displayedLabels.size && !zooming && !unzooming; // Trick to discretize unzooming

    if (unzooming && Math.trunc(cameraState.ratio * 100) % 5 !== 0) return Array.from(displayedLabels); // If panning while unzoomed, we shouldn't change label selection

    if ((unzoomedPanning || still) && displayedLabels.size !== 0) return Array.from(displayedLabels); // When unzoomed & zooming

    if (zooming && cameraState.ratio >= 1) return Array.from(displayedLabels); // Adapting cell dimensions

    var cell = userCell ? userCell : DEFAULT_CELL;
    if (cameraState.ratio >= 1.3) cell = DEFAULT_UNZOOMED_CELL;
    var cwr = dimensions.width % cell.width;
    var cellWidth = cell.width + cwr / Math.floor(dimensions.width / cell.width);
    var chr = dimensions.height % cell.height;
    var cellHeight = cell.height + chr / Math.floor(dimensions.height / cell.height);
    var adjustedWidth = dimensions.width + cellWidth,
        adjustedHeight = dimensions.height + cellHeight,
        adjustedX = -cellWidth,
        adjustedY = -cellHeight;
    var panningWidth = dimensions.width + cellWidth / 2,
        panningHeight = dimensions.height + cellHeight / 2,
        panningX = -(cellWidth / 2),
        panningY = -(cellHeight / 2); // console.log(cellWidth, cellHeight, dimensions.width / cellWidth, dimensions.height / cellHeight);

    var worthyLabels = [];
    var grid = {};
    var maxSize = -Infinity,
        biggestNode = null;

    for (var i = 0, l = visibleNodes.length; i < l; i++) {
      var node = visibleNodes[i],
          nodeData = cache[node]; // We filter nodes having a rendered size less than a certain thresold

      if (nodeData.size / sizeRatio < renderedSizeThreshold) continue; // Finding our node's cell in the grid

      var pos = camera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Node is not actually visible on screen
      // NOTE: can optimize margin on the right side (only if we know where the labels go)

      if (pos.x < adjustedX || pos.x > adjustedWidth || pos.y < adjustedY || pos.y > adjustedHeight) continue; // Keeping track of the maximum node size for certain cases

      if (nodeData.size > maxSize) {
        maxSize = nodeData.size;
        biggestNode = node;
      } // If panning when zoomed, we consider only displayed labels and newly
      // visible nodes


      if (zoomedPanning) {
        var ppos = previousCamera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Was node visible earlier?

        if (ppos.x >= panningX && ppos.x <= panningWidth && ppos.y >= panningY && ppos.y <= panningHeight) {
          // Was the label displayed?
          if (!displayedLabels.has(node)) continue;
        }
      }

      var xKey = Math.floor(pos.x / cellWidth),
          yKey = Math.floor(pos.y / cellHeight);
      var key = "".concat(xKey, "\xA7").concat(yKey);

      if (typeof grid[key] === 'undefined') {
        // This cell is not yet occupied
        grid[key] = node;
      } else {
        // We must solve a conflict in this cell
        var currentNode = grid[key],
            currentNodeData = cache[currentNode]; // We prefer already displayed labels

        if (displayedLabels.size > 0) {
          var n1 = displayedLabels.has(node),
              n2 = displayedLabels.has(currentNode);

          if (!n1 && n2) {
            continue;
          }

          if (n1 && !n2) {
            grid[key] = node;
            continue;
          }

          if ((zoomedPanning || zooming) && n1 && n2) {
            worthyLabels.push(node);
            continue;
          }
        } // In case of size & degree equality, we use the node's key so that the
        // process remains deterministic


        var won = false;

        if (nodeData.size > currentNodeData.size) {
          won = true;
        } else if (nodeData.size === currentNodeData.size) {
          var nodeDegree = graph.degree(node),
              currentNodeDegree = graph.degree(currentNode);

          if (nodeDegree > currentNodeDegree) {
            won = true;
          } else if (nodeDegree === currentNodeDegree) {
            if (node > currentNode) won = true;
          }
        }

        if (won) grid[key] = node;
      }
    } // Compiling the labels


    var biggestNodeShown = worthyLabels.some(function (node) {
      return node === biggestNode;
    });

    for (var _key in grid) {
      var _node = grid[_key];
      if (_node === biggestNode) biggestNodeShown = true;
      worthyLabels.push(_node);
    } // Always keeping biggest node shown on screen


    if (!biggestNodeShown && biggestNode) worthyLabels.push(biggestNode); // Basic anti-collision

    var collisions = new Set();

    for (var _i = 0, _l = worthyLabels.length; _i < _l; _i++) {
      var _n = worthyLabels[_i],
          d1 = cache[_n],
          p1 = camera.graphToViewport(dimensions, d1.x, d1.y);
      if (collisions.has(_n)) continue;

      for (var j = _i + 1; j < _l; j++) {
        var _n2 = worthyLabels[j],
            d2 = cache[_n2],
            p2 = camera.graphToViewport(dimensions, d2.x, d2.y);
        var c = collision( // First abstract bbox
        p1.x, p1.y, d1.label.length * 8, fontSize, // Second abstract bbox
        p2.x, p2.y, d2.label.length * 8, fontSize);

        if (c) {
          // NOTE: add degree as tie-breaker here if required in the future
          // NOTE: add final stable tie-breaker using node key if required
          if (d1.size < d2.size) collisions.add(_n);else collisions.add(_n2);
        }
      }
    } // console.log(collisions)


    return worthyLabels.filter(function (l) {
      return !collisions.has(l);
    });
  }
  /**
   * Label heuristic selecting edge labels to display, based on displayed node
   * labels
   *
   * @param  {object} params                 - Parameters:
   * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.
   * @param  {Set}      highlightedNodes     - Highlighted nodes.
   * @param  {Graph}    graph                - The rendered graph.
   * @param  {string}   hoveredNode          - Hovered node (optional)
   * @return {Array}                         - The selected labels.
   */


  function edgeLabelsToDisplayFromNodes(params) {
    var graph = params.graph,
        hoveredNode = params.hoveredNode,
        highlightedNodes = params.highlightedNodes,
        displayedNodeLabels = params.displayedNodeLabels;
    var worthyEdges = new Set();
    var displayedNodeLabelsArray = Array.from(displayedNodeLabels); // Each edge connecting a highlighted node has its label displayed:

    var highlightedNodesArray = Array.from(highlightedNodes);
    if (hoveredNode && !highlightedNodes.has(hoveredNode)) highlightedNodesArray.push(hoveredNode);

    for (var i = 0; i < highlightedNodesArray.length; i++) {
      var key = highlightedNodesArray[i];
      var edges = graph.edges(key);

      for (var j = 0; j < edges.length; j++) {
        worthyEdges.add(edges[j]);
      }
    } // Each edge connecting two nodes with visible labels has its label displayed:


    for (var _i2 = 0; _i2 < displayedNodeLabelsArray.length; _i2++) {
      var _key2 = displayedNodeLabelsArray[_i2];

      var _edges = graph.outboundEdges(_key2);

      for (var _j = 0; _j < _edges.length; _j++) {
        if (displayedNodeLabels.has(graph.opposite(_key2, _edges[_j]))) worthyEdges.add(_edges[_j]);
      }
    }

    return Array.from(worthyEdges);
  }
  });

  unwrapExports(labels);
  var labels_1 = labels.labelsToDisplayFromGrid;
  var labels_2 = labels.edgeLabelsToDisplayFromNodes;

  var zIndex = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.zIndexOrdering = zIndexOrdering;

  /**
   * Sigma.js zIndex Heuristics
   * ===========================
   *
   * Miscelleneous heuristics related to z-index ordering of nodes & edges.
   */

  /**
   * Function ordering the given elements in reverse z-order so they drawn
   * the correct way.
   *
   * @param  {number}   extent   - [min, max] z values.
   * @param  {function} getter   - Z attribute getter function.
   * @param  {array}    elements - The array to sort.
   * @return {array} - The sorted array.
   */
  function zIndexOrdering(extent, getter, elements) {
    // const n = elements.length;
    // const [min, max] = extent;
    // const k = max - min;
    // No ordering needs to be done
    // if (k === 0 || k === -Infinity)
    //   return elements;
    // If k is > n, we'll use a standard sort
    return elements.sort(function (a, b) {
      var zA = getter(a) || 0,
          zB = getter(b) || 0;
      if (zA < zB) return -1;
      if (zA > zB) return 1;
      return 0;
    }); // TODO: counting sort optimization
  }
  });

  unwrapExports(zIndex);
  var zIndex_1 = zIndex.zIndexOrdering;

  var label = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = drawLabel;

  /**
   * Sigma.js Canvas Renderer Label Component
   * =========================================
   *
   * Function used by the canvas renderer to display a single node's label.
   */
  function drawLabel(context, data, settings) {
    var size = settings.labelSize,
        font = settings.labelFont,
        weight = settings.labelWeight;
    context.fillStyle = '#000';
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
    context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);
  }
  });

  unwrapExports(label);

  var node$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = drawNode;

  /**
   * Sigma.js Canvas Renderer Node Component
   * ========================================
   *
   * Function used by the canvas renderer to display a single node.
   */
  var PI_TIMES_2 = Math.PI * 2;

  function drawNode(context, data) {
    context.fillStyle = data.color;
    context.beginPath();
    context.arc(data.x, data.y, data.size, 0, PI_TIMES_2, true);
    context.closePath();
    context.fill();
  }
  });

  unwrapExports(node$1);

  var hover = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = drawHover;

  var _node = _interopRequireDefault(node$1);

  var _label = _interopRequireDefault(label);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  /**
   * Sigma.js Canvas Renderer Hover Component
   * =========================================
   *
   * Function used by the canvas renderer to display a single node's hovered
   * state.
   */
  function drawHover(context, data, settings) {
    var size = settings.labelSize,
        font = settings.labelFont,
        weight = settings.labelWeight;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font); // Then we draw the label background

    context.beginPath();
    context.fillStyle = '#fff';
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 8;
    context.shadowColor = '#000';
    var textWidth = context.measureText(data.label).width;
    var x = Math.round(data.x - size / 2 - 2),
        y = Math.round(data.y - size / 2 - 2),
        w = Math.round(textWidth + size / 2 + data.size + 9),
        h = Math.round(size + 4),
        e = Math.round(size / 2 + 2);
    context.moveTo(x, y + e);
    context.moveTo(x, y + e);
    context.arcTo(x, y, x + e, y, e);
    context.lineTo(x + w, y);
    context.lineTo(x + w, y + h);
    context.lineTo(x + e, y + h);
    context.arcTo(x, y + h, x, y + h - e, e);
    context.lineTo(x, y + e);
    context.closePath();
    context.fill();
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 0; // Then we need to draw the node

    (0, _node["default"])(context, data); // And finally we draw the label

    (0, _label["default"])(context, data, settings);
  }
  });

  unwrapExports(hover);

  var edgeLabel = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = drawEdgeLabel;

  /**
   * Sigma.js Canvas Renderer Edge Label Component
   * =============================================
   *
   * Function used by the canvas renderer to display a single edge's label.
   */
  function drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {
    var size = settings.edgeLabelSize,
        font = settings.edgeLabelFont,
        weight = settings.edgeLabelWeight,
        label = edgeData.label;
    context.fillStyle = edgeData.color;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
    var textWidth = context.measureText(label).width;
    var cx = (sourceData.x + targetData.x) / 2;
    var cy = (sourceData.y + targetData.y) / 2;
    var dx = targetData.x - sourceData.x;
    var dy = targetData.y - sourceData.y;
    var d = Math.sqrt(dx * dx + dy * dy);
    var angle;

    if (dx > 0) {
      if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);
    } else {
      if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;
    }

    context.save();
    context.translate(cx, cy);
    context.rotate(angle);
    context.fillText(label, -textWidth / 2, edgeData.size / 2 + size);
    context.restore();
  }
  });

  unwrapExports(edgeLabel);

  var utils$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.loadProgram = loadProgram;
  exports.loadFragmentShader = exports.loadVertexShader = void 0;

  /**
   * Sigma.js Shader Utils
   * ======================
   *
   * Code used to load sigma's shaders.
   */

  /**
   * Function used to load a shader.
   */
  function loadShader(type, gl, source) {
    var glType = type === 'VERTEX' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER; // Creating the shader

    var shader = gl.createShader(glType); // Loading source

    gl.shaderSource(shader, source); // Compiling the shader

    gl.compileShader(shader); // Retrieving compilation status

    var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); // Throwing if something went awry

    if (!successfullyCompiled) {
      var infoLog = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error("sigma/renderers/webgl/shaders/utils.loadShader: error while compiling the shader:\n".concat(infoLog, "\n").concat(source));
    }

    return shader;
  }

  var loadVertexShader = loadShader.bind(null, 'VERTEX'),
      loadFragmentShader = loadShader.bind(null, 'FRAGMENT');
  exports.loadFragmentShader = loadFragmentShader;
  exports.loadVertexShader = loadVertexShader;

  /**
   * Function used to load a program.
   */
  function loadProgram(gl, shaders) {
    var program = gl.createProgram();
    var i, l; // Attaching the shaders

    for (i = 0, l = shaders.length; i < l; i++) {
      gl.attachShader(program, shaders[i]);
    }

    gl.linkProgram(program); // Checking status

    var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (!successfullyLinked) {
      gl.deleteProgram(program);
      throw new Error('sigma/renderers/webgl/shaders/utils.loadProgram: error while linking the program.');
    }

    return program;
  }
  });

  unwrapExports(utils$4);
  var utils_1$4 = utils$4.loadProgram;
  var utils_2$4 = utils$4.loadFragmentShader;
  var utils_3$3 = utils$4.loadVertexShader;

  var program = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createCompoundProgram = createCompoundProgram;
  exports["default"] = void 0;



  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /**
   * Program class.
   *
   * @constructor
   */
  var Program =
  /*#__PURE__*/
  function () {
    function Program(gl, vertexShaderSource, fragmentShaderSource) {
      _classCallCheck(this, Program);

      this.vertexShaderSource = vertexShaderSource;
      this.fragmentShaderSource = fragmentShaderSource;
      this.load(gl);
    }
    /**
     * Method used to load the program into a webgl context.
     *
     * @param  {WebGLContext} gl - The WebGL context.
     * @return {WebGLProgram}
     */


    _createClass(Program, [{
      key: "load",
      value: function load(gl) {
        this.vertexShader = (0, utils$4.loadVertexShader)(gl, this.vertexShaderSource);
        this.fragmentShader = (0, utils$4.loadFragmentShader)(gl, this.fragmentShaderSource);
        this.program = (0, utils$4.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);
        return this.program;
      }
    }]);

    return Program;
  }();
  /**
   * Helper function combining two or more programs into a single compound one.
   * Note that this is more a quick & easy way to combine program than a really
   * performant option. More performant programs can be written entirely.
   *
   * @param  {array}    programClasses - Program classes to combine.
   * @return {function}
   */
  // TODO: maybe those should handle their own canvases


  exports["default"] = Program;

  function createCompoundProgram(programClasses) {
    return (
      /*#__PURE__*/
      function () {
        function CompoundProgram(gl) {
          _classCallCheck(this, CompoundProgram);

          this.programs = programClasses.map(function (ProgramClass) {
            return new ProgramClass(gl);
          });
        }

        _createClass(CompoundProgram, [{
          key: "allocate",
          value: function allocate(capacity) {
            this.programs.forEach(function (program) {
              return program.allocate(capacity);
            });
          }
        }, {
          key: "process",
          value: function process() {
            var args = arguments;
            this.programs.forEach(function (program) {
              return program.process.apply(program, _toConsumableArray(args));
            });
          }
        }, {
          key: "computeIndices",
          value: function computeIndices() {
            this.programs.forEach(function (program) {
              if (typeof program.computeIndices === 'function') program.computeIndices();
            });
          }
        }, {
          key: "bufferData",
          value: function bufferData() {
            this.programs.forEach(function (program) {
              return program.bufferData();
            });
          }
        }, {
          key: "render",
          value: function render() {
            var args = arguments;
            this.programs.forEach(function (program) {
              program.bind();
              program.bufferData();
              program.render.apply(program, _toConsumableArray(args));
            });
          }
        }]);

        return CompoundProgram;
      }()
    );
  }
  });

  unwrapExports(program);
  var program_1 = program.createCompoundProgram;

  var node_fast_vert = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 12);
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ 12:
  /***/ (function(module, exports) {

  module.exports = "attribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\n\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\n\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";

  /***/ })

  /******/ });
  });

  unwrapExports(node_fast_vert);

  var node_fast_frag = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 11);
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ 11:
  /***/ (function(module, exports) {

  module.exports = "precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\n\nvoid main(void) {\n  vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  // gl_FragColor = mix(color0, v_color, t);\n  gl_FragColor = mix(color0, v_color, t);\n}\n";

  /***/ })

  /******/ });
  });

  unwrapExports(node_fast_frag);

  var node_fast = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _program = _interopRequireDefault(program);



  var _nodeFastVert = _interopRequireDefault(node_fast_vert);

  var _nodeFastFrag = _interopRequireDefault(node_fast_frag);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var POINTS = 1,
      ATTRIBUTES = 4;

  var NodeProgramFast =
  /*#__PURE__*/
  function (_Program) {
    _inherits(NodeProgramFast, _Program);

    function NodeProgramFast(gl) {
      var _this;

      _classCallCheck(this, NodeProgramFast);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeProgramFast).call(this, gl, _nodeFastVert["default"], _nodeFastFrag["default"])); // Binding context

      _this.gl = gl; // Array data

      _this.array = null; // Initializing buffers

      _this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, _this.buffer);
      var program = _this.program; // Locations

      _this.positionLocation = gl.getAttribLocation(program, 'a_position');
      _this.sizeLocation = gl.getAttribLocation(program, 'a_size');
      _this.colorLocation = gl.getAttribLocation(program, 'a_color');
      _this.matrixLocation = gl.getUniformLocation(program, 'u_matrix');
      _this.ratioLocation = gl.getUniformLocation(program, 'u_ratio');
      _this.scaleLocation = gl.getUniformLocation(program, 'u_scale'); // Bindings

      gl.enableVertexAttribArray(_this.positionLocation);
      gl.enableVertexAttribArray(_this.sizeLocation);
      gl.enableVertexAttribArray(_this.colorLocation);
      gl.vertexAttribPointer(_this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
      gl.vertexAttribPointer(_this.sizeLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
      gl.vertexAttribPointer(_this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12);
      return _this;
    }

    _createClass(NodeProgramFast, [{
      key: "allocate",
      value: function allocate(capacity) {
        this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);
      }
    }, {
      key: "process",
      value: function process(data, offset) {
        var color = (0, utils$3.floatColor)(data.color);
        var i = offset * POINTS * ATTRIBUTES;
        var array = this.array;

        if (data.hidden) {
          array[i++] = 0;
          array[i++] = 0;
          array[i++] = 0;
          array[i++] = 0;
          return;
        }

        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i] = color;
      }
    }, {
      key: "bufferData",
      value: function bufferData() {
        var gl = this.gl;
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      }
    }, {
      key: "render",
      value: function render(params) {
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program);
        gl.uniform1f(this.ratioLocation, 1 / Math.pow(params.ratio, params.nodesPowRatio));
        gl.uniform1f(this.scaleLocation, params.scalingRatio);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);
      }
    }]);

    return NodeProgramFast;
  }(_program["default"]);

  exports["default"] = NodeProgramFast;
  });

  unwrapExports(node_fast);

  var edge_vert = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 10);
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ 10:
  /***/ (function(module, exports) {

  module.exports = "attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_thickness;\nattribute vec4 a_color;\n\nuniform vec2 u_resolution;\nuniform float u_ratio;\nuniform mat3 u_matrix;\nuniform float u_scale;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float min_thickness = 1.8;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n\n  // Computing thickness in pixels\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\n  float thickness = a_thickness * pow_ratio / u_scale;\n\n  // Min thickness for AA\n  thickness = max(min_thickness, thickness);\n\n  // Computing delta relative to viewport\n  vec2 delta = (a_normal * thickness) / u_resolution;\n\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  position += delta;\n\n  // Applying\n  gl_Position = vec4(position, 0, 1);\n\n  v_normal = a_normal;\n  v_thickness = thickness;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";

  /***/ })

  /******/ });
  });

  unwrapExports(edge_vert);

  var edge_frag = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 5);
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ 5:
  /***/ (function(module, exports) {

  module.exports = "precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float feather = 2.6;\nconst vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, color0, t);\n}\n";

  /***/ })

  /******/ });
  });

  unwrapExports(edge_frag);

  var edge = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _program = _interopRequireDefault(program);



  var _edgeVert = _interopRequireDefault(edge_vert);

  var _edgeFrag = _interopRequireDefault(edge_frag);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var POINTS = 4,
      ATTRIBUTES = 6,
      STRIDE = POINTS * ATTRIBUTES;

  var EdgeProgram =
  /*#__PURE__*/
  function (_Program) {
    _inherits(EdgeProgram, _Program);

    function EdgeProgram(gl) {
      var _this;

      _classCallCheck(this, EdgeProgram);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeProgram).call(this, gl, _edgeVert["default"], _edgeFrag["default"])); // Binding context

      _this.gl = gl; // Array data

      _this.array = null;
      _this.indicesArray = null; // Initializing buffers

      _this.buffer = gl.createBuffer();
      _this.indicesBuffer = gl.createBuffer(); // Locations

      _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');
      _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');
      _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');
      _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');
      _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');
      _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');
      _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');
      _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');

      _this.bind(); // Enabling the OES_element_index_uint extension
      // NOTE: on older GPUs, this means that really large graphs won't
      // have all their edges rendered. But it seems that the
      // `OES_element_index_uint` is quite everywhere so we'll handle
      // the potential issue if it really arises.
      // NOTE: when using webgl2, the extension is enabled by default


      _this.canUse32BitsIndices = (0, utils$3.canUse32BitsIndices)(gl);
      _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;
      _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
      return _this;
    }

    _createClass(EdgeProgram, [{
      key: "bind",
      value: function bind() {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings

        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.thicknessLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
      }
    }, {
      key: "allocate",
      value: function allocate(capacity) {
        this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);
      }
    }, {
      key: "process",
      value: function process(sourceData, targetData, data, offset) {
        if (sourceData.hidden || targetData.hidden || data.hidden) {
          for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {
            this.array[_i] = 0;
          }

          return;
        }

        var thickness = data.size || 1,
            x1 = sourceData.x,
            y1 = sourceData.y,
            x2 = targetData.x,
            y2 = targetData.y,
            color = (0, utils$3.floatColor)(data.color); // Computing normals

        var dx = x2 - x1,
            dy = y2 - y1;
        var len = dx * dx + dy * dy,
            n1 = 0,
            n2 = 0;

        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len;
          n2 = dx * len;
        }

        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array; // First point

        array[i++] = x1;
        array[i++] = y1;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = thickness;
        array[i++] = color; // First point flipped

        array[i++] = x1;
        array[i++] = y1;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = color; // Second point

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = thickness;
        array[i++] = color; // Second point flipped

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i] = color;
      }
    }, {
      key: "computeIndices",
      value: function computeIndices() {
        var l = this.array.length / ATTRIBUTES;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);

        for (var i = 0, c = 0; i < l; i += 4) {
          indices[c++] = i;
          indices[c++] = i + 1;
          indices[c++] = i + 2;
          indices[c++] = i + 2;
          indices[c++] = i + 1;
          indices[c++] = i + 3;
        }

        this.indicesArray = indices;
      }
    }, {
      key: "bufferData",
      value: function bufferData() {
        var gl = this.gl; // Vertices data

        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);
      }
    }, {
      key: "render",
      value: function render(params) {
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program); // Binding uniforms
        // TODO: precise the uniform names

        gl.uniform2f(this.resolutionLocation, params.width, params.height);
        gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)
        params.ratio);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:

        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
      }
    }]);

    return EdgeProgram;
  }(_program["default"]);

  exports["default"] = EdgeProgram;
  });

  unwrapExports(edge);

  var arrow_vert = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 1);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */,
  /* 1 */
  /***/ (function(module, exports) {

  module.exports = "attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_thickness;\nattribute float a_radius;\nattribute vec4 a_color;\nattribute vec3 a_barycentric;\n\nuniform vec2 u_resolution;\nuniform float u_ratio;\nuniform mat3 u_matrix;\nuniform float u_scale;\n\nvarying vec4 v_color;\n// varying vec3 v_barycentric;\n\nconst float arrow_ratio = 0.66;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5) * 2.0;\n  float radius = (a_radius - 1.0) * pow_ratio;\n  float thickness = a_thickness * pow_ratio / u_scale;\n  float width = arrow_ratio * thickness / 2.0;\n\n  vec2 delta = vec2(\n      da * ((radius) * a_normal.y)\n    + db * ((radius + thickness) * a_normal.y + width * a_normal.x)\n    + dc * ((radius + thickness) * a_normal.y - width * a_normal.x),\n\n      da * (-(radius) * a_normal.x)\n    + db * (-(radius + thickness) * a_normal.x + width * a_normal.y)\n    + dc * (-(radius + thickness) * a_normal.x - width * a_normal.y)\n  );\n\n  delta /= u_resolution;\n\n  // Scale from [[-1 1] [-1 1]] to the container:\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  position += delta;\n\n  // Applying\n  gl_Position = vec4(position, 0, 1);\n\n  // v_barycentric = a_barycentric;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";

  /***/ })
  /******/ ]);
  });

  unwrapExports(arrow_vert);

  var arrow_frag = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, exports) {

  module.exports = "precision mediump float;\n\nvarying vec4 v_color;\n// varying vec3 v_barycentric;\n\nvoid main(void) {\n  // if (any(lessThan(v_barycentric, vec3(0.01))))\n  //   discard;\n  // else\n    gl_FragColor = v_color;\n}\n";

  /***/ })
  /******/ ]);
  });

  unwrapExports(arrow_frag);

  var arrow = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _program = _interopRequireDefault(program);



  var _arrowVert = _interopRequireDefault(arrow_vert);

  var _arrowFrag = _interopRequireDefault(arrow_frag);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var POINTS = 3,
      ATTRIBUTES = 10,
      STRIDE = POINTS * ATTRIBUTES;

  var ArrowProgram =
  /*#__PURE__*/
  function (_Program) {
    _inherits(ArrowProgram, _Program);

    function ArrowProgram(gl) {
      var _this;

      _classCallCheck(this, ArrowProgram);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ArrowProgram).call(this, gl, _arrowVert["default"], _arrowFrag["default"])); // Binding context

      _this.gl = gl; // Array data

      _this.array = null; // Initializing buffers

      _this.buffer = gl.createBuffer(); // Locations

      _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');
      _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');
      _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');
      _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');
      _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');
      _this.barycentricLocation = gl.getAttribLocation(_this.program, 'a_barycentric');
      _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');
      _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');
      _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');
      _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');

      _this.bind();

      return _this;
    }

    _createClass(ArrowProgram, [{
      key: "bind",
      value: function bind() {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer); // Bindings

        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.thicknessLocation);
        gl.enableVertexAttribArray(this.radiusLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.enableVertexAttribArray(this.barycentricLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24); // TODO: maybe we can optimize here by packing this in a bit mask

        gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 28);
      }
    }, {
      key: "allocate",
      value: function allocate(capacity) {
        this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);
      }
    }, {
      key: "process",
      value: function process(sourceData, targetData, data, offset) {
        if (sourceData.hidden || targetData.hidden || data.hidden) {
          for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {
            this.array[_i] = 0;
          }

          return;
        }

        var thickness = Math.max((data.size || 1) * 2.5, 5),
            radius = targetData.size || 1,
            x1 = sourceData.x,
            y1 = sourceData.y,
            x2 = targetData.x,
            y2 = targetData.y,
            color = (0, utils$3.floatColor)(data.color); // Computing normals

        var dx = x2 - x1,
            dy = y2 - y1;
        var len = dx * dx + dy * dy,
            n1 = 0,
            n2 = 0;

        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len;
          n2 = dx * len;
        }

        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array; // First point

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = 0;
        array[i++] = 0; // Second point

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 1;
        array[i++] = 0; // Third point

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 0;
        array[i] = 1;
      }
    }, {
      key: "bufferData",
      value: function bufferData() {
        var gl = this.gl; // Vertices data

        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      }
    }, {
      key: "render",
      value: function render(params) {
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program); // Binding uniforms

        gl.uniform2f(this.resolutionLocation, params.width, params.height);
        gl.uniform1f(this.ratioLocation, params.ratio);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:

        gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);
      }
    }]);

    return ArrowProgram;
  }(_program["default"]);

  exports["default"] = ArrowProgram;
  });

  unwrapExports(arrow);

  var edge_clamped_vert = createCommonjsModule(function (module) {
  module.exports =
  /******/ (function(modules) { // webpackBootstrap
  /******/ 	// The module cache
  /******/ 	var installedModules = {};
  /******/
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/
  /******/ 		// Check if module is in cache
  /******/ 		if(installedModules[moduleId]) {
  /******/ 			return installedModules[moduleId].exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = installedModules[moduleId] = {
  /******/ 			i: moduleId,
  /******/ 			l: false,
  /******/ 			exports: {}
  /******/ 		};
  /******/
  /******/ 		// Execute the module function
  /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ 		// Flag the module as loaded
  /******/ 		module.l = true;
  /******/
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/
  /******/
  /******/ 	// expose the modules object (__webpack_modules__)
  /******/ 	__webpack_require__.m = modules;
  /******/
  /******/ 	// expose the module cache
  /******/ 	__webpack_require__.c = installedModules;
  /******/
  /******/ 	// define getter function for harmony exports
  /******/ 	__webpack_require__.d = function(exports, name, getter) {
  /******/ 		if(!__webpack_require__.o(exports, name)) {
  /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/ 		}
  /******/ 	};
  /******/
  /******/ 	// define __esModule on exports
  /******/ 	__webpack_require__.r = function(exports) {
  /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 		}
  /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 	};
  /******/
  /******/ 	// create a fake namespace object
  /******/ 	// mode & 1: value is a module id, require it
  /******/ 	// mode & 2: merge all properties of value into the ns
  /******/ 	// mode & 4: return value when already ns object
  /******/ 	// mode & 8|1: behave like require
  /******/ 	__webpack_require__.t = function(value, mode) {
  /******/ 		if(mode & 1) value = __webpack_require__(value);
  /******/ 		if(mode & 8) return value;
  /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/ 		var ns = Object.create(null);
  /******/ 		__webpack_require__.r(ns);
  /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/ 		return ns;
  /******/ 	};
  /******/
  /******/ 	// getDefaultExport function for compatibility with non-harmony modules
  /******/ 	__webpack_require__.n = function(module) {
  /******/ 		var getter = module && module.__esModule ?
  /******/ 			function getDefault() { return module['default']; } :
  /******/ 			function getModuleExports() { return module; };
  /******/ 		__webpack_require__.d(getter, 'a', getter);
  /******/ 		return getter;
  /******/ 	};
  /******/
  /******/ 	// Object.prototype.hasOwnProperty.call
  /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/ 	// __webpack_public_path__
  /******/ 	__webpack_require__.p = "";
  /******/
  /******/
  /******/ 	// Load entry module and return exports
  /******/ 	return __webpack_require__(__webpack_require__.s = 2);
  /******/ })
  /************************************************************************/
  /******/ ({

  /***/ 2:
  /***/ (function(module, exports) {

  module.exports = "attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_thickness;\nattribute vec4 a_color;\nattribute float a_radius;\n\nuniform vec2 u_resolution;\nuniform float u_ratio;\nuniform mat3 u_matrix;\nuniform float u_scale;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float min_thickness = 1.8;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n\n  // Computing thickness in pixels\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\n  float thickness = a_thickness * pow_ratio / u_scale;\n\n  // Min thickness for AA\n  thickness = max(min_thickness, thickness);\n\n  // Arrow margin\n  // NOTE: it seems we don't need a constant margin into the arrow\n  float arrow_pow_ratio = pow_ratio * 2.0;\n  float radius = abs(a_radius) * arrow_pow_ratio;\n  float arrow_thickness = max(a_thickness * 2.5, 5.0) * arrow_pow_ratio / u_scale;\n  float margin = radius + arrow_thickness - arrow_pow_ratio;\n  float direction = sign(a_radius);\n  vec2 pnormal = vec2(-direction * a_normal.y, direction * a_normal.x);\n\n  // Computing delta relative to viewport\n  vec2 delta = (a_normal * thickness) / u_resolution;\n  vec2 clamped = (pnormal * margin) / u_resolution;\n\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  position += delta + clamped;\n\n  // Applying\n  gl_Position = vec4(position, 0, 1);\n\n  v_normal = a_normal;\n  v_thickness = thickness;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";

  /***/ })

  /******/ });
  });

  unwrapExports(edge_clamped_vert);

  var edge_clamped = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;

  var _program = _interopRequireDefault(program);



  var _edgeClampedVert = _interopRequireDefault(edge_clamped_vert);

  var _edgeFrag = _interopRequireDefault(edge_frag);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var POINTS = 4,
      ATTRIBUTES = 7,
      STRIDE = POINTS * ATTRIBUTES;

  var EdgeClampedProgram =
  /*#__PURE__*/
  function (_Program) {
    _inherits(EdgeClampedProgram, _Program);

    function EdgeClampedProgram(gl) {
      var _this;

      _classCallCheck(this, EdgeClampedProgram);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeClampedProgram).call(this, gl, _edgeClampedVert["default"], _edgeFrag["default"])); // Binding context

      _this.gl = gl; // Array data

      _this.array = null;
      _this.indicesArray = null; // Initializing buffers

      _this.buffer = gl.createBuffer();
      _this.indicesBuffer = gl.createBuffer(); // Locations

      _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');
      _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');
      _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');
      _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');
      _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');
      _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');
      _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');
      _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');
      _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');

      _this.bind(); // Enabling the OES_element_index_uint extension
      // NOTE: on older GPUs, this means that really large graphs won't
      // have all their edges rendered. But it seems that the
      // `OES_element_index_uint` is quite everywhere so we'll handle
      // the potential issue if it really arises.
      // NOTE: when using webgl2, the extension is enabled by default


      _this.canUse32BitsIndices = (0, utils$3.canUse32BitsIndices)(gl);
      _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;
      _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
      return _this;
    }

    _createClass(EdgeClampedProgram, [{
      key: "bind",
      value: function bind() {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings

        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.thicknessLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.enableVertexAttribArray(this.radiusLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);
      }
    }, {
      key: "allocate",
      value: function allocate(capacity) {
        this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);
      }
    }, {
      key: "process",
      value: function process(sourceData, targetData, data, offset) {
        if (sourceData.hidden || targetData.hidden || data.hidden) {
          for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {
            this.array[_i] = 0;
          }

          return;
        }

        var thickness = data.size || 1,
            x1 = sourceData.x,
            y1 = sourceData.y,
            x2 = targetData.x,
            y2 = targetData.y,
            radius = targetData.size || 1,
            color = (0, utils$3.floatColor)(data.color); // Computing normals

        var dx = x2 - x1,
            dy = y2 - y1;
        var len = dx * dx + dy * dy,
            n1 = 0,
            n2 = 0;

        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len;
          n2 = dx * len;
        }

        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array; // First point

        array[i++] = x1;
        array[i++] = y1;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = thickness;
        array[i++] = color;
        array[i++] = 0; // First point flipped

        array[i++] = x1;
        array[i++] = y1;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = color;
        array[i++] = 0; // Second point

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = thickness;
        array[i++] = color;
        array[i++] = radius; // Second point flipped

        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = thickness;
        array[i++] = color;
        array[i] = -radius;
      }
    }, {
      key: "computeIndices",
      value: function computeIndices() {
        var l = this.array.length / ATTRIBUTES;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);

        for (var i = 0, c = 0; i < l; i += 4) {
          indices[c++] = i;
          indices[c++] = i + 1;
          indices[c++] = i + 2;
          indices[c++] = i + 2;
          indices[c++] = i + 1;
          indices[c++] = i + 3;
        }

        this.indicesArray = indices;
      }
    }, {
      key: "bufferData",
      value: function bufferData() {
        var gl = this.gl; // Vertices data

        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);
      }
    }, {
      key: "render",
      value: function render(params) {
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program); // Binding uniforms
        // TODO: precise the uniform names

        gl.uniform2f(this.resolutionLocation, params.width, params.height);
        gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)
        params.ratio);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:

        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
      }
    }]);

    return EdgeClampedProgram;
  }(_program["default"]);

  exports["default"] = EdgeClampedProgram;
  });

  unwrapExports(edge_clamped);

  var edge_arrow = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _arrow = _interopRequireDefault(arrow);

  var _edge = _interopRequireDefault(edge_clamped);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  /**
   * Sigma.js WebGL Renderer Edge Arrow Program
   * ===========================================
   *
   * Compound program rendering edges as an arrow from the source to the target.
   */
  var program$1 = (0, program.createCompoundProgram)([_edge["default"], _arrow["default"]]);
  var _default = program$1;
  exports["default"] = _default;
  });

  unwrapExports(edge_arrow);

  var settings = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.validateWebglRendererSettings = validateWebglRendererSettings;
  exports.WEBGL_RENDERER_DEFAULT_SETTINGS = void 0;

  var _label = _interopRequireDefault(label);

  var _hover = _interopRequireDefault(hover);

  var _edgeLabel = _interopRequireDefault(edgeLabel);

  var _node = _interopRequireDefault(node_fast);

  var _edge = _interopRequireDefault(edge);

  var _edge2 = _interopRequireDefault(edge_arrow);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /**
   * Sigma.js WebGL Renderer Settings
   * =================================
   *
   * The list of settings for the WebGL renderer and some handy functions.
   */
  function validateWebglRendererSettings(settings) {
    // Label grid cell
    if (settings.labelGrid && settings.labelGrid.cell && _typeof(settings.labelGrid.cell) === 'object' && (!settings.labelGrid.cell.width || !settings.labelGrid.cell.height)) {
      throw new Error('sigma/renderers/webgl/settings: invalid `labelGrid.cell`. Expecting {width, height}.');
    }
  }

  var WEBGL_RENDERER_DEFAULT_SETTINGS = {
    // Performance
    hideEdgesOnMove: false,
    hideLabelsOnMove: false,
    renderLabels: true,
    renderEdgeLabels: false,
    // Component rendering
    defaultNodeColor: '#999',
    defaultNodeType: 'circle',
    defaultEdgeColor: '#ccc',
    defaultEdgeType: 'line',
    labelFont: 'Arial',
    labelSize: 14,
    labelWeight: 'normal',
    edgeLabelFont: 'Arial',
    edgeLabelSize: 14,
    edgeLabelWeight: 'normal',
    // Labels
    labelGrid: {
      cell: null,
      renderedSizeThreshold: -Infinity
    },
    // Reducers
    nodeReducer: null,
    edgeReducer: null,
    // Features
    zIndex: false,
    // Renderers
    labelRenderer: _label["default"],
    hoverRenderer: _hover["default"],
    edgeLabelRenderer: _edgeLabel["default"],
    // Program classes
    nodeProgramClasses: {
      circle: _node["default"]
    },
    edgeProgramClasses: {
      arrow: _edge2["default"],
      line: _edge["default"]
    }
  };
  exports.WEBGL_RENDERER_DEFAULT_SETTINGS = WEBGL_RENDERER_DEFAULT_SETTINGS;
  });

  unwrapExports(settings);
  var settings_1 = settings.validateWebglRendererSettings;
  var settings_2 = settings.WEBGL_RENDERER_DEFAULT_SETTINGS;

  var webgl = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _isGraph = _interopRequireDefault(isGraph$1);

  var _renderer = _interopRequireDefault(renderer);

  var _camera = _interopRequireDefault(camera);

  var _mouse = _interopRequireDefault(mouse);

  var _quadtree = _interopRequireDefault(quadtree);















  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * Constants.
   */
  var PIXEL_RATIO = (0, utils$1.getPixelRatio)();
  var WEBGL_OVERSAMPLING_RATIO = (0, utils$1.getPixelRatio)();
  /**
   * Main class.
   *
   * @constructor
   * @param {Graph}       graph     - Graph to render.
   * @param {HTMLElement} container - DOM container in which to render.
   * @param {object}      settings  - Optional settings.
   */

  var WebGLRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    _inherits(WebGLRenderer, _Renderer);

    function WebGLRenderer(graph, container, settings$1) {
      var _this;

      _classCallCheck(this, WebGLRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLRenderer).call(this));
      settings$1 = settings$1 || {};
      _this.settings = (0, utils.assign)({}, settings.WEBGL_RENDERER_DEFAULT_SETTINGS, settings$1);
      (0, settings.validateWebglRendererSettings)(_this.settings); // Validating

      if (!(0, _isGraph["default"])(graph)) throw new Error('sigma/renderers/webgl: invalid graph instance.');
      if (!(container instanceof HTMLElement)) throw new Error('sigma/renderers/webgl: container should be an html element.'); // Properties

      _this.graph = graph;
      _this.captors = {};
      _this.container = container;
      _this.elements = {};
      _this.contexts = {};
      _this.listeners = {}; // Indices & cache
      // TODO: this could be improved by key => index => floatArray
      // TODO: the cache should erase keys on node delete & add new

      _this.quadtree = new _quadtree["default"]();
      _this.nodeDataCache = {};
      _this.edgeDataCache = {};
      _this.nodeExtent = null;
      _this.edgeExtent = null;

      _this.initializeCache(); // Normalization function


      _this.normalizationFunction = null; // Starting dimensions

      _this.width = 0;
      _this.height = 0; // State

      _this.highlightedNodes = new Set();
      _this.displayedLabels = new Set();
      _this.hoveredNode = null;
      _this.wasRenderedInThisFrame = false;
      _this.renderFrame = null;
      _this.renderHighlightedNodesFrame = null;
      _this.needToProcess = false;
      _this.needToSoftProcess = false; // Initializing contexts

      _this.createContext('edges');

      _this.createContext('edgeLabels', false);

      _this.createContext('nodes');

      _this.createContext('labels', false);

      _this.createContext('hovers', false);

      _this.createContext('mouse', false); // Blending


      var gl = _this.contexts.nodes;
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);
      gl = _this.contexts.edges;
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND); // Loading programs

      _this.nodePrograms = {};
      _this.edgePrograms = {};

      for (var type in _this.settings.nodeProgramClasses) {
        var NodeProgramClass = _this.settings.nodeProgramClasses[type];
        _this.nodePrograms[type] = new NodeProgramClass(_this.contexts.nodes);
      }

      for (var _type in _this.settings.edgeProgramClasses) {
        var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];
        _this.edgePrograms[_type] = new EdgeProgramClass(_this.contexts.edges);
      } // Initial resize


      _this.resize(); // Initializing the camera


      _this.camera = new _camera["default"]({
        width: _this.width,
        height: _this.height
      }); // Binding camera events

      _this.bindCameraHandlers(); // Initializing captors


      _this.captors = {
        mouse: new _mouse["default"](_this.elements.mouse, _this.camera)
      }; // Binding event handlers

      _this.bindEventHandlers(); // Binding graph handlers


      _this.bindGraphHandlers(); // Processing data for the first time & render


      _this.process();

      _this.render();

      return _this;
    }
    /**---------------------------------------------------------------------------
     * Internal methods.
     **---------------------------------------------------------------------------
     */

    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string}  id    - Context's id.
     * @param  {boolean} webgl - Whether the context is a webgl or canvas one.
     * @return {WebGLRenderer}
     */


    _createClass(WebGLRenderer, [{
      key: "createContext",
      value: function createContext(id) {
        var webgl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var element = (0, utils$1.createElement)('canvas', {
          "class": "sigma-".concat(id),
          style: {
            position: 'absolute'
          }
        });
        this.elements[id] = element;
        this.container.appendChild(element);
        var contextOptions = {
          preserveDrawingBuffer: false,
          antialias: false
        };
        var context;

        if (webgl) {
          // First we try webgl2 for an easy performance boost
          context = element.getContext('webgl2', contextOptions); // Else we fall back to webgl

          if (!context) context = element.getContext('webgl', contextOptions); // Edge, I am looking right at you...

          if (!context) context = element.getContext('experimental-webgl', contextOptions);
        } else {
          context = element.getContext('2d', contextOptions);
        }

        this.contexts[id] = context;
        return this;
      }
      /**
       * Method used to initialize display data cache.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "initializeCache",
      value: function initializeCache() {
        var graph = this.graph;
        var nodes = graph.nodes();

        for (var i = 0, l = nodes.length; i < l; i++) {
          this.nodeDataCache[nodes[i]] = new displayData.NodeDisplayData(i, this.settings);
        }

        var edges = graph.edges();

        for (var _i = 0, _l = edges.length; _i < _l; _i++) {
          this.edgeDataCache[edges[_i]] = new displayData.EdgeDisplayData(_i, this.settings);
        }
      }
      /**
       * Method binding camera handlers.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "bindCameraHandlers",
      value: function bindCameraHandlers() {
        var _this2 = this;

        this.listeners.camera = function () {
          _this2.scheduleRender();
        };

        this.camera.on('updated', this.listeners.camera);
        return this;
      }
      /**
       * Method binding event handlers.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "bindEventHandlers",
      value: function bindEventHandlers() {
        var _this3 = this;

        // Handling window resize
        this.listeners.handleResize = function () {
          _this3.needToSoftProcess = true;

          _this3.scheduleRender();
        };

        window.addEventListener('resize', this.listeners.handleResize); // Function checking if the mouse is on the given node

        var mouseIsOnNode = function mouseIsOnNode(mouseX, mouseY, nodeX, nodeY, size) {
          return mouseX > nodeX - size && mouseX < nodeX + size && mouseY > nodeY - size && mouseY < nodeY + size && Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2)) < size;
        }; // Function returning the nodes in the mouse's quad


        var getQuadNodes = function getQuadNodes(mouseX, mouseY) {
          var mouseGraphPosition = _this3.camera.viewportToGraph(_this3, mouseX, mouseY); // TODO: minus 1? lol


          return _this3.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);
        }; // Handling mouse move


        this.listeners.handleMove = function (e) {
          // NOTE: for the canvas renderer, testing the pixel's alpha should
          // give some boost but this slows things down for WebGL empirically.
          // TODO: this should be a method from the camera (or can be passed to graph to display somehow)
          var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);
          var quadNodes = getQuadNodes(e.x, e.y); // We will hover the node whose center is closest to mouse

          var minDistance = Infinity,
              nodeToHover = null;

          for (var i = 0, l = quadNodes.length; i < l; i++) {
            var node = quadNodes[i];
            var data = _this3.nodeDataCache[node];

            var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);

            var size = data.size / sizeRatio;

            if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {
              var distance = Math.sqrt(Math.pow(e.x - pos.x, 2) + Math.pow(e.y - pos.y, 2)); // TODO: sort by min size also for cases where center is the same

              if (distance < minDistance) {
                minDistance = distance;
                nodeToHover = node;
              }
            }
          }

          if (nodeToHover && _this3.hoveredNode !== nodeToHover) {
            // Handling passing from one node to the other directly
            if (_this3.hoveredNode !== null) _this3.emit('leaveNode', {
              node: _this3.hoveredNode
            });
            _this3.hoveredNode = nodeToHover;

            _this3.emit('enterNode', {
              node: nodeToHover
            });

            return _this3.scheduleHighlightedNodesRender();
          } // Checking if the hovered node is still hovered


          if (_this3.hoveredNode) {
            var _data = _this3.nodeDataCache[_this3.hoveredNode];

            var _pos = _this3.camera.graphToViewport(_this3, _data.x, _data.y);

            var _size = _data.size / sizeRatio;

            if (!mouseIsOnNode(e.x, e.y, _pos.x, _pos.y, _size)) {
              var _node = _this3.hoveredNode;
              _this3.hoveredNode = null;

              _this3.emit('leaveNode', {
                node: _node
              });

              return _this3.scheduleHighlightedNodesRender();
            }
          }
        }; // Handling click


        this.listeners.handleClick = function (e) {
          var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);
          var quadNodes = getQuadNodes(e.x, e.y);

          for (var i = 0, l = quadNodes.length; i < l; i++) {
            var node = quadNodes[i];
            var data = _this3.nodeDataCache[node];

            var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);

            var size = data.size / sizeRatio;
            if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) return _this3.emit('clickNode', {
              node: node,
              captor: e
            });
          }

          return _this3.emit('clickStage');
        };

        this.captors.mouse.on('mousemove', this.listeners.handleMove);
        this.captors.mouse.on('click', this.listeners.handleClick);
        return this;
      }
      /**
       * Method binding graph handlers
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "bindGraphHandlers",
      value: function bindGraphHandlers() {
        var _this4 = this;

        var graph = this.graph;

        this.listeners.graphUpdate = function () {
          _this4.needToProcess = true;

          _this4.scheduleRender();
        };

        this.listeners.softGraphUpdate = function () {
          _this4.needToSoftProcess = true;

          _this4.scheduleRender();
        };

        this.listeners.addNodeGraphUpdate = function (e) {
          // Adding entry to cache
          _this4.nodeDataCache[e.key] = new displayData.NodeDisplayData(graph.order - 1, _this4.settings);

          _this4.listeners.graphUpdate();
        };

        this.listeners.addEdgeGraphUpdate = function (e) {
          // Adding entry to cache
          _this4.edgeDataCache[e.key] = new displayData.EdgeDisplayData(graph.size - 1, _this4.settings);

          _this4.listeners.graphUpdate();
        }; // TODO: clean cache on drop!
        // TODO: bind this on composed state events
        // TODO: it could be possible to update only specific node etc. by holding
        // a fixed-size pool of updated items


        graph.on('nodeAdded', this.listeners.addNodeGraphUpdate);
        graph.on('nodeDropped', this.listeners.graphUpdate);
        graph.on('nodeAttributesUpdated', this.listeners.softGraphUpdate);
        graph.on('edgeAdded', this.listeners.addEdgeGraphUpdate);
        graph.on('nodeDropped', this.listeners.graphUpdate);
        graph.on('edgeAttributesUpdated', this.listeners.softGraphUpdate);
        graph.on('cleared', this.listeners.graphUpdate);
        return this;
      }
      /**
       * Method used to process the whole graph's data.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "process",
      value: function process() {
        var keepArrays = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var graph = this.graph,
            settings = this.settings; // Clearing the quad

        this.quadtree.clear(); // Computing extents

        var nodeExtentProperties = ['x', 'y'];

        if (this.settings.zIndex) {
          nodeExtentProperties.push('z');
          this.edgeExtent = (0, extent_1.edgeExtent)(graph, ['z']);
        }

        this.nodeExtent = (0, extent_1.nodeExtent)(graph, nodeExtentProperties); // Rescaling function

        this.normalizationFunction = (0, utils$1.createNormalizationFunction)(this.nodeExtent);
        var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];
        if (!keepArrays) nodeProgram.allocate(graph.order);
        var nodes = graph.nodes(); // Handling node z-index
        // TODO: z-index needs us to compute display data before hand
        // TODO: remains to be seen if reducers are a good or bad thing and if we
        // should store display data in flat byte arrays indices

        if (this.settings.zIndex) nodes = (0, zIndex.zIndexOrdering)(this.edgeExtent.z, function (node) {
          return graph.getNodeAttribute(node, 'z');
        }, nodes);

        for (var i = 0, l = nodes.length; i < l; i++) {
          var node = nodes[i];
          var data = graph.getNodeAttributes(node);
          var displayData = this.nodeDataCache[node];
          if (settings.nodeReducer) data = settings.nodeReducer(node, data); // TODO: should assign default also somewhere here if there is a reducer

          displayData.assign(data);
          this.normalizationFunction.applyTo(displayData);
          this.quadtree.add(node, displayData.x, 1 - displayData.y, displayData.size / this.width);
          nodeProgram.process(displayData, i);
          displayData.index = i;
        }

        nodeProgram.bufferData();
        var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];
        if (!keepArrays) edgeProgram.allocate(graph.size);
        var edges = graph.edges(); // Handling edge z-index

        if (this.settings.zIndex) edges = (0, zIndex.zIndexOrdering)(this.edgeExtent.z, function (edge) {
          return graph.getEdgeAttribute(edge, 'z');
        }, edges);

        for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {
          var edge = edges[_i2];

          var _data2 = graph.getEdgeAttributes(edge);

          var _displayData = this.edgeDataCache[edge];
          if (settings.edgeReducer) _data2 = settings.edgeReducer(edge, _data2);

          _displayData.assign(_data2);

          var extremities = graph.extremities(edge),
              sourceData = this.nodeDataCache[extremities[0]],
              targetData = this.nodeDataCache[extremities[1]];
          edgeProgram.process(sourceData, targetData, _displayData, _i2);
          _displayData.index = _i2;
        } // Computing edge indices if necessary


        if (!keepArrays && typeof edgeProgram.computeIndices === 'function') edgeProgram.computeIndices();
        edgeProgram.bufferData();
        return this;
      }
      /**
       * Method used to process a single node.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "processNode",
      value: function processNode(key) {
        var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];
        var data = this.graph.getNodeAttributes(key);
        nodeProgram.process(data, this.nodeDataCache[key].index);
        return this;
      }
      /**
       * Method used to process a single edge.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "processEdge",
      value: function processEdge(key) {
        var graph = this.graph;
        var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];
        var data = graph.getEdgeAttributes(key),
            extremities = graph.extremities(key),
            sourceData = graph.getNodeAttributes(extremities[0]),
            targetData = graph.getNodeAttributes(extremities[1]);
        edgeProgram.process(sourceData, targetData, data, this.edgeDataCache[key].index);
        return this;
      }
      /**---------------------------------------------------------------------------
       * Public API.
       **---------------------------------------------------------------------------
       */

      /**
       * Method returning the renderer's camera.
       *
       * @return {Camera}
       */

    }, {
      key: "getCamera",
      value: function getCamera() {
        return this.camera;
      }
      /**
       * Method returning the mouse captor.
       *
       * @return {Camera}
       */

    }, {
      key: "getMouseCaptor",
      value: function getMouseCaptor() {
        return this.captors.mouse;
      }
      /**
       * Method used to resize the renderer.
       *
       * @param  {number} width  - Target width.
       * @param  {number} height - Target height.
       * @return {WebGLRenderer}
       */

    }, {
      key: "resize",
      value: function resize(width, height) {
        var previousWidth = this.width,
            previousHeight = this.height;

        if (arguments.length > 1) {
          this.width = width;
          this.height = height;
        } else {
          this.width = this.container.offsetWidth;
          this.height = this.container.offsetHeight;
        }

        if (this.width === 0) throw new Error('sigma/renderers/webgl: container has no width.');
        if (this.height === 0) throw new Error('sigma/renderers/webgl: container has no height.'); // If nothing has changed, we can stop right here

        if (previousWidth === this.width && previousHeight === this.height) return this; // Sizing dom elements

        for (var id in this.elements) {
          var element = this.elements[id];
          element.style.width = this.width + 'px';
          element.style.height = this.height + 'px';
        } // Sizing contexts


        for (var _id in this.contexts) {
          var context = this.contexts[_id]; // Canvas contexts

          if (context.scale) {
            this.elements[_id].setAttribute('width', this.width * PIXEL_RATIO + 'px');

            this.elements[_id].setAttribute('height', this.height * PIXEL_RATIO + 'px');

            if (PIXEL_RATIO !== 1) context.scale(PIXEL_RATIO, PIXEL_RATIO);
          } // WebGL contexts
          else {
              this.elements[_id].setAttribute('width', this.width * WEBGL_OVERSAMPLING_RATIO + 'px');

              this.elements[_id].setAttribute('height', this.height * WEBGL_OVERSAMPLING_RATIO + 'px');
            }

          if (context.viewport) {
            context.viewport(0, 0, this.width * WEBGL_OVERSAMPLING_RATIO, this.height * WEBGL_OVERSAMPLING_RATIO);
          }
        }

        return this;
      }
      /**
       * Method used to clear the canvases.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "clear",
      value: function clear() {
        this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
        this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);
        this.contexts.labels.clearRect(0, 0, this.width, this.height);
        this.contexts.hovers.clearRect(0, 0, this.width, this.height);
        this.contexts.edgeLabels.clearRect(0, 0, this.width, this.height);
        return this;
      }
      /**
       * Method used to render.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "render",
      value: function render() {
        // If a render was scheduled, we cancel it
        if (this.renderFrame) {
          cancelAnimationFrame(this.renderFrame);
          this.renderFrame = null;
          this.needToProcess = false;
          this.needToSoftProcess = false;
        } // First we need to resize


        this.resize(); // Clearing the canvases

        this.clear(); // If we have no nodes we can stop right there

        if (!this.graph.order) return this; // TODO: improve this heuristic or move to the captor itself?

        var moving = this.camera.isAnimated() || this.captors.mouse.isMoving || this.captors.mouse.hasDragged || this.captors.mouse.wheelLock; // Then we need to extract a matrix from the camera

        var cameraState = this.camera.getState(),
            cameraMatrix = (0, utils$3.matrixFromCamera)(cameraState, {
          width: this.width,
          height: this.height
        });
        var program; // Drawing nodes

        program = this.nodePrograms[this.settings.defaultNodeType];
        program.render({
          matrix: cameraMatrix,
          width: this.width,
          height: this.height,
          ratio: cameraState.ratio,
          nodesPowRatio: 0.5,
          scalingRatio: WEBGL_OVERSAMPLING_RATIO
        }); // Drawing edges

        if (!this.settings.hideEdgesOnMove || !moving) {
          program = this.edgePrograms[this.settings.defaultEdgeType];
          program.render({
            matrix: cameraMatrix,
            width: this.width,
            height: this.height,
            ratio: cameraState.ratio,
            nodesPowRatio: 0.5,
            edgesPowRatio: 0.5,
            scalingRatio: WEBGL_OVERSAMPLING_RATIO
          });
        } // Do not display labels on move per setting


        if (this.settings.hideLabelsOnMove && moving) return this;
        this.renderLabels();
        this.renderEdgeLabels();
        this.renderHighlightedNodes();
        return this;
      }
      /**
       * Method used to render labels.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "renderLabels",
      value: function renderLabels() {
        if (!this.settings.renderLabels) return this;
        var cameraState = this.camera.getState(); // Finding visible nodes to display their labels

        var visibleNodes;

        if (cameraState.ratio >= 1) {
          // Camera is unzoomed so no need to ask the quadtree for visible nodes
          visibleNodes = this.graph.nodes();
        } else {
          // Let's ask the quadtree
          var viewRectangle = this.camera.viewRectangle(this);
          visibleNodes = this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height);
        } // Selecting labels to draw


        var gridSettings = this.settings.labelGrid;
        var labelsToDisplay = (0, labels.labelsToDisplayFromGrid)({
          cache: this.nodeDataCache,
          camera: this.camera,
          cell: gridSettings.cell,
          dimensions: this,
          displayedLabels: this.displayedLabels,
          fontSize: this.settings.labelSize,
          graph: this.graph,
          renderedSizeThreshold: gridSettings.renderedSizeThreshold,
          visibleNodes: visibleNodes
        }); // Drawing labels

        var context = this.contexts.labels;
        var sizeRatio = Math.pow(cameraState.ratio, 0.5);

        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {
          var data = this.nodeDataCache[labelsToDisplay[i]];

          var _this$camera$graphToV = this.camera.graphToViewport(this, data.x, data.y),
              x = _this$camera$graphToV.x,
              y = _this$camera$graphToV.y; // TODO: we can cache the labels we need to render until the camera's ratio changes
          // TODO: this should be computed in the canvas components?


          var size = data.size / sizeRatio;
          this.settings.labelRenderer(context, {
            key: labelsToDisplay[i],
            label: data.label,
            size: size,
            x: x,
            y: y
          }, this.settings);
        } // Caching visible nodes and displayed labels


        this.displayedLabels = new Set(labelsToDisplay);
        return this;
      }
      /**
       * Method used to render edge labels, based on which node labels were
       * rendered.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "renderEdgeLabels",
      value: function renderEdgeLabels() {
        if (!this.settings.renderEdgeLabels) return this;
        var cameraState = this.camera.getState();
        var sizeRatio = Math.pow(cameraState.ratio, 0.5);
        var context = this.contexts.edgeLabels; // Clearing

        context.clearRect(0, 0, this.width, this.height);
        var edgeLabelsToDisplay = (0, labels.edgeLabelsToDisplayFromNodes)({
          graph: this.graph,
          hoveredNode: this.hoveredNode,
          displayedNodeLabels: this.displayedLabels,
          highlightedNodes: this.highlightedNodes
        });

        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {
          var edge = edgeLabelsToDisplay[i],
              extremities = this.graph.extremities(edge),
              sourceData = this.nodeDataCache[extremities[0]],
              targetData = this.nodeDataCache[extremities[1]],
              edgeData = this.edgeDataCache[edgeLabelsToDisplay[i]];

          var _this$camera$graphToV2 = this.camera.graphToViewport(this, sourceData.x, sourceData.y),
              sourceX = _this$camera$graphToV2.x,
              sourceY = _this$camera$graphToV2.y;

          var _this$camera$graphToV3 = this.camera.graphToViewport(this, targetData.x, targetData.y),
              targetX = _this$camera$graphToV3.x,
              targetY = _this$camera$graphToV3.y; // TODO: we can cache the labels we need to render until the camera's ratio changes
          // TODO: this should be computed in the canvas components?


          var size = edgeData.size / sizeRatio;
          this.settings.edgeLabelRenderer(context, {
            key: edge,
            label: edgeData.label,
            color: edgeData.color,
            size: size
          }, {
            key: extremities[0],
            x: sourceX,
            y: sourceY
          }, {
            key: extremities[1],
            x: targetX,
            y: targetY
          }, this.settings);
        }

        return this;
      }
      /**
       * Method used to render the highlighted nodes.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "renderHighlightedNodes",
      value: function renderHighlightedNodes() {
        var _this5 = this;

        var camera = this.camera;
        var sizeRatio = Math.pow(camera.getState().ratio, 0.5);
        var context = this.contexts.hovers; // Clearing

        context.clearRect(0, 0, this.width, this.height); // Rendering

        var render = function render(node) {
          var data = _this5.nodeDataCache[node];

          var _camera$graphToViewpo = camera.graphToViewport(_this5, data.x, data.y),
              x = _camera$graphToViewpo.x,
              y = _camera$graphToViewpo.y;

          var size = data.size / sizeRatio;

          _this5.settings.hoverRenderer(context, {
            key: node,
            label: data.label,
            color: data.color,
            size: size,
            x: x,
            y: y
          }, _this5.settings);
        };

        if (this.hoveredNode) render(this.hoveredNode);
        this.highlightedNodes.forEach(render);
      }
      /**
       * Method used to schedule a render.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "scheduleRender",
      value: function scheduleRender() {
        var _this6 = this;

        // A frame is already scheduled
        if (this.renderFrame) return this; // Let's schedule a frame

        this.renderFrame = requestAnimationFrame(function () {
          // Do we need to process data?
          if (_this6.needToProcess) {
            _this6.process();
          } else if (_this6.needToSoftProcess) {
            _this6.process(true);
          } // Resetting state


          _this6.renderFrame = null;
          _this6.needToProcess = false;
          _this6.needToSoftProcess = false; // Rendering

          _this6.render();
        });
      }
      /**
       * Method used to schedule a hover render.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "scheduleHighlightedNodesRender",
      value: function scheduleHighlightedNodesRender() {
        var _this7 = this;

        if (this.renderHighlightedNodesFrame || this.renderFrame) return this;
        this.renderHighlightedNodesFrame = requestAnimationFrame(function () {
          // Resetting state
          _this7.renderHighlightedNodesFrame = null; // Rendering

          _this7.renderHighlightedNodes();

          _this7.renderEdgeLabels();
        });
      }
      /**
       * Method used to manually refresh.
       *
       * @return {WebGLRenderer}
       */

    }, {
      key: "refresh",
      value: function refresh() {
        this.needToSoftProcess = true;
        this.scheduleRender();
        return this;
      }
      /**
       * Method used to highlight a node.
       *
       * @param  {string} key - The node's key.
       * @return {WebGLRenderer}
       */

    }, {
      key: "highlightNode",
      value: function highlightNode(key) {
        // TODO: check the existence of the node
        // TODO: coerce?
        this.highlightedNodes.add(key); // Rendering

        this.scheduleHighlightedNodesRender();
        return this;
      }
      /**
       * Method used to unhighlight a node.
       *
       * @param  {string} key - The node's key.
       * @return {WebGLRenderer}
       */

    }, {
      key: "unhighlightNode",
      value: function unhighlightNode(key) {
        // TODO: check the existence of the node
        // TODO: coerce?
        this.highlightedNodes["delete"](key); // Rendering

        this.scheduleHighlightedNodesRender();
        return this;
      }
      /**
       * Method used to shut the container & release event listeners.
       *
       * @return {undefined}
       */

    }, {
      key: "kill",
      value: function kill() {
        var graph = this.graph; // Releasing camera handlers

        this.camera.removeListener('updated', this.listeners.camera); // Releasing DOM events & captors

        window.removeEventListener('resize', this.listeners.handleResize);
        this.captors.mouse.kill(); // Releasing graph handlers

        graph.removeListener('nodeAdded', this.listeners.addNodeGraphUpdate);
        graph.removeListener('nodeDropped', this.listeners.graphUpdate);
        graph.removeListener('nodeAttributesUpdated', this.listeners.softGraphUpdate);
        graph.removeListener('edgeAdded', this.listeners.addEdgeGraphUpdate);
        graph.removeListener('nodeDropped', this.listeners.graphUpdate);
        graph.removeListener('edgeAttributesUpdated', this.listeners.softGraphUpdate);
        graph.removeListener('cleared', this.listeners.graphUpdate); // Releasing cache & state

        this.quadtree = null;
        this.nodeDataCache = null;
        this.edgeDataCache = null;
        this.highlightedNodes = null;
        this.previousVisibleNodes = null;
        this.displayedLabels = null; // Clearing frames

        if (this.renderFrame) {
          cancelAnimationFrame(this.renderFrame);
          this.renderFrame = null;
        }

        if (this.renderHighlightedNodesFrame) {
          cancelAnimationFrame(this.renderHighlightedNodesFrame);
          this.renderHighlightedNodesFrame = null;
        } // Destroying canvases


        var container = this.container;

        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
      }
    }]);

    return WebGLRenderer;
  }(_renderer["default"]);

  exports["default"] = WebGLRenderer;
  });

  var WebGLRenderer = unwrapExports(webgl);

  //
   
   var script$9 = {
       name: 'graph-index',
       props: ['nodeset','highlight'],
       computed: {
  	 num_nodes: function() {
  	     var ans = 0;
  	     for(var id in this.nodeset) {
  		 ans++;
  	     }
  	     return ans;
  	 },
  	 graph_data: function() {
  	     var ans = {nodes:[],edges:[]};
  	     var edgeset = {};
  	     for(var id in this.nodeset) {
  		 console.log("NODE",id,name);
  		 ans.nodes.push({"key":id,attributes:{"label":this.nodeset[id].name, "color":"#00f"}});
  		 if(!(this.nodeset[id].edges)) continue;
  		 for(var label in this.nodeset[id].edges.has) {
  		     for(var edge of this.nodeset[id].edges.has[label]) {
  			 var target = edge.target;
  			 console.log("EDGE",edge,id,target);
  			 if(target in this.nodeset) {
  			     var eid = `${id}_${target}_${label}`;
  			     if(eid in edgeset) {
  				 edgeset[eid].attributes.label += ", " + label;
  			     }
  			     else {
  				 edgeset[eid] = {"source":id,"target":target,attributes:{"label":label}};
  			     }
  			 }
  		     }
  		 }
  	     }
  	     for(var eid in edgeset) {
  		 ans.edges.push(edgeset[eid]);
  	     }
  	     return ans;
  	 },
  	 ...mapState([
  	     'nodes'
  	 ]),
  	 ...mapGetters(['sorted','sortedby'])
       },
       watch: {
  	 nodeset: function(val) {
  	     this.$nextTick(function () {
  		 this.update_graph();
  	     });
  	 },
  	 highlight: function(val) {
  	     this.$nextTick(function () {
  		 this.update_highlight();
  	     });
  	 }
       },
       methods: {
  	 label_neighbours: function(n, label) {
  	     var ans = [];
  	     var tgts = this.nodes[n].edges[this.mode == 'menu' ? 'has' : 'is'][label];
  	     for(var i = 0; i < tgts.length; i++) {
  		 var m = tgts[i].target;
  		 console.log(m);
  		 if(m in this.nodeset) ans.push(m);
  	     }
  	     console.log(ans);
  	     return ans;
  	 },
  	 update_graph: function() {
  	     if(this.layout) {
  		 this.layout.stop();
  		 this.layout = null;
  	     }
  	     if(this.layout_timer) {
  		 clearTimeout(this.layout_timer);
  		 this.layout_timer = null;
  	     }
  	     this.graph.clear();
  	     this.graph.import(this.graph_data);
  	     this.graph.nodes().forEach(node => {
  		 this.graph.mergeNodeAttributes(node, {
  		     x: Math.random(),
  		     y: Math.random(),
  		     size: Math.max(3,Math.min(this.graph.degree(node), 8)),
  		     color: node in this.highlight ? "#f00" : "#00f"
  		 });
  	     });
  	     
  	     var settings = graphologyLayoutForceatlas2.inferSettings(this.graph);
  	     console.log(settings);
  	     settings.slowDown = 10;
  	     //saneSettings.strongGravityMode = true;
  	     //saneSettings.gravity = 3;
  	     this.layout = new FA2Layout(this.graph, {settings: settings});
  	     this.layout.start();
  	     var self = this;
  	     this.layout_timer = setTimeout(function(){self.layout.stop(); self.layout.kill(); self.layout = null; self.layout_timer = null;}, Math.max(10, 3+(this.num_nodes/100)*1000));
  	 },
  	 update_highlight: function() {
  	     console.log("updating highlight",this.highlight);
  	     this.graph.nodes().forEach(node => {
  		 console.log("N",node, node in this.highlight);
  		 this.graph.mergeNodeAttributes(node, {color: node in this.highlight ? "#f00" : "#00f"});
  	     });
  	     
  	 }
       },
       mounted: function () {
  	 this.$nextTick(function () {
  	     console.log("initing graph container");
  	     this.graph = new DirectedGraph({multi: true});
  	     this.renderer = new WebGLRenderer(this.graph, document.getElementById("graph_container"), {
  		 defaultEdgeType: 'arrow',
  		 defaultEdgeColor: '#888',
  		 renderEdgeLabels: true,
  		 labelSize: 12,
  		 labelGrid: {
  		     cell: {
  			 width: 40,
  			 height: 20
  		     },
  		     renderedSizeThreshold: 1}});
  	     const camera = this.renderer.getCamera();
  	     const captor = this.renderer.getMouseCaptor();

  	     // State
  	     let draggedNode = null, dragging = false;

  	     var self = this;
  	     
  	     this.renderer.on('downNode', (e) => {
  		 dragging = true;
  		 console.log("down",e);
  		 draggedNode = e.node;
  		 camera.disable();
  	     });

  	     this.renderer.on('clickNode', (e) => {
  		 console.log("nav",e.node);
  		 //this.$router.push("/node/"+e.node);
  		 this.$emit("clickedNode",e.node);
  	     });

  	     captor.on('mouseup', e => {
  		 dragging = false;
  		 console.log("up",e);
  		 draggedNode = null;
  		 camera.enable();
  	     });

  	     captor.on('mousemove', e => {
  		 if (!dragging)
  		     return;

  		 // Get new position of node
  		 const pos = self.renderer.normalizationFunction.inverse(
  		     camera.viewportToGraph(self.renderer, e.x, e.y)
  		 );

  		 self.graph.setNodeAttribute(draggedNode, 'x', pos.x);
  		 self.graph.setNodeAttribute(draggedNode, 'y', pos.y);
  	     });

  	     this.update_graph();
  	     this.update_highlight();
  	 });
       }
   };

  /* script */
  const __vue_script__$9 = script$9;

  /* template */
  var __vue_render__$a = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm._m(0)
  };
  var __vue_staticRenderFns__$a = [
    function() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", { staticClass: "graph_index" }, [
        _c("div", { attrs: { id: "graph_container" } })
      ])
    }
  ];
  __vue_render__$a._withStripped = true;

    /* style */
    const __vue_inject_styles__$a = function (inject) {
      if (!inject) return
      inject("data-v-d60dedc4_0", { source: "\n.graph_index[data-v-d60dedc4] {\n    height: 80%;\n    min-height:80vh;\n    width: 100%;\n}\n#graph_container[data-v-d60dedc4] {\n    height: 80%;\n    min-height:80vh;\n    width: 100%;\n    color: unset;\n    border: 1px solid #ccc;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/components/graph.vue"],"names":[],"mappings":";AA2LA;IACA,WAAA;IACA,eAAA;IACA,WAAA;AACA;AACA;IACA,WAAA;IACA,eAAA;IACA,WAAA;IACA,YAAA;IACA,sBAAA;AACA","file":"graph.vue","sourcesContent":["<template>\n    <div class=\"graph_index\">\n\t<div id=\"graph_container\"></div>\n    </div>\n</template>\n\n<script>\n import {DirectedGraph} from 'graphology';\n import FA2 from 'graphology-layout-forceatlas2';\n import FA2Layout from 'graphology-layout-forceatlas2/worker';\n import WebGLRenderer from 'sigma/renderers/webgl';\n \n import { mapState } from 'vuex'\n import { mapGetters } from 'vuex'\n \n export default {\n     name: 'graph-index',\n     props: ['nodeset','highlight'],\n     computed: {\n\t num_nodes: function() {\n\t     var ans = 0;\n\t     for(var id in this.nodeset) {\n\t\t ans++;\n\t     }\n\t     return ans;\n\t },\n\t graph_data: function() {\n\t     var ans = {nodes:[],edges:[]};\n\t     var edgeset = {};\n\t     for(var id in this.nodeset) {\n\t\t console.log(\"NODE\",id,name);\n\t\t ans.nodes.push({\"key\":id,attributes:{\"label\":this.nodeset[id].name, \"color\":\"#00f\"}})\n\t\t if(!(this.nodeset[id].edges)) continue;\n\t\t for(var label in this.nodeset[id].edges.has) {\n\t\t     for(var edge of this.nodeset[id].edges.has[label]) {\n\t\t\t var target = edge.target;\n\t\t\t console.log(\"EDGE\",edge,id,target);\n\t\t\t if(target in this.nodeset) {\n\t\t\t     var eid = `${id}_${target}_${label}`;\n\t\t\t     if(eid in edgeset) {\n\t\t\t\t edgeset[eid].attributes.label += \", \" + label;\n\t\t\t     }\n\t\t\t     else {\n\t\t\t\t edgeset[eid] = {\"source\":id,\"target\":target,attributes:{\"label\":label}};\n\t\t\t     }\n\t\t\t }\n\t\t     }\n\t\t }\n\t     }\n\t     for(var eid in edgeset) {\n\t\t ans.edges.push(edgeset[eid]);\n\t     }\n\t     return ans;\n\t },\n\t ...mapState([\n\t     'nodes'\n\t ]),\n\t ...mapGetters(['sorted','sortedby'])\n     },\n     watch: {\n\t nodeset: function(val) {\n\t     this.$nextTick(function () {\n\t\t this.update_graph();\n\t     });\n\t },\n\t highlight: function(val) {\n\t     this.$nextTick(function () {\n\t\t this.update_highlight();\n\t     });\n\t }\n     },\n     methods: {\n\t label_neighbours: function(n, label) {\n\t     var ans = [];\n\t     var tgts = this.nodes[n].edges[this.mode == 'menu' ? 'has' : 'is'][label];\n\t     for(var i = 0; i < tgts.length; i++) {\n\t\t var m = tgts[i].target;\n\t\t console.log(m);\n\t\t if(m in this.nodeset) ans.push(m);\n\t     }\n\t     console.log(ans);\n\t     return ans;\n\t },\n\t update_graph: function() {\n\t     if(this.layout) {\n\t\t this.layout.stop();\n\t\t this.layout = null;\n\t     }\n\t     if(this.layout_timer) {\n\t\t clearTimeout(this.layout_timer);\n\t\t this.layout_timer = null;\n\t     }\n\t     this.graph.clear();\n\t     this.graph.import(this.graph_data);\n\t     this.graph.nodes().forEach(node => {\n\t\t this.graph.mergeNodeAttributes(node, {\n\t\t     x: Math.random(),\n\t\t     y: Math.random(),\n\t\t     size: Math.max(3,Math.min(this.graph.degree(node), 8)),\n\t\t     color: node in this.highlight ? \"#f00\" : \"#00f\"\n\t\t });\n\t     });\n\t     \n\t     var settings = FA2.inferSettings(this.graph);\n\t     console.log(settings);\n\t     settings.slowDown = 10;\n\t     //saneSettings.strongGravityMode = true;\n\t     //saneSettings.gravity = 3;\n\t     this.layout = new FA2Layout(this.graph, {settings: settings});\n\t     this.layout.start();\n\t     var self = this;\n\t     this.layout_timer = setTimeout(function(){self.layout.stop(); self.layout.kill(); self.layout = null; self.layout_timer = null;}, Math.max(10, 3+(this.num_nodes/100)*1000));\n\t },\n\t update_highlight: function() {\n\t     console.log(\"updating highlight\",this.highlight);\n\t     this.graph.nodes().forEach(node => {\n\t\t console.log(\"N\",node, node in this.highlight);\n\t\t this.graph.mergeNodeAttributes(node, {color: node in this.highlight ? \"#f00\" : \"#00f\"});\n\t     });\n\t     \n\t }\n     },\n     mounted: function () {\n\t this.$nextTick(function () {\n\t     console.log(\"initing graph container\");\n\t     this.graph = new DirectedGraph({multi: true});\n\t     this.renderer = new WebGLRenderer(this.graph, document.getElementById(\"graph_container\"), {\n\t\t defaultEdgeType: 'arrow',\n\t\t defaultEdgeColor: '#888',\n\t\t renderEdgeLabels: true,\n\t\t labelSize: 12,\n\t\t labelGrid: {\n\t\t     cell: {\n\t\t\t width: 40,\n\t\t\t height: 20\n\t\t     },\n\t\t     renderedSizeThreshold: 1}});\n\t     const camera = this.renderer.getCamera();\n\t     const captor = this.renderer.getMouseCaptor();\n\n\t     // State\n\t     let draggedNode = null, dragging = false;\n\n\t     var self = this;\n\t     \n\t     this.renderer.on('downNode', (e) => {\n\t\t dragging = true;\n\t\t console.log(\"down\",e);\n\t\t draggedNode = e.node;\n\t\t camera.disable();\n\t     });\n\n\t     this.renderer.on('clickNode', (e) => {\n\t\t console.log(\"nav\",e.node);\n\t\t //this.$router.push(\"/node/\"+e.node);\n\t\t this.$emit(\"clickedNode\",e.node)\n\t     });\n\n\t     captor.on('mouseup', e => {\n\t\t dragging = false;\n\t\t console.log(\"up\",e);\n\t\t draggedNode = null;\n\t\t camera.enable();\n\t     });\n\n\t     captor.on('mousemove', e => {\n\t\t if (!dragging)\n\t\t     return;\n\n\t\t // Get new position of node\n\t\t const pos = self.renderer.normalizationFunction.inverse(\n\t\t     camera.viewportToGraph(self.renderer, e.x, e.y)\n\t\t );\n\n\t\t self.graph.setNodeAttribute(draggedNode, 'x', pos.x);\n\t\t self.graph.setNodeAttribute(draggedNode, 'y', pos.y);\n\t     });\n\n\t     this.update_graph();\n\t     this.update_highlight();\n\t });\n     }\n }\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n .graph_index {\n     height: 80%;\n     min-height:80vh;\n     width: 100%;\n }\n #graph_container {\n     height: 80%;\n     min-height:80vh;\n     width: 100%;\n     color: unset;\n     border: 1px solid #ccc;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$a = "data-v-d60dedc4";
    /* module identifier */
    const __vue_module_identifier__$a = undefined;
    /* functional template */
    const __vue_is_functional_template__$a = false;
    /* style inject SSR */
    

    
    var GraphIndex = normalizeComponent_1(
      { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
      __vue_inject_styles__$a,
      __vue_script__$9,
      __vue_scope_id__$a,
      __vue_is_functional_template__$a,
      __vue_module_identifier__$a,
      browser,
      undefined
    );

  //
  //
  //
  //
  //
  //

   var script$a = {
       name: 'cat-loc',
       props: ['root'],
       data () {
  	 return {
  	     loc:'',
  	     links:[],
  	 };
       },
       mounted: function(){
  	 // Parse the link info
  	 var locs = this.root.innerHTML.split("\n");
  	 this.loc = lines[0].trim();
       }
   };

  /* script */
  const __vue_script__$a = script$a;

  /* template */
  var __vue_render__$b = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c("a", { attrs: { name: "cat_loc_" + _vm.loc } }),
      _vm.links.length > 0
        ? _c(
            "ul",
            _vm._l(_vm.links, function(l) {
              return _c("li", [
                _c(
                  "a",
                  {
                    attrs: { href: "#" },
                    on: {
                      click: function($event) {
                        return _vm.goto(_vm.i.secs)
                      }
                    }
                  },
                  [_vm._v(_vm._s(l.name))]
                )
              ])
            }),
            0
          )
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$b = [];
  __vue_render__$b._withStripped = true;

    /* style */
    const __vue_inject_styles__$b = undefined;
    /* scoped */
    const __vue_scope_id__$b = undefined;
    /* module identifier */
    const __vue_module_identifier__$b = undefined;
    /* functional template */
    const __vue_is_functional_template__$b = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var LocPlugin = normalizeComponent_1(
      { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
      __vue_inject_styles__$b,
      __vue_script__$a,
      __vue_scope_id__$b,
      __vue_is_functional_template__$b,
      __vue_module_identifier__$b,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //

   var script$b = {
       name: 'cat-video',
       props: ['root'],
       data () {
  	 return {
  	     id:'',
  	     index:{},
  	     url:'',
  	     type:'',
  	     player: null
  	 };
       },
       methods: {
  	 goto: function(t){
  	     document.getElementById(this.id).currentTime = t;
  	 }
       },
       mounted: function(){
  	 // Parse the link info
  	 var lines = this.root.innerHTML.split("\n");
  	 var url = lines[0].trim();
  	 var index = [];
  	 for (var i = 1; i < lines.length; i++) {
  	     var time = lines[i].split(" ")[0];
  	     var caption = lines[i].substring(lines[i].indexOf(" ")+1);
  	     var secs = 60*parseInt(time.split(":")[0])+parseInt(time.split(":")[1]);
  	     index.push({'secs':secs, 'caption':caption});
  	 }
  	 var ending = 'video/'+url.substring(url.lastIndexOf(".")+1);
  	 this.id = url.replace(new RegExp("[^0-9a-zA-Z_]","g"),"-");
  	 this.index = index;
  	 this.url = url;
  	 this.type = ending;
       }
   };

  /* script */
  const __vue_script__$b = script$b;

  /* template */
  var __vue_render__$c = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c("video", { attrs: { id: _vm.id, controls: "" } }, [
        _c("source", { attrs: { src: _vm.url, type: _vm.type } }),
        _vm._v(
          "\n\tIf you are seing this text, your browser does not support the video tag.\n    "
        )
      ]),
      _vm.index.length > 0
        ? _c(
            "ul",
            _vm._l(_vm.index, function(i) {
              return _c("li", [
                _c(
                  "a",
                  {
                    attrs: { href: "#" },
                    on: {
                      click: function($event) {
                        return _vm.goto(i.secs)
                      }
                    }
                  },
                  [
                    _vm._v(
                      _vm._s(Math.floor(i.secs / 60)) +
                        ":" +
                        _vm._s(new String(i.secs % 60).padStart(2, "0")) +
                        " " +
                        _vm._s(i.caption)
                    )
                  ]
                )
              ])
            }),
            0
          )
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$c = [];
  __vue_render__$c._withStripped = true;

    /* style */
    const __vue_inject_styles__$c = undefined;
    /* scoped */
    const __vue_scope_id__$c = undefined;
    /* module identifier */
    const __vue_module_identifier__$c = undefined;
    /* functional template */
    const __vue_is_functional_template__$c = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var VideoPlugin = normalizeComponent_1(
      { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
      __vue_inject_styles__$c,
      __vue_script__$b,
      __vue_scope_id__$c,
      __vue_is_functional_template__$c,
      __vue_module_identifier__$c,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

   var script$c = {
       name: 'cat-math',
       props: ['root'],
       data () {
  	 return {
  	     id: '',
  	     rendered: '',
  	     player: null
  	 };
       },
       methods: {
  	 get_pos: function() {
  	     var el = document.getElementById("category-math-plugin-expr-"+this.id);
  	     var top = el.getBoundingClientRect().y;
  	     return {'position':'absolute','left':'-25%','top':top+'px','width':'25%'};
  	 }
       },
       created: function(){
  	 console.log("init");
  	 this.$store.dispatch("RESET_PLUGIN_DATA","math");
  	 //Guppy.init({"path":"/node_modules/guppy-js","symbols":"/node_modules/guppy-js/sym/symbols.json"});
       }, 
       mounted: function(){
  	 var index = 0;
  	 var doc_id = node+"-"+index;
  	 var content = this.root.innerHTML.trim();
  	 console.log("R",this.root,content);
  	 //res.container.setAttribute("id","category-math-container-"+doc_id);
  	 //var rendered_content = (new XMLSerializer()).serializeToString(res.container);

  	 
  	 // Put this doc ID in the index for each var and symbol in the document
  	 for(var i = 0; i < this.docs[node][index].length; i++) {
  	     var v = this.docs[node][index][i];
  	     if (!this.index[v]) this.index[v] = [];
  	     if (this.index[v].indexOf(doc_id) < 0) this.index[v].push(doc_id);
  	 }

  	 // Calculate the snippet that will be associated with this expression when it appears in listings
  	 var snippet = "";
  	 if(this.root.previousSibling){
  	     snippet += this.root.previousSibling.textContent.split(" ").slice(-4).join(" ");
  	 }
  	 snippet += " [formula] ";

  	 if(this.root.nextSibling) {
  	     snippet += this.root.nextSibling.textContent.split(" ").slice(0,4).join(" ");
  	 }
  	 snippet = "..." + snippet + "...";
  	 console.log("parprev",this.root.parentNode.previousSibling);
  	 console.log("parnext",this.root.parentNode.nextSibling);
  	 this.snippets[doc_id] = snippet;

  	 // Finally, set up component attributes
  	 this.syms = this.docs[node][index];
  	 this.rendered = rendered_content;
  	 this.display_syms = false;
  	 this.id = doc_id;
  	 this.query = "";
  	 this.node = node;
       }
   };

  /* script */
  const __vue_script__$c = script$c;

  /* template */
  var __vue_render__$d = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", { staticClass: "category-math-plugin" }, [
      _c("a", { attrs: { name: "category-math-plugin-link-" + _vm.id } }),
      _c("div", {
        staticClass: "category-math-plugin-math",
        attrs: { id: "category-math-plugin-expr-" + _vm.id },
        domProps: { innerHTML: _vm._s(_vm.rendered) },
        on: {
          click: function($event) {
            _vm.display_syms = !_vm.display_syms;
          }
        }
      }),
      _vm.display_syms
        ? _c(
            "div",
            {
              staticClass: "category-math-plugin-vars",
              style: _vm.get_pos(_vm.id)
            },
            [
              _c(
                "a",
                {
                  attrs: { href: "#" },
                  on: {
                    click: function($event) {
                      _vm.display_syms = false;
                      _vm.query = "";
                    }
                  }
                },
                [_vm._v("[x]")]
              ),
              _vm._v("\n\t    Vars:\n\t    "),
              _c(
                "ul",
                _vm._l(_vm.syms, function(e) {
                  return _c("li", [
                    _c(
                      "a",
                      {
                        attrs: { href: "#" },
                        on: {
                          click: function($event) {
                            _vm.query = e;
                          }
                        }
                      },
                      [_vm._v(_vm._s(e))]
                    )
                  ])
                }),
                0
              ),
              _vm.display_syms && _vm.query != ""
                ? _c("div", { staticClass: "category-math-plugin-refs" }, [
                    _vm._v("\n\t\tUses:\n\t\t"),
                    _c(
                      "ul",
                      _vm._l(_vm.master.index[_vm.query], function(x) {
                        return _c("li", [
                          _c(
                            "a",
                            {
                              attrs: { href: "#category-math-plugin-link-" + x }
                            },
                            [_vm._v(_vm._s(_vm.master.snippets[x]))]
                          )
                        ])
                      }),
                      0
                    )
                  ])
                : _vm._e()
            ]
          )
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$d = [];
  __vue_render__$d._withStripped = true;

    /* style */
    const __vue_inject_styles__$d = function (inject) {
      if (!inject) return
      inject("data-v-368015e5_0", { source: "\n.category-math-plugin-math[data-v-368015e5] {\n    cursor:pointer;\n    display:inline-block;\n}\n.category-math-plugin-vars[data-v-368015e5] {\n    background-color: #dd5;\n    padding:1ex;\n    border: 1px solid black;\n    z-index:1;\n}\n.category-math-plugin-refs[data-v-368015e5] {\n    background-color: #ff5;\n    padding:2ex 1ex;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/plugins/math.vue"],"names":[],"mappings":";AA6FA;IACA,cAAA;IACA,oBAAA;AACA;AAEA;IACA,sBAAA;IACA,WAAA;IACA,uBAAA;IACA,SAAA;AACA;AAEA;IACA,sBAAA;IACA,eAAA;AACA","file":"math.vue","sourcesContent":["<template>\n    <span class=\"category-math-plugin\">\n\t<a v-bind:name=\"'category-math-plugin-link-'+id\"></a>\n\t<div v-bind:id=\"'category-math-plugin-expr-'+id\" class=\"category-math-plugin-math\" v-on:click=\"display_syms = !display_syms\" v-html=\"rendered\"></div>\n\t<div class=\"category-math-plugin-vars\" v-bind:style=\"get_pos(id)\" v-if=\"display_syms\">\n\t    <a href=\"#\" v-on:click=\"display_syms = false; query = ''\">[x]</a>\n\t    Vars:\n\t    <ul>\n\t\t<li v-for=\"e in syms\">\n\t\t    <a href=\"#\" v-on:click=\"query = e\">{{e}}</a>\n\t\t</li>\n\t    </ul>\n\t    <div class=\"category-math-plugin-refs\" v-if=\"display_syms && query != ''\">\n\t\tUses:\n\t\t<ul>\n\t\t    <li v-for=\"x in master.index[query]\">\n\t\t\t<a v-bind:href=\"'#category-math-plugin-link-'+x\">{{master.snippets[x]}}</a>\n\t\t    </li>\n\t\t</ul>\n\t    </div>\n\t</div>\n    </span>\n</template>\n<script>\n export default {\n     name: 'cat-math',\n     props: ['root'],\n     data () {\n\t return {\n\t     id: '',\n\t     rendered: '',\n\t     player: null\n\t };\n     },\n     methods: {\n\t get_pos: function() {\n\t     var el = document.getElementById(\"category-math-plugin-expr-\"+this.id);\n\t     var top = el.getBoundingClientRect().y;\n\t     return {'position':'absolute','left':'-25%','top':top+'px','width':'25%'};\n\t }\n     },\n     created: function(){\n\t console.log(\"init\");\n\t this.$store.dispatch(\"RESET_PLUGIN_DATA\",\"math\");\n\t //Guppy.init({\"path\":\"/node_modules/guppy-js\",\"symbols\":\"/node_modules/guppy-js/sym/symbols.json\"});\n     }, \n     mounted: function(){\n\t var index = 0;\n\t var doc_id = node+\"-\"+index;\n\t var content = this.root.innerHTML.trim()\n\t console.log(\"R\",this.root,content);\n\t //var res = Guppy.Doc.render(content, \"text\");\n\t var res = {doc:content};\n\t var doc_data = {};\n\t //doc_data[index] = res.doc.get_vars().concat(res.doc.get_symbols());\n\t doc_data[index] = [\"x\"];\n\t //res.container.setAttribute(\"id\",\"category-math-container-\"+doc_id);\n\t //var rendered_content = (new XMLSerializer()).serializeToString(res.container);\n\n\t \n\t // Put this doc ID in the index for each var and symbol in the document\n\t for(var i = 0; i < this.docs[node][index].length; i++) {\n\t     var v = this.docs[node][index][i];\n\t     if (!this.index[v]) this.index[v] = [];\n\t     if (this.index[v].indexOf(doc_id) < 0) this.index[v].push(doc_id);\n\t }\n\n\t // Calculate the snippet that will be associated with this expression when it appears in listings\n\t var snippet = \"\";\n\t if(this.root.previousSibling){\n\t     snippet += this.root.previousSibling.textContent.split(\" \").slice(-4).join(\" \");\n\t }\n\t snippet += \" [formula] \"\n\n\t if(this.root.nextSibling) {\n\t     snippet += this.root.nextSibling.textContent.split(\" \").slice(0,4).join(\" \");\n\t }\n\t snippet = \"...\" + snippet + \"...\";\n\t console.log(\"parprev\",this.root.parentNode.previousSibling);\n\t console.log(\"parnext\",this.root.parentNode.nextSibling);\n\t this.snippets[doc_id] = snippet;\n\n\t // Finally, set up component attributes\n\t this.syms = this.docs[node][index];\n\t this.rendered = rendered_content;\n\t this.display_syms = false;\n\t this.id = doc_id;\n\t this.query = \"\";\n\t this.node = node;\n     }\n }\n</script>\n<style scoped>\n .category-math-plugin-math {\n     cursor:pointer;\n     display:inline-block;\n }\n\n .category-math-plugin-vars {\n     background-color: #dd5;\n     padding:1ex;\n     border: 1px solid black;\n     z-index:1;\n }\n\n .category-math-plugin-refs {\n     background-color: #ff5;\n     padding:2ex 1ex;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$d = "data-v-368015e5";
    /* module identifier */
    const __vue_module_identifier__$d = undefined;
    /* functional template */
    const __vue_is_functional_template__$d = false;
    /* style inject SSR */
    

    
    normalizeComponent_1(
      { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
      __vue_inject_styles__$d,
      __vue_script__$c,
      __vue_scope_id__$d,
      __vue_is_functional_template__$d,
      __vue_module_identifier__$d,
      browser,
      undefined
    );

  //
  //
  //

   var script$d = {
       name: 'cat-link',
       props: ['root'],
       data () {
  	 return {
  	     target: '',
  	     name: ''
  	 };
       },
       mounted: function(){
  	 var doc = this.root.innerHTML.trim();
  	 var idx = doc.indexOf(":");
  	 this.target = doc.substring(0,idx);
  	 this.name = doc.substring(idx+1);
       }
   };

  /* script */
  const __vue_script__$d = script$d;

  /* template */
  var __vue_render__$e = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("router-link", { attrs: { to: "./" + _vm.target } }, [
      _vm._v(_vm._s(_vm.name))
    ])
  };
  var __vue_staticRenderFns__$e = [];
  __vue_render__$e._withStripped = true;

    /* style */
    const __vue_inject_styles__$e = undefined;
    /* scoped */
    const __vue_scope_id__$e = undefined;
    /* module identifier */
    const __vue_module_identifier__$e = undefined;
    /* functional template */
    const __vue_is_functional_template__$e = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var LinkPlugin = normalizeComponent_1(
      { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
      __vue_inject_styles__$e,
      __vue_script__$d,
      __vue_scope_id__$e,
      __vue_is_functional_template__$e,
      __vue_module_identifier__$e,
      undefined,
      undefined
    );

  //
   
   var script$e = {
       name: 'cat-query',
       props: ['root'],
       
       // Need to have access to all the nodes in order to search them
       computed: {
  	 ...mapState(['nodes']),
  	 ...mapGetters(['sorted'])
       },
       data () {
  	 return {
  	     result: []
  	 };
       },
       mounted: function(){
  	 var query_text = this.root.innerHTML.trim();
  	 var q = Vue$1.category_query.parse(query_text);
  	 var query_result = Vue$1.category_search(q, this.nodes);
  	 this.result = this.$store.getters.sorted(query_result);
       }
   };

  /* script */
  const __vue_script__$e = script$e;

  /* template */
  var __vue_render__$f = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "ul",
      { staticClass: "category-query-plugin-result" },
      _vm._l(_vm.result, function(node) {
        return _c(
          "li",
          [
            _c("router-link", { attrs: { to: "./" + node } }, [
              _vm._v(_vm._s(_vm.nodes[node].name))
            ])
          ],
          1
        )
      }),
      0
    )
  };
  var __vue_staticRenderFns__$f = [];
  __vue_render__$f._withStripped = true;

    /* style */
    const __vue_inject_styles__$f = undefined;
    /* scoped */
    const __vue_scope_id__$f = undefined;
    /* module identifier */
    const __vue_module_identifier__$f = undefined;
    /* functional template */
    const __vue_is_functional_template__$f = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var QueryPlugin = normalizeComponent_1(
      { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
      __vue_inject_styles__$f,
      __vue_script__$e,
      __vue_scope_id__$f,
      __vue_is_functional_template__$f,
      __vue_module_identifier__$f,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //

   var script$f = {
       name: 'cat-slideshow',
       props: ['root'],
       data() {
  	 return {
  	     current_index: 0,
  	     lock_index: 0,
  	     init_index: 0,
  	     all: false,
  	     slides: [],
  	 };
       },
       mounted: function() {
  	 var doc = this.root;
  	 var elements = [];

  	 // Iterate through li nodes and extract these as the slides
  	 for(var n = doc.firstChild.firstChild; n != null; n = n.nextSibling){
  	     if(n.nodeName.toLowerCase() == "li") elements.push(n.innerHTML);
  	 }
  	 
  	 this.slides = elements;
       },
       methods: {
  	 tmp_set_index: function(idx){
  	     this.current_index = idx;
  	 },
  	 reset_index: function(){
  	     this.current_index = this.lock_index;
  	 },
  	 set_index: function(idx){
  	     this.all = false;
  	     this.lock_index = idx;
  	     this.current_index = idx;
  	 }
       }
   };

  /* script */
  const __vue_script__$f = script$f;

  /* template */
  var __vue_render__$g = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "category-slideshow" },
      [
        _vm._l(_vm.slides, function(s, index) {
          return _c(
            "span",
            {
              class:
                _vm.current_index == index && !_vm.all
                  ? "category-slideshow-button category-slideshow-button-current"
                  : "category-slideshow-button category-slideshow-button-other",
              on: {
                mouseover: function($event) {
                  return _vm.tmp_set_index(index)
                },
                mouseout: function($event) {
                  return _vm.reset_index()
                },
                click: function($event) {
                  return _vm.set_index(index)
                }
              }
            },
            [_vm._v("\n\t    " + _vm._s(index) + "\n\t")]
          )
        }),
        _c(
          "span",
          {
            class: _vm.all
              ? "category-slideshow-button category-slideshow-button-current"
              : "category-slideshow-button category-slideshow-button-other",
            on: {
              click: function($event) {
                _vm.all = !_vm.all;
              }
            }
          },
          [_vm._v("\n\t    all\n\t")]
        ),
        !_vm.all
          ? _c("div", {
              staticClass: "category-slideshow-slide",
              domProps: { innerHTML: _vm._s(_vm.slides[_vm.current_index]) }
            })
          : _vm._e(),
        _vm._l(_vm.slides, function(s, index) {
          return _vm.all
            ? _c("div", {
                staticClass: "category-slideshow-slide",
                domProps: { innerHTML: _vm._s(s) }
              })
            : _vm._e()
        })
      ],
      2
    )
  };
  var __vue_staticRenderFns__$g = [];
  __vue_render__$g._withStripped = true;

    /* style */
    const __vue_inject_styles__$g = function (inject) {
      if (!inject) return
      inject("data-v-46ec8c84_0", { source: "\n.category-slideshow[data-v-46ec8c84] {\n    text-align:center;\n    width:100%;\n    overflow-x:scroll;\n}\n.category-slideshow-slide[data-v-46ec8c84] img {\n    max-width: 100% !important;\n}\n.category-slideshow-slide[data-v-46ec8c84] {\n    text-align:center;\n}\n.category-slideshow-caption[data-v-46ec8c84] {\n    text-align:center;\n    margin:auto;\n    width:80%;\n}\n.category-slideshow-button[data-v-46ec8c84] {\n    width:2em;\n    display:inline-block;\n    height:2em;\n    border:2px solid black;\n    text-align:center;\n    cursor:pointer;\n    margin:.5ex 0;\n}\n.category-slideshow-button-other[data-v-46ec8c84] {\n    background-color:#ccc;\n}\n.category-slideshow-button-current[data-v-46ec8c84] {\n    background-color:#8cf;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/plugins/slideshow.vue"],"names":[],"mappings":";AAuDA;IACA,iBAAA;IACA,UAAA;IACA,iBAAA;AACA;AAEA;IACA,0BAAA;AACA;AAEA;IACA,iBAAA;AACA;AAEA;IACA,iBAAA;IACA,WAAA;IACA,SAAA;AACA;AAEA;IACA,SAAA;IACA,oBAAA;IACA,UAAA;IACA,sBAAA;IACA,iBAAA;IACA,cAAA;IACA,aAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,qBAAA;AACA","file":"slideshow.vue","sourcesContent":["<template>\n    <div class=\"category-slideshow\">\n\t<span :class=\"current_index == index && !all ? 'category-slideshow-button category-slideshow-button-current' : 'category-slideshow-button category-slideshow-button-other'\" v-for=\"(s,index) in slides\" v-on:mouseover=\"tmp_set_index(index)\" v-on:mouseout=\"reset_index()\" v-on:click=\"set_index(index)\">\n\t    {{index}}\n\t</span>\n\t<span :class=\"all ? 'category-slideshow-button category-slideshow-button-current' : 'category-slideshow-button category-slideshow-button-other'\" v-on:click=\"all=!all\">\n\t    all\n\t</span>\n\t<div class=\"category-slideshow-slide\" v-html=\"slides[current_index]\" v-if=\"!all\">\n\t</div>\n\t<div class=\"category-slideshow-slide\" v-for=\"(s,index) in slides\" v-if=\"all\" v-html=\"s\">\n\t</div>\n    </div>\n</template>\n<script>\n export default {\n     name: 'cat-slideshow',\n     props: ['root'],\n     data() {\n\t return {\n\t     current_index: 0,\n\t     lock_index: 0,\n\t     init_index: 0,\n\t     all: false,\n\t     slides: [],\n\t };\n     },\n     mounted: function() {\n\t var doc = this.root;\n\t var elements = [];\n\n\t // Iterate through li nodes and extract these as the slides\n\t for(var n = doc.firstChild.firstChild; n != null; n = n.nextSibling){\n\t     if(n.nodeName.toLowerCase() == \"li\") elements.push(n.innerHTML);\n\t }\n\t \n\t this.slides = elements;\n     },\n     methods: {\n\t tmp_set_index: function(idx){\n\t     this.current_index = idx;\n\t },\n\t reset_index: function(){\n\t     this.current_index = this.lock_index;\n\t },\n\t set_index: function(idx){\n\t     this.all = false;\n\t     this.lock_index = idx;\n\t     this.current_index = idx;\n\t }\n     }\n }\n</script>\n\n<style scoped>\n .category-slideshow {\n     text-align:center;\n     width:100%;\n     overflow-x:scroll;\n }\n\n .category-slideshow-slide >>> img {\n     max-width: 100% !important;\n }\n \n .category-slideshow-slide {\n     text-align:center;\n }\n\n .category-slideshow-caption {\n     text-align:center;\n     margin:auto;\n     width:80%;\n }\n\n .category-slideshow-button {\n     width:2em;\n     display:inline-block;\n     height:2em;\n     border:2px solid black;\n     text-align:center;\n     cursor:pointer;\n     margin:.5ex 0;\n }\n\n .category-slideshow-button-other {\n     background-color:#ccc;\n }\n\n .category-slideshow-button-current {\n     background-color:#8cf;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$g = "data-v-46ec8c84";
    /* module identifier */
    const __vue_module_identifier__$g = undefined;
    /* functional template */
    const __vue_is_functional_template__$g = false;
    /* style inject SSR */
    

    
    var SlideshowPlugin = normalizeComponent_1(
      { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
      __vue_inject_styles__$g,
      __vue_script__$f,
      __vue_scope_id__$g,
      __vue_is_functional_template__$g,
      __vue_module_identifier__$g,
      browser,
      undefined
    );

  var codemirror = createCommonjsModule(function (module, exports) {
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: https://codemirror.net/LICENSE

  // This is CodeMirror (https://codemirror.net), a code editor
  // implemented in JavaScript on top of the browser's DOM.
  //
  // You can find some technical background for some of the code below
  // at http://marijnhaverbeke.nl/blog/#cm-internals .

  (function (global, factory) {
     module.exports = factory() ;
  }(commonjsGlobal, (function () {
    // Kludges for bugs and behavior differences that can't be feature
    // detected are enabled based on userAgent etc sniffing.
    var userAgent = navigator.userAgent;
    var platform = navigator.platform;

    var gecko = /gecko\/\d/i.test(userAgent);
    var ie_upto10 = /MSIE \d/.test(userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
    var edge = /Edge\/(\d+)/.exec(userAgent);
    var ie = ie_upto10 || ie_11up || edge;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
    var chrome = !edge && /Chrome\//.test(userAgent);
    var presto = /Opera\//.test(userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
    var phantom = /PhantomJS/.test(userAgent);

    var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
    var android = /Android/.test(userAgent);
    // This is woefully incomplete. Suggestions for alternative methods welcome.
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
    var mac = ios || /Mac/.test(platform);
    var chromeOS = /\bCrOS\b/.test(userAgent);
    var windows = /win/i.test(platform);

    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version) { presto_version = Number(presto_version[1]); }
    if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
    // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || (ie && ie_version >= 9);

    function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

    var rmClass = function(node, cls) {
      var current = node.className;
      var match = classTest(cls).exec(current);
      if (match) {
        var after = current.slice(match.index + match[0].length);
        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
      }
    };

    function removeChildren(e) {
      for (var count = e.childNodes.length; count > 0; --count)
        { e.removeChild(e.firstChild); }
      return e
    }

    function removeChildrenAndAdd(parent, e) {
      return removeChildren(parent).appendChild(e)
    }

    function elt(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) { e.className = className; }
      if (style) { e.style.cssText = style; }
      if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
      else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
      return e
    }
    // wrapper for elt, which removes the elt from the accessibility tree
    function eltP(tag, content, className, style) {
      var e = elt(tag, content, className, style);
      e.setAttribute("role", "presentation");
      return e
    }

    var range;
    if (document.createRange) { range = function(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r
    }; }
    else { range = function(node, start, end) {
      var r = document.body.createTextRange();
      try { r.moveToElementText(node.parentNode); }
      catch(e) { return r }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r
    }; }

    function contains(parent, child) {
      if (child.nodeType == 3) // Android browser always returns false when child is a textnode
        { child = child.parentNode; }
      if (parent.contains)
        { return parent.contains(child) }
      do {
        if (child.nodeType == 11) { child = child.host; }
        if (child == parent) { return true }
      } while (child = child.parentNode)
    }

    function activeElt() {
      // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
      // IE < 10 will throw when accessed while the page is loading or in an iframe.
      // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch(e) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
        { activeElement = activeElement.shadowRoot.activeElement; }
      return activeElement
    }

    function addClass(node, cls) {
      var current = node.className;
      if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
    }
    function joinClasses(a, b) {
      var as = a.split(" ");
      for (var i = 0; i < as.length; i++)
        { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
      return b
    }

    var selectInput = function(node) { node.select(); };
    if (ios) // Mobile Safari apparently has a bug where select() is broken.
      { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
    else if (ie) // Suppress mysterious IE10 errors
      { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

    function bind(f) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function(){return f.apply(null, args)}
    }

    function copyObj(obj, target, overwrite) {
      if (!target) { target = {}; }
      for (var prop in obj)
        { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
          { target[prop] = obj[prop]; } }
      return target
    }

    // Counts the column offset in a string, taking tabs into account.
    // Used mostly to find indentation.
    function countColumn(string, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1) { end = string.length; }
      }
      for (var i = startIndex || 0, n = startValue || 0;;) {
        var nextTab = string.indexOf("\t", i);
        if (nextTab < 0 || nextTab >= end)
          { return n + (end - i) }
        n += nextTab - i;
        n += tabSize - (n % tabSize);
        i = nextTab + 1;
      }
    }

    var Delayed = function() {this.id = null;};
    Delayed.prototype.set = function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    };

    function indexOf(array, elt) {
      for (var i = 0; i < array.length; ++i)
        { if (array[i] == elt) { return i } }
      return -1
    }

    // Number of pixels added to scroller and sizer to hide scrollbar
    var scrollerGap = 30;

    // Returned or thrown by various protocols to signal 'I'm not
    // handling this'.
    var Pass = {toString: function(){return "CodeMirror.Pass"}};

    // Reused option objects for setSelection & friends
    var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

    // The inverse of countColumn -- find the offset that corresponds to
    // a particular column.
    function findColumn(string, goal, tabSize) {
      for (var pos = 0, col = 0;;) {
        var nextTab = string.indexOf("\t", pos);
        if (nextTab == -1) { nextTab = string.length; }
        var skipped = nextTab - pos;
        if (nextTab == string.length || col + skipped >= goal)
          { return pos + Math.min(skipped, goal - col) }
        col += nextTab - pos;
        col += tabSize - (col % tabSize);
        pos = nextTab + 1;
        if (col >= goal) { return pos }
      }
    }

    var spaceStrs = [""];
    function spaceStr(n) {
      while (spaceStrs.length <= n)
        { spaceStrs.push(lst(spaceStrs) + " "); }
      return spaceStrs[n]
    }

    function lst(arr) { return arr[arr.length-1] }

    function map(array, f) {
      var out = [];
      for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
      return out
    }

    function insertSorted(array, value, score) {
      var pos = 0, priority = score(value);
      while (pos < array.length && score(array[pos]) <= priority) { pos++; }
      array.splice(pos, 0, value);
    }

    function nothing() {}

    function createObj(base, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base);
      } else {
        nothing.prototype = base;
        inst = new nothing();
      }
      if (props) { copyObj(props, inst); }
      return inst
    }

    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
      return /\w/.test(ch) || ch > "\x80" &&
        (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
    }
    function isWordChar(ch, helper) {
      if (!helper) { return isWordCharBasic(ch) }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
      return helper.test(ch)
    }

    function isEmpty(obj) {
      for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
      return true
    }

    // Extending unicode characters. A series of a non-extending char +
    // any number of extending chars is treated as a single unit as far
    // as editing and measuring is concerned. This is not fully correct,
    // since some scripts/fonts/browsers also treat other configurations
    // of code points as a group.
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

    // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
    function skipExtendingChars(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
      return pos
    }

    // Returns the value from the range [`from`; `to`] that satisfies
    // `pred` and is closest to `from`. Assumes that at least `to`
    // satisfies `pred`. Supports `from` being greater than `to`.
    function findFirst(pred, from, to) {
      // At any point we are certain `to` satisfies `pred`, don't know
      // whether `from` does.
      var dir = from > to ? -1 : 1;
      for (;;) {
        if (from == to) { return from }
        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid == from) { return pred(mid) ? from : to }
        if (pred(mid)) { to = mid; }
        else { from = mid + dir; }
      }
    }

    // BIDI HELPERS

    function iterateBidiSections(order, from, to, f) {
      if (!order) { return f(from, to, "ltr", 0) }
      var found = false;
      for (var i = 0; i < order.length; ++i) {
        var part = order[i];
        if (part.from < to && part.to > from || from == to && part.to == from) {
          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
          found = true;
        }
      }
      if (!found) { f(from, to, "ltr"); }
    }

    var bidiOther = null;
    function getBidiPartAt(order, ch, sticky) {
      var found;
      bidiOther = null;
      for (var i = 0; i < order.length; ++i) {
        var cur = order[i];
        if (cur.from < ch && cur.to > ch) { return i }
        if (cur.to == ch) {
          if (cur.from != cur.to && sticky == "before") { found = i; }
          else { bidiOther = i; }
        }
        if (cur.from == ch) {
          if (cur.from != cur.to && sticky != "before") { found = i; }
          else { bidiOther = i; }
        }
      }
      return found != null ? found : bidiOther
    }

    // Bidirectional ordering algorithm
    // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
    // that this (partially) implements.

    // One-char codes used for character types:
    // L (L):   Left-to-Right
    // R (R):   Right-to-Left
    // r (AL):  Right-to-Left Arabic
    // 1 (EN):  European Number
    // + (ES):  European Number Separator
    // % (ET):  European Number Terminator
    // n (AN):  Arabic Number
    // , (CS):  Common Number Separator
    // m (NSM): Non-Spacing Mark
    // b (BN):  Boundary Neutral
    // s (B):   Paragraph Separator
    // t (S):   Segment Separator
    // w (WS):  Whitespace
    // N (ON):  Other Neutrals

    // Returns null if characters are ordered as they appear
    // (left-to-right), or an array of sections ({from, to, level}
    // objects) in the order in which they occur visually.
    var bidiOrdering = (function() {
      // Character types for codepoints 0 to 0xff
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      // Character types for codepoints 0x600 to 0x6f9
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code) {
        if (code <= 0xf7) { return lowTypes.charAt(code) }
        else if (0x590 <= code && code <= 0x5f4) { return "R" }
        else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
        else if (0x6ee <= code && code <= 0x8ac) { return "r" }
        else if (0x2000 <= code && code <= 0x200b) { return "w" }
        else if (code == 0x200c) { return "b" }
        else { return "L" }
      }

      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from; this.to = to;
      }

      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";

        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
        var len = str.length, types = [];
        for (var i = 0; i < len; ++i)
          { types.push(charType(str.charCodeAt(i))); }

        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
          var type = types[i$1];
          if (type == "m") { types[i$1] = prev; }
          else { prev = type; }
        }

        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
          var type$1 = types[i$2];
          if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
          else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
        }

        // W4. A single European separator between two European numbers
        // changes to a European number. A single common separator between
        // two numbers of the same type changes to that type.
        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
          var type$2 = types[i$3];
          if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
          else if (type$2 == "," && prev$1 == types[i$3+1] &&
                   (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
          prev$1 = type$2;
        }

        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        for (var i$4 = 0; i$4 < len; ++i$4) {
          var type$3 = types[i$4];
          if (type$3 == ",") { types[i$4] = "N"; }
          else if (type$3 == "%") {
            var end = (void 0);
            for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
            var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
            for (var j = i$4; j < end; ++j) { types[j] = replace; }
            i$4 = end - 1;
          }
        }

        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
          var type$4 = types[i$5];
          if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
          else if (isStrong.test(type$4)) { cur$1 = type$4; }
        }

        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        for (var i$6 = 0; i$6 < len; ++i$6) {
          if (isNeutral.test(types[i$6])) {
            var end$1 = (void 0);
            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
            var before = (i$6 ? types[i$6-1] : outerType) == "L";
            var after = (end$1 < len ? types[end$1] : outerType) == "L";
            var replace$1 = before == after ? (before ? "L" : "R") : outerType;
            for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
            i$6 = end$1 - 1;
          }
        }

        // Here we depart from the documented algorithm, in order to avoid
        // building up an actual levels array. Since there are only three
        // levels (0, 1, 2) in an implementation that doesn't take
        // explicit embedding into account, we can build up the order on
        // the fly, without following the level-based algorithm.
        var order = [], m;
        for (var i$7 = 0; i$7 < len;) {
          if (countsAsLeft.test(types[i$7])) {
            var start = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
            order.push(new BidiSpan(0, start, i$7));
          } else {
            var pos = i$7, at = order.length;
            for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
            for (var j$2 = pos; j$2 < i$7;) {
              if (countsAsNum.test(types[j$2])) {
                if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
                order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                pos = j$2;
              } else { ++j$2; }
            }
            if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
          }
        }
        if (direction == "ltr") {
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push(new BidiSpan(0, len - m[0].length, len));
          }
        }

        return direction == "rtl" ? order.reverse() : order
      }
    })();

    // Get the bidi ordering for the given line (and cache it). Returns
    // false for lines that are fully left-to-right, and an array of
    // BidiSpan objects otherwise.
    function getOrder(line, direction) {
      var order = line.order;
      if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
      return order
    }

    // EVENT HANDLING

    // Lightweight event framework. on/off also work on DOM nodes,
    // registering native DOM handlers.

    var noHandlers = [];

    var on = function(emitter, type, f) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type, f, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type, f);
      } else {
        var map$$1 = emitter._handlers || (emitter._handlers = {});
        map$$1[type] = (map$$1[type] || noHandlers).concat(f);
      }
    };

    function getHandlers(emitter, type) {
      return emitter._handlers && emitter._handlers[type] || noHandlers
    }

    function off(emitter, type, f) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type, f, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type, f);
      } else {
        var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
        if (arr) {
          var index = indexOf(arr, f);
          if (index > -1)
            { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
        }
      }
    }

    function signal(emitter, type /*, values...*/) {
      var handlers = getHandlers(emitter, type);
      if (!handlers.length) { return }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
    }

    // The DOM events that CodeMirror handles can be overridden by
    // registering a (non-DOM) handler on the editor for the event name,
    // and preventDefault-ing the event in that handler.
    function signalDOMEvent(cm, e, override) {
      if (typeof e == "string")
        { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
      signal(cm, override || e.type, cm, e);
      return e_defaultPrevented(e) || e.codemirrorIgnore
    }

    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) { return }
      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
        { set.push(arr[i]); } }
    }

    function hasHandler(emitter, type) {
      return getHandlers(emitter, type).length > 0
    }

    // Add on and off methods to a constructor's prototype, to make
    // registering events on such objects more convenient.
    function eventMixin(ctor) {
      ctor.prototype.on = function(type, f) {on(this, type, f);};
      ctor.prototype.off = function(type, f) {off(this, type, f);};
    }

    // Due to the fact that we still support jurassic IE versions, some
    // compatibility wrappers are needed.

    function e_preventDefault(e) {
      if (e.preventDefault) { e.preventDefault(); }
      else { e.returnValue = false; }
    }
    function e_stopPropagation(e) {
      if (e.stopPropagation) { e.stopPropagation(); }
      else { e.cancelBubble = true; }
    }
    function e_defaultPrevented(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
    }
    function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

    function e_target(e) {return e.target || e.srcElement}
    function e_button(e) {
      var b = e.which;
      if (b == null) {
        if (e.button & 1) { b = 1; }
        else if (e.button & 2) { b = 3; }
        else if (e.button & 4) { b = 2; }
      }
      if (mac && e.ctrlKey && b == 1) { b = 3; }
      return b
    }

    // Detect drag-and-drop
    var dragAndDrop = function() {
      // There is *some* kind of drag-and-drop support in IE6-8, but I
      // couldn't get it to work yet.
      if (ie && ie_version < 9) { return false }
      var div = elt('div');
      return "draggable" in div || "dragDrop" in div
    }();

    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test = elt("span", "\u200b");
        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0)
          { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
      }
      var node = zwspSupported ? elt("span", "\u200b") :
        elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node
    }

    // Feature-detect IE's crummy client rect reporting for bidi text
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) { return badBidiRects }
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
      var r0 = range(txt, 0, 1).getBoundingClientRect();
      var r1 = range(txt, 1, 2).getBoundingClientRect();
      removeChildren(measure);
      if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
      return badBidiRects = (r1.right - r0.right < 3)
    }

    // See if "".split is the broken IE version, if so, provide an
    // alternative way to split lines.
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf("\n", pos);
        if (nl == -1) { nl = string.length; }
        var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result
    } : function (string) { return string.split(/\r\n?|\n/); };

    var hasSelection = window.getSelection ? function (te) {
      try { return te.selectionStart != te.selectionEnd }
      catch(e) { return false }
    } : function (te) {
      var range$$1;
      try {range$$1 = te.ownerDocument.selection.createRange();}
      catch(e) {}
      if (!range$$1 || range$$1.parentElement() != te) { return false }
      return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
    };

    var hasCopyEvent = (function () {
      var e = elt("div");
      if ("oncopy" in e) { return true }
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function"
    })();

    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) { return badZoomedRects }
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
    }

    // Known modes, by name and by MIME
    var modes = {}, mimeModes = {};

    // Extra arguments are stored as the mode's dependencies, which is
    // used by (legacy) mechanisms like loadmode.js to automatically
    // load a mode. (Preferred mechanism is the require/define calls.)
    function defineMode(name, mode) {
      if (arguments.length > 2)
        { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
      modes[name] = mode;
    }

    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }

    // Given a MIME type, a {name, ...options} config object, or a name
    // string, return a mode config object.
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") { found = {name: found}; }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml")
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json")
      }
      if (typeof spec == "string") { return {name: spec} }
      else { return spec || {name: "null"} }
    }

    // Given a mode spec (anything that resolveMode accepts), find and
    // initialize an actual mode object.
    function getMode(options, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) { return getMode(options, "text/plain") }
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop in exts) {
          if (!exts.hasOwnProperty(prop)) { continue }
          if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
          modeObj[prop] = exts[prop];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) { modeObj.helperType = spec.helperType; }
      if (spec.modeProps) { for (var prop$1 in spec.modeProps)
        { modeObj[prop$1] = spec.modeProps[prop$1]; } }

      return modeObj
    }

    // This can be used to attach properties to mode objects from
    // outside the actual mode definition.
    var modeExtensions = {};
    function extendMode(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
      copyObj(properties, exts);
    }

    function copyState(mode, state) {
      if (state === true) { return state }
      if (mode.copyState) { return mode.copyState(state) }
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array) { val = val.concat([]); }
        nstate[n] = val;
      }
      return nstate
    }

    // Given a mode and a state (for that mode), find the inner mode and
    // state at the position that the state refers to.
    function innerMode(mode, state) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state);
        if (!info || info.mode == mode) { break }
        state = info.state;
        mode = info.mode;
      }
      return info || {mode: mode, state: state}
    }

    function startState(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true
    }

    // STRING STREAM

    // Fed to the mode parsers, provides helper functions to make
    // parsers more succinct.

    var StringStream = function(string, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };

    StringStream.prototype.eol = function () {return this.pos >= this.string.length};
    StringStream.prototype.sol = function () {return this.pos == this.lineStart};
    StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
    StringStream.prototype.next = function () {
      if (this.pos < this.string.length)
        { return this.string.charAt(this.pos++) }
    };
    StringStream.prototype.eat = function (match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") { ok = ch == match; }
      else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
      if (ok) {++this.pos; return ch}
    };
    StringStream.prototype.eatWhile = function (match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start
    };
    StringStream.prototype.eatSpace = function () {
        var this$1 = this;

      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
      return this.pos > start
    };
    StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
    StringStream.prototype.skipTo = function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true}
    };
    StringStream.prototype.backUp = function (n) {this.pos -= n;};
    StringStream.prototype.column = function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
    };
    StringStream.prototype.indentation = function () {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
    };
    StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) { this.pos += pattern.length; }
          return true
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) { return null }
        if (match && consume !== false) { this.pos += match[0].length; }
        return match
      }
    };
    StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
    StringStream.prototype.hideFirstChars = function (n, inner) {
      this.lineStart += n;
      try { return inner() }
      finally { this.lineStart -= n; }
    };
    StringStream.prototype.lookAhead = function (n) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n)
    };
    StringStream.prototype.baseToken = function () {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos)
    };

    // Find the line object corresponding to the given line number.
    function getLine(doc, n) {
      n -= doc.first;
      if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
      var chunk = doc;
      while (!chunk.lines) {
        for (var i = 0;; ++i) {
          var child = chunk.children[i], sz = child.chunkSize();
          if (n < sz) { chunk = child; break }
          n -= sz;
        }
      }
      return chunk.lines[n]
    }

    // Get the part of a document between two positions, as an array of
    // strings.
    function getBetween(doc, start, end) {
      var out = [], n = start.line;
      doc.iter(start.line, end.line + 1, function (line) {
        var text = line.text;
        if (n == end.line) { text = text.slice(0, end.ch); }
        if (n == start.line) { text = text.slice(start.ch); }
        out.push(text);
        ++n;
      });
      return out
    }
    // Get the lines between from and to, as array of strings.
    function getLines(doc, from, to) {
      var out = [];
      doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
      return out
    }

    // Update the height of a line, propagating the height change
    // upwards to parent nodes.
    function updateLineHeight(line, height) {
      var diff = height - line.height;
      if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
    }

    // Given a line object, find its line number by walking up through
    // its parent links.
    function lineNo(line) {
      if (line.parent == null) { return null }
      var cur = line.parent, no = indexOf(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i = 0;; ++i) {
          if (chunk.children[i] == cur) { break }
          no += chunk.children[i].chunkSize();
        }
      }
      return no + cur.first
    }

    // Find the line at the given vertical position, using the height
    // information in the document tree.
    function lineAtHeight(chunk, h) {
      var n = chunk.first;
      outer: do {
        for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
          var child = chunk.children[i$1], ch = child.height;
          if (h < ch) { chunk = child; continue outer }
          h -= ch;
          n += child.chunkSize();
        }
        return n
      } while (!chunk.lines)
      var i = 0;
      for (; i < chunk.lines.length; ++i) {
        var line = chunk.lines[i], lh = line.height;
        if (h < lh) { break }
        h -= lh;
      }
      return n + i
    }

    function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

    function lineNumberFor(options, i) {
      return String(options.lineNumberFormatter(i + options.firstLineNumber))
    }

    // A Pos instance represents a position within the text.
    function Pos(line, ch, sticky) {
      if ( sticky === void 0 ) sticky = null;

      if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
      this.line = line;
      this.ch = ch;
      this.sticky = sticky;
    }

    // Compare two positions, return 0 if they are the same, a negative
    // number when a is less, and a positive number otherwise.
    function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

    function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

    function copyPos(x) {return Pos(x.line, x.ch)}
    function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
    function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

    // Most of the external API clips given positions to make sure they
    // actually exist within the document.
    function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
    function clipPos(doc, pos) {
      if (pos.line < doc.first) { return Pos(doc.first, 0) }
      var last = doc.first + doc.size - 1;
      if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
      return clipToLen(pos, getLine(doc, pos.line).text.length)
    }
    function clipToLen(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
      else if (ch < 0) { return Pos(pos.line, 0) }
      else { return pos }
    }
    function clipPosArray(doc, array) {
      var out = [];
      for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
      return out
    }

    var SavedContext = function(state, lookAhead) {
      this.state = state;
      this.lookAhead = lookAhead;
    };

    var Context = function(doc, state, line, lookAhead) {
      this.state = state;
      this.doc = doc;
      this.line = line;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };

    Context.prototype.lookAhead = function (n) {
      var line = this.doc.getLine(this.line + n);
      if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
      return line
    };

    Context.prototype.baseToken = function (n) {
        var this$1 = this;

      if (!this.baseTokens) { return null }
      while (this.baseTokens[this.baseTokenPos] <= n)
        { this$1.baseTokenPos += 2; }
      var type = this.baseTokens[this.baseTokenPos + 1];
      return {type: type && type.replace(/( |^)overlay .*/, ""),
              size: this.baseTokens[this.baseTokenPos] - n}
    };

    Context.prototype.nextLine = function () {
      this.line++;
      if (this.maxLookAhead > 0) { this.maxLookAhead--; }
    };

    Context.fromSaved = function (doc, saved, line) {
      if (saved instanceof SavedContext)
        { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
      else
        { return new Context(doc, copyState(doc.mode, saved), line) }
    };

    Context.prototype.save = function (copy) {
      var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
    };


    // Compute a style array (an array starting with a mode generation
    // -- for invalidation -- followed by pairs of end positions and
    // style strings), which is used to highlight the tokens on the
    // line.
    function highlightLine(cm, line, context, forceToEnd) {
      // A styles array always starts with a number identifying the
      // mode/overlays that it is based on (for easy invalidation).
      var st = [cm.state.modeGen], lineClasses = {};
      // Compute the base array of styles
      runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
              lineClasses, forceToEnd);
      var state = context.state;

      // Run overlays, adjust style array.
      var loop = function ( o ) {
        context.baseTokens = st;
        var overlay = cm.state.overlays[o], i = 1, at = 0;
        context.state = true;
        runMode(cm, line.text, overlay.mode, context, function (end, style) {
          var start = i;
          // Ensure there's a token end at the current position, and that i points at it
          while (at < end) {
            var i_end = st[i];
            if (i_end > end)
              { st.splice(i, 1, end, st[i+1], i_end); }
            i += 2;
            at = Math.min(end, i_end);
          }
          if (!style) { return }
          if (overlay.opaque) {
            st.splice(start, i - start, end, "overlay " + style);
            i = start + 2;
          } else {
            for (; start < i; start += 2) {
              var cur = st[start+1];
              st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
            }
          }
        }, lineClasses);
        context.state = state;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };

      for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

      return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
    }

    function getLineStyles(cm, line, updateFrontier) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var context = getContextBefore(cm, lineNo(line));
        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
        var result = highlightLine(cm, line, context);
        if (resetState) { context.state = resetState; }
        line.stateAfter = context.save(!resetState);
        line.styles = result.styles;
        if (result.classes) { line.styleClasses = result.classes; }
        else if (line.styleClasses) { line.styleClasses = null; }
        if (updateFrontier === cm.doc.highlightFrontier)
          { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
      }
      return line.styles
    }

    function getContextBefore(cm, n, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) { return new Context(doc, true, n) }
      var start = findStartLine(cm, n, precise);
      var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
      var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

      doc.iter(start, n, function (line) {
        processLine(cm, line.text, context);
        var pos = context.line;
        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) { doc.modeFrontier = context.line; }
      return context
    }

    // Lightweight form of highlight -- proceed over this line and
    // update state, but don't save a style array. Used for lines that
    // aren't currently visible.
    function processLine(cm, text, context, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream(text, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text == "") { callBlankLine(mode, context.state); }
      while (!stream.eol()) {
        readToken(mode, stream, context.state);
        stream.start = stream.pos;
      }
    }

    function callBlankLine(mode, state) {
      if (mode.blankLine) { return mode.blankLine(state) }
      if (!mode.innerMode) { return }
      var inner = innerMode(mode, state);
      if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
    }

    function readToken(mode, stream, state, inner) {
      for (var i = 0; i < 10; i++) {
        if (inner) { inner[0] = innerMode(mode, state).mode; }
        var style = mode.token(stream, state);
        if (stream.pos > stream.start) { return style }
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.")
    }

    var Token = function(stream, type, state) {
      this.start = stream.start; this.end = stream.pos;
      this.string = stream.current();
      this.type = type || null;
      this.state = state;
    };

    // Utility for getTokenAt and getLineTokens
    function takeToken(cm, pos, precise, asArray) {
      var doc = cm.doc, mode = doc.mode, style;
      pos = clipPos(doc, pos);
      var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
      if (asArray) { tokens = []; }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style = readToken(mode, stream, context.state);
        if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
      }
      return asArray ? tokens : new Token(stream, style, context.state)
    }

    function extractLineClasses(type, output) {
      if (type) { for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) { break }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null)
          { output[prop] = lineClass[2]; }
        else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
          { output[prop] += " " + lineClass[2]; }
      } }
      return type
    }

    // Run the given mode's parser over a line, calling f for each token.
    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text, cm.options.tabSize, context), style;
      var inner = cm.options.addModeClass && [null];
      if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) { processLine(cm, text, context, stream.pos); }
          stream.pos = text.length;
          style = null;
        } else {
          style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
        }
        if (!flattenSpans || curStyle != style) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5000);
            f(curStart, curStyle);
          }
          curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        // Webkit seems to refuse to render text nodes longer than 57444
        // characters, and returns inaccurate measurements in nodes
        // starting around 5000 chars.
        var pos = Math.min(stream.pos, curStart + 5000);
        f(pos, curStyle);
        curStart = pos;
      }
    }

    // Finds the line to start with when starting a parse. Tries to
    // find a line with a stateAfter, so that it can start with a
    // valid state. If that fails, it returns the line with the
    // smallest indentation, which tends to need the least context to
    // parse correctly.
    function findStartLine(cm, n, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
      for (var search = n; search > lim; --search) {
        if (search <= doc.first) { return doc.first }
        var line = getLine(doc, search - 1), after = line.stateAfter;
        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
          { return search }
        var indented = countColumn(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline
    }

    function retreatFrontier(doc, n) {
      doc.modeFrontier = Math.min(doc.modeFrontier, n);
      if (doc.highlightFrontier < n - 10) { return }
      var start = doc.first;
      for (var line = n - 1; line > start; line--) {
        var saved = getLine(doc, line).stateAfter;
        // change is on 3
        // state on line 1 looked ahead 2 -- so saw 3
        // test 1 + 2 < 3 should cover this
        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
          start = line + 1;
          break
        }
      }
      doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
    }

    // Optimize some code when these features are not used.
    var sawReadOnlySpans = false, sawCollapsedSpans = false;

    function seeReadOnlySpans() {
      sawReadOnlySpans = true;
    }

    function seeCollapsedSpans() {
      sawCollapsedSpans = true;
    }

    // TEXTMARKER SPANS

    function MarkedSpan(marker, from, to) {
      this.marker = marker;
      this.from = from; this.to = to;
    }

    // Search an array of spans for a span matching the given marker.
    function getMarkedSpanFor(spans, marker) {
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) { return span }
      } }
    }
    // Remove a span from an array, returning undefined if no spans are
    // left (we don't store arrays for lines without spans).
    function removeMarkedSpan(spans, span) {
      var r;
      for (var i = 0; i < spans.length; ++i)
        { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
      return r
    }
    // Add a span to a line.
    function addMarkedSpan(line, span) {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      span.marker.attachLine(line);
    }

    // Used for the algorithm that adjusts markers for a change in the
    // document. These functions cut an array of spans at a given
    // character position, returning an array of remaining chunks (or
    // undefined if nothing remains).
    function markedSpansBefore(old, startCh, isInsert) {
      var nw;
      if (old) { for (var i = 0; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
          ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      } }
      return nw
    }
    function markedSpansAfter(old, endCh, isInsert) {
      var nw;
      if (old) { for (var i = 0; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
          ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                                span.to == null ? null : span.to - endCh));
        }
      } }
      return nw
    }

    // Given a change object, compute the new set of marker spans that
    // cover the line in which the change took place. Removes spans
    // entirely within the change, reconnects spans belonging to the
    // same marker that appear on both sides of the change, and cuts off
    // spans partially within the change. Returns an array of span
    // arrays with one element for each line in (after) the change.
    function stretchSpansOverChange(doc, change) {
      if (change.full) { return null }
      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) { return null }

      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      // Get the spans that 'stick out' on both sides
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);

      // Next, merge those two ends
      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        // Fix up .to properties of first
        for (var i = 0; i < first.length; ++i) {
          var span = first[i];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) { span.to = startCh; }
            else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
          }
        }
      }
      if (last) {
        // Fix up .from in last (or move them into first in case of sameLine)
        for (var i$1 = 0; i$1 < last.length; ++i$1) {
          var span$1 = last[i$1];
          if (span$1.to != null) { span$1.to += offset; }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset;
              if (sameLine) { (first || (first = [])).push(span$1); }
            }
          } else {
            span$1.from += offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        }
      }
      // Make sure we didn't create any zero-length spans
      if (first) { first = clearEmptySpans(first); }
      if (last && last != first) { last = clearEmptySpans(last); }

      var newMarkers = [first];
      if (!sameLine) {
        // Fill gap with whole-line-spans
        var gap = change.text.length - 2, gapMarkers;
        if (gap > 0 && first)
          { for (var i$2 = 0; i$2 < first.length; ++i$2)
            { if (first[i$2].to == null)
              { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
        for (var i$3 = 0; i$3 < gap; ++i$3)
          { newMarkers.push(gapMarkers); }
        newMarkers.push(last);
      }
      return newMarkers
    }

    // Remove spans that are empty and don't have a clearWhenEmpty
    // option of false.
    function clearEmptySpans(spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
          { spans.splice(i--, 1); }
      }
      if (!spans.length) { return null }
      return spans
    }

    // Used to 'clip' out readOnly ranges when making a change.
    function removeReadOnlyRanges(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function (line) {
        if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            { (markers || (markers = [])).push(mark); }
        } }
      });
      if (!markers) { return null }
      var parts = [{from: from, to: to}];
      for (var i = 0; i < markers.length; ++i) {
        var mk = markers[i], m = mk.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p = parts[j];
          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
          var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
            { newParts.push({from: p.from, to: m.from}); }
          if (dto > 0 || !mk.inclusiveRight && !dto)
            { newParts.push({from: m.to, to: p.to}); }
          parts.splice.apply(parts, newParts);
          j += newParts.length - 3;
        }
      }
      return parts
    }

    // Connect or disconnect spans from a line.
    function detachMarkedSpans(line) {
      var spans = line.markedSpans;
      if (!spans) { return }
      for (var i = 0; i < spans.length; ++i)
        { spans[i].marker.detachLine(line); }
      line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
      if (!spans) { return }
      for (var i = 0; i < spans.length; ++i)
        { spans[i].marker.attachLine(line); }
      line.markedSpans = spans;
    }

    // Helpers used when computing which overlapping collapsed span
    // counts as the larger one.
    function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
    function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

    // Returns a number indicating which of two overlapping collapsed
    // spans is larger (and thus includes the other). Falls back to
    // comparing ids when the spans cover exactly the same range.
    function compareCollapsedMarkers(a, b) {
      var lenDiff = a.lines.length - b.lines.length;
      if (lenDiff != 0) { return lenDiff }
      var aPos = a.find(), bPos = b.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
      if (fromCmp) { return -fromCmp }
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
      if (toCmp) { return toCmp }
      return b.id - a.id
    }

    // Find out whether a line ends or starts in a collapsed span. If
    // so, return the marker for that span.
    function collapsedSpanAtSide(line, start) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
            (!found || compareCollapsedMarkers(found, sp.marker) < 0))
          { found = sp.marker; }
      } }
      return found
    }
    function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
    function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

    function collapsedSpanAround(line, ch) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) { for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
            (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
      } }
      return found
    }

    // Test whether there exists a collapsed span that partially
    // overlaps (covers the start or end, but not both) of a new span.
    // Such overlap is not allowed.
    function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
      var line = getLine(doc, lineNo$$1);
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) { for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) { continue }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
            fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
          { return true }
      } }
    }

    // A visual line is a line as drawn on the screen. Folding, for
    // example, can cause multiple logical lines to appear on the same
    // visual line. This finds the start of the visual line that the
    // given line is part of (usually that is the line itself).
    function visualLine(line) {
      var merged;
      while (merged = collapsedSpanAtStart(line))
        { line = merged.find(-1, true).line; }
      return line
    }

    function visualLineEnd(line) {
      var merged;
      while (merged = collapsedSpanAtEnd(line))
        { line = merged.find(1, true).line; }
      return line
    }

    // Returns an array of logical lines that continue the visual line
    // started by the argument, or undefined if there are no such lines.
    function visualLineContinued(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line
        ;(lines || (lines = [])).push(line);
      }
      return lines
    }

    // Get the line number of the start of the visual line that the
    // given line number is part of.
    function visualLineNo(doc, lineN) {
      var line = getLine(doc, lineN), vis = visualLine(line);
      if (line == vis) { return lineN }
      return lineNo(vis)
    }

    // Get the line number of the start of the next visual line after
    // the given line.
    function visualLineEndNo(doc, lineN) {
      if (lineN > doc.lastLine()) { return lineN }
      var line = getLine(doc, lineN), merged;
      if (!lineIsHidden(doc, line)) { return lineN }
      while (merged = collapsedSpanAtEnd(line))
        { line = merged.find(1, true).line; }
      return lineNo(line) + 1
    }

    // Compute whether a line is hidden. Lines count as hidden when they
    // are part of a visual line that starts with another line, or when
    // they are entirely covered by collapsed, non-widget span.
    function lineIsHidden(doc, line) {
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) { continue }
        if (sp.from == null) { return true }
        if (sp.marker.widgetNode) { continue }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          { return true }
      } }
    }
    function lineIsHiddenInner(doc, line, span) {
      if (span.to == null) {
        var end = span.marker.find(1, true);
        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
      }
      if (span.marker.inclusiveRight && span.to == line.text.length)
        { return true }
      for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
        sp = line.markedSpans[i];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
            (sp.to == null || sp.to != span.from) &&
            (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
            lineIsHiddenInner(doc, line, sp)) { return true }
      }
    }

    // Find the height above the given line.
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);

      var h = 0, chunk = lineObj.parent;
      for (var i = 0; i < chunk.lines.length; ++i) {
        var line = chunk.lines[i];
        if (line == lineObj) { break }
        else { h += line.height; }
      }
      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
        for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
          var cur = p.children[i$1];
          if (cur == chunk) { break }
          else { h += cur.height; }
        }
      }
      return h
    }

    // Compute the character length of a line, taking into account
    // collapsed ranges (see markText) that might hide parts, and join
    // other lines onto it.
    function lineLength(line) {
      if (line.height == 0) { return 0 }
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found$1 = merged.find(0, true);
        len -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len += cur.text.length - found$1.to.ch;
      }
      return len
    }

    // Find the longest line in the document.
    function findMaxLine(cm) {
      var d = cm.display, doc = cm.doc;
      d.maxLine = getLine(doc, doc.first);
      d.maxLineLength = lineLength(d.maxLine);
      d.maxLineChanged = true;
      doc.iter(function (line) {
        var len = lineLength(line);
        if (len > d.maxLineLength) {
          d.maxLineLength = len;
          d.maxLine = line;
        }
      });
    }

    // LINE DATA STRUCTURE

    // Line objects. These hold state related to a line, including
    // highlighting info (the styles array).
    var Line = function(text, markedSpans, estimateHeight) {
      this.text = text;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight ? estimateHeight(this) : 1;
    };

    Line.prototype.lineNo = function () { return lineNo(this) };
    eventMixin(Line);

    // Change the content (text, markers) of a line. Automatically
    // invalidates cached information and tries to re-estimate the
    // line's height.
    function updateLine(line, text, markedSpans, estimateHeight) {
      line.text = text;
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
      if (line.order != null) { line.order = null; }
      detachMarkedSpans(line);
      attachMarkedSpans(line, markedSpans);
      var estHeight = estimateHeight ? estimateHeight(line) : 1;
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    }

    // Detach a line from the document tree and its markers.
    function cleanUpLine(line) {
      line.parent = null;
      detachMarkedSpans(line);
    }

    // Convert a style as returned by a mode (either null, or a string
    // containing one or more styles) to a CSS style. This is cached,
    // and also looks for line-wide styles.
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
      if (!style || /^\s*$/.test(style)) { return null }
      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache[style] ||
        (cache[style] = style.replace(/\S+/g, "cm-$&"))
    }

    // Render the DOM representation of the text of a line. Also builds
    // up a 'line map', which points at the DOM nodes that represent
    // specific stretches of text, and is used by the measuring code.
    // The returned object contains the DOM node, this map, and
    // information about line-wide styles that were set by the mode.
    function buildLineContent(cm, lineView) {
      // The padding-right forces the element to have a 'border', which
      // is needed on Webkit to be able to get line-level bounding
      // rectangles for it (in measureChar).
      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                     col: 0, pos: 0, cm: cm,
                     trailingSpace: false,
                     splitSpaces: cm.getOption("lineWrapping")};
      lineView.measure = {};

      // Iterate over the logical lines that make up this visual line.
      for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
        var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
        builder.pos = 0;
        builder.addToken = buildToken;
        // Optionally wire in some hacks into the token-rendering
        // algorithm, to deal with browser quirks.
        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
          { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass)
            { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
          if (line.styleClasses.textClass)
            { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
        }

        // Ensure at least a single node is present, for measuring.
        if (builder.map.length == 0)
          { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

        // Store the map and a cache object for the current logical line
        if (i == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
    (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
          ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }

      // See issue #2901
      if (webkit) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
          { builder.content.className = "cm-tab-wrap-hack"; }
      }

      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className)
        { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

      return builder
    }

    function defaultSpecialCharPlaceholder(ch) {
      var token = elt("span", "\u2022", "cm-invalidchar");
      token.title = "\\u" + ch.charCodeAt(0).toString(16);
      token.setAttribute("aria-label", token.title);
      return token
    }

    // Build up the DOM representation for a single token, and add it to
    // the line map. Takes care to render special characters separately.
    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
      if (!text) { return }
      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text)) {
        builder.col += text.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text.length, content);
        if (ie && ie_version < 9) { mustWrap = true; }
        builder.pos += text.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m = special.exec(text);
          var skipped = m ? m.index - pos : text.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
            else { content.appendChild(txt); }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m) { break }
          pos += skipped + 1;
          var txt$1 = (void 0);
          if (m[0] == "\t") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "\t");
            builder.col += tabWidth;
          } else if (m[0] == "\r" || m[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
            txt$1.setAttribute("cm-text", m[0]);
            if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
            else { content.appendChild(txt$1); }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
      if (style || startStyle || endStyle || mustWrap || css) {
        var fullStyle = style || "";
        if (startStyle) { fullStyle += startStyle; }
        if (endStyle) { fullStyle += endStyle; }
        var token = elt("span", [content], fullStyle, css);
        if (attributes) {
          for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
            { token.setAttribute(attr, attributes[attr]); } }
        }
        return builder.content.appendChild(token)
      }
      builder.content.appendChild(content);
    }

    // Change some spaces to NBSP to prevent the browser from collapsing
    // trailing spaces at the end of a line when rendering text (issue #1362).
    function splitSpaces(text, trailingBefore) {
      if (text.length > 1 && !/  /.test(text)) { return text }
      var spaceBefore = trailingBefore, result = "";
      for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
          { ch = "\u00a0"; }
        result += ch;
        spaceBefore = ch == " ";
      }
      return result
    }

    // Work around nonsense dimensions being reported for stretches of
    // right-to-left text.
    function buildTokenBadBidi(inner, order) {
      return function (builder, text, style, startStyle, endStyle, css, attributes) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start = builder.pos, end = start + text.length;
        for (;;) {
          // Find the part that overlaps with the start of this text
          var part = (void 0);
          for (var i = 0; i < order.length; i++) {
            part = order[i];
            if (part.to > start && part.from <= start) { break }
          }
          if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
          inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
          startStyle = null;
          text = text.slice(part.to - start);
          start = part.to;
        }
      }
    }

    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode;
      if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget)
          { widget = builder.content.appendChild(document.createElement("span")); }
        widget.setAttribute("cm-marker", marker.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size;
      builder.trailingSpace = false;
    }

    // Outputs a number of spans to make up a line, taking highlighting
    // and marked text into account.
    function insertLineContent(line, builder, styles) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i$1 = 1; i$1 < styles.length; i$1+=2)
          { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
        return
      }

      var len = allText.length, pos = 0, i = 1, text = "", style, css;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
      for (;;) {
        if (nextChange == pos) { // Update current marker set
          spanStyle = spanEndStyle = spanStartStyle = css = "";
          attributes = null;
          collapsed = null; nextChange = Infinity;
          var foundBookmarks = [], endStyles = (void 0);
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m = sp.marker;
            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
              foundBookmarks.push(m);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m.className) { spanStyle += " " + m.className; }
              if (m.css) { css = (css ? css + ";" : "") + m.css; }
              if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
              if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
              // support for the old title property
              // https://github.com/codemirror/CodeMirror/pull/5673
              if (m.title) { (attributes || (attributes = {})).title = m.title; }
              if (m.attributes) {
                for (var attr in m.attributes)
                  { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
              }
              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                { collapsed = sp; }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
            { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

          if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
            { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                               collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) { return }
            if (collapsed.to == pos) { collapsed = false; }
          }
        }
        if (pos >= len) { break }

        var upto = Math.min(len, nextChange);
        while (true) {
          if (text) {
            var end = pos + text.length;
            if (!collapsed) {
              var tokenText = end > upto ? text.slice(0, upto - pos) : text;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                               spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
            }
            if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
            pos = end;
            spanStartStyle = "";
          }
          text = allText.slice(at, at = styles[i++]);
          style = interpretTokenStyle(styles[i++], builder.cm.options);
        }
      }
    }


    // These objects are used to represent the visible (currently drawn)
    // part of the document. A LineView may correspond to multiple
    // logical lines, if those are connected by collapsed ranges.
    function LineView(doc, line, lineN) {
      // The starting line
      this.line = line;
      // Continuing lines, if any
      this.rest = visualLineContinued(line);
      // Number of logical lines in this visual line
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc, line);
    }

    // Create a range of LineView objects for the given lines.
    function buildViewArray(cm, from, to) {
      var array = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array.push(view);
      }
      return array
    }

    var operationGroup = null;

    function pushOperation(op) {
      if (operationGroup) {
        operationGroup.ops.push(op);
      } else {
        op.ownsGroup = operationGroup = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }

    function fireCallbacksForOps(group) {
      // Calls delayed callbacks and cursorActivity handlers until no
      // new ones appear
      var callbacks = group.delayedCallbacks, i = 0;
      do {
        for (; i < callbacks.length; i++)
          { callbacks[i].call(null); }
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers)
            { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
              { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
        }
      } while (i < callbacks.length)
    }

    function finishOperation(op, endCb) {
      var group = op.ownsGroup;
      if (!group) { return }

      try { fireCallbacksForOps(group); }
      finally {
        operationGroup = null;
        endCb(group);
      }
    }

    var orphanDelayedCallbacks = null;

    // Often, we want to signal events at a point where we are in the
    // middle of some work, but don't want the handler to start calling
    // other methods on the editor, which might be in an inconsistent
    // state or simply not expect any other events to happen.
    // signalLater looks whether there are any handlers, and schedules
    // them to be executed when the last operation ends, or, if no
    // operation is active, when a timeout fires.
    function signalLater(emitter, type /*, values...*/) {
      var arr = getHandlers(emitter, type);
      if (!arr.length) { return }
      var args = Array.prototype.slice.call(arguments, 2), list;
      if (operationGroup) {
        list = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list = orphanDelayedCallbacks;
      } else {
        list = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      var loop = function ( i ) {
        list.push(function () { return arr[i].apply(null, args); });
      };

      for (var i = 0; i < arr.length; ++i)
        loop( i );
    }

    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
    }

    // When an aspect of a line changes, a string is added to
    // lineView.changes. This updates the relevant part of the line's
    // DOM structure.
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type = lineView.changes[j];
        if (type == "text") { updateLineText(cm, lineView); }
        else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
        else if (type == "class") { updateLineClasses(cm, lineView); }
        else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
      }
      lineView.changes = null;
    }

    // Lines with gutter elements, widgets or a background class need to
    // be wrapped, and have the extra elements added to the wrapper div
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode)
          { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
        lineView.node.appendChild(lineView.text);
        if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
      }
      return lineView.node
    }

    function updateLineBackground(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) { cls += " CodeMirror-linebackground"; }
      if (lineView.background) {
        if (cls) { lineView.background.className = cls; }
        else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
      } else if (cls) {
        var wrap = ensureLineWrapped(lineView);
        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }

    // Wrapper around buildLineContent which will reuse the structure
    // in display.externalMeasured when possible.
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built
      }
      return buildLineContent(cm, lineView)
    }

    // Redraw the line's text. Interacts with the background and text
    // classes because the mode may output tokens that influence these
    // classes.
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) { lineView.node = built.pre; }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }

    function updateLineClasses(cm, lineView) {
      updateLineBackground(cm, lineView);
      if (lineView.line.wrapClass)
        { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
      else if (lineView.node != lineView.text)
        { lineView.node.className = ""; }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }

    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap = ensureLineWrapped(lineView);
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                        ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$1 = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
        cm.display.input.setUneditable(gutterWrap);
        wrap$1.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass)
          { gutterWrap.className += " " + lineView.line.gutterClass; }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
          { lineView.lineNumber = gutterWrap.appendChild(
            elt("div", lineNumberFor(cm.options, lineN),
                "CodeMirror-linenumber CodeMirror-gutter-elt",
                ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
        if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                       ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
        } }
      }
    }

    function updateLineWidgets(cm, lineView, dims) {
      if (lineView.alignable) { lineView.alignable = null; }
      for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
        next = node.nextSibling;
        if (node.className == "CodeMirror-linewidget")
          { lineView.node.removeChild(node); }
      }
      insertLineWidgets(cm, lineView, dims);
    }

    // Build a line's DOM representation from scratch
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) { lineView.bgClass = built.bgClass; }
      if (built.textClass) { lineView.textClass = built.textClass; }

      updateLineClasses(cm, lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(cm, lineView, dims);
      return lineView.node
    }

    // A lineView may contain multiple logical lines (when merged by
    // collapsed spans). The widgets for all of them need to be drawn.
    function insertLineWidgets(cm, lineView, dims) {
      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
    }

    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
      if (!line.widgets) { return }
      var wrap = ensureLineWrapped(lineView);
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
        if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
        positionLineWidget(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above)
          { wrap.insertBefore(node, lineView.gutter || lineView.text); }
        else
          { wrap.appendChild(node); }
        signalLater(widget, "redraw");
      }
    }

    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
    (lineView.alignable || (lineView.alignable = [])).push(node);
        var width = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
      }
    }

    function widgetHeight(widget) {
      if (widget.height != null) { return widget.height }
      var cm = widget.doc.cm;
      if (!cm) { return 0 }
      if (!contains(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter)
          { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
        if (widget.noHScroll)
          { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight
    }

    // Return true when the given mouse event happened in a widget
    function eventInWidget(display, e) {
      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
        if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
            (n.parentNode == display.sizer && n != display.mover))
          { return true }
      }
    }

    // POSITION MEASUREMENT

    function paddingTop(display) {return display.lineSpace.offsetTop}
    function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
    function paddingH(display) {
      if (display.cachedPaddingH) { return display.cachedPaddingH }
      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
      if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
      return data
    }

    function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
    function displayWidth(cm) {
      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
    }
    function displayHeight(cm) {
      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
    }

    // Ensure the lineView.wrapping.heights array is populated. This is
    // an array of bottom offsets for the lines that make up a drawn
    // line. When lineWrapping is on, there might be more than one
    // height.
    function ensureLineHeights(cm, lineView, rect) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i = 0; i < rects.length - 1; i++) {
            var cur = rects[i], next = rects[i + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2)
              { heights.push((cur.bottom + next.top) / 2 - rect.top); }
          }
        }
        heights.push(rect.bottom - rect.top);
      }
    }

    // Find a line map (mapping character offsets to text nodes) and a
    // measurement cache for the given line number. (A line view might
    // contain multiple lines when collapsed ranges are present.)
    function mapFromLineView(lineView, line, lineN) {
      if (lineView.line == line)
        { return {map: lineView.measure.map, cache: lineView.measure.cache} }
      for (var i = 0; i < lineView.rest.length; i++)
        { if (lineView.rest[i] == line)
          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
        { if (lineNo(lineView.rest[i$1]) > lineN)
          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
    }

    // Render a line into the hidden node display.externalMeasured. Used
    // when measurement is needed for a line that's not in the viewport.
    function updateExternalMeasurement(cm, line) {
      line = visualLine(line);
      var lineN = lineNo(line);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view
    }

    // Get a {top, bottom, left, right} box (in line-local coordinates)
    // for a given character.
    function measureChar(cm, line, ch, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
    }

    // Find a line view that corresponds to the given line number.
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
        { return cm.display.view[findViewIndex(cm, lineN)] }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
        { return ext }
    }

    // Measurement can be split in two steps, the set-up work that
    // applies to the whole line, and the measurement of the actual
    // character. Functions like coordsChar, that need to do a lot of
    // measurements in a row, can thus ensure that the set-up work is
    // only done once.
    function prepareMeasureForLine(cm, line) {
      var lineN = lineNo(line);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges(cm, view, lineN, getDimensions(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view)
        { view = updateExternalMeasurement(cm, line); }

      var info = mapFromLineView(view, line, lineN);
      return {
        line: line, view: view, rect: null,
        map: info.map, cache: info.cache, before: info.before,
        hasHeights: false
      }
    }

    // Given a prepared measurement object, measures the position of an
    // actual character (or fetches it from the cache).
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) { ch = -1; }
      var key = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect)
          { prepared.rect = prepared.view.text.getBoundingClientRect(); }
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch, bias);
        if (!found.bogus) { prepared.cache[key] = found; }
      }
      return {left: found.left, right: found.right,
              top: varHeight ? found.rtop : found.top,
              bottom: varHeight ? found.rbottom : found.bottom}
    }

    var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

    function nodeAndOffsetInLineMap(map$$1, ch, bias) {
      var node, start, end, collapse, mStart, mEnd;
      // First, search the line map for the text node corresponding to,
      // or closest to, the target character.
      for (var i = 0; i < map$$1.length; i += 3) {
        mStart = map$$1[i];
        mEnd = map$$1[i + 1];
        if (ch < mStart) {
          start = 0; end = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start = ch - mStart;
          end = start + 1;
        } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
          end = mEnd - mStart;
          start = end - 1;
          if (ch >= mEnd) { collapse = "right"; }
        }
        if (start != null) {
          node = map$$1[i + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
            { collapse = bias; }
          if (bias == "left" && start == 0)
            { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
              node = map$$1[(i -= 3) + 2];
              collapse = "left";
            } }
          if (bias == "right" && start == mEnd - mStart)
            { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
              node = map$$1[(i += 3) + 2];
              collapse = "right";
            } }
          break
        }
      }
      return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
    }

    function getUsefulRect(rects, bias) {
      var rect = nullRect;
      if (bias == "left") { for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) { break }
      } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) { break }
      } }
      return rect
    }

    function measureCharInner(cm, prepared, ch, bias) {
      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
      var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

      var rect;
      if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
        for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
          while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
          if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
            { rect = node.parentNode.getBoundingClientRect(); }
          else
            { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
          if (rect.left || rect.right || start == 0) { break }
          end = start;
          start = start - 1;
          collapse = "right";
        }
        if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
      } else { // If it is a widget, simply get the box for the whole widget.
        if (start > 0) { collapse = bias = "right"; }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
          { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
        else
          { rect = node.getBoundingClientRect(); }
      }
      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan)
          { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
        else
          { rect = nullRect; }
      }

      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
      var mid = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i = 0;
      for (; i < heights.length - 1; i++)
        { if (mid < heights[i]) { break } }
      var top = i ? heights[i - 1] : 0, bot = heights[i];
      var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                    right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                    top: top, bottom: bot};
      if (!rect.left && !rect.right) { result.bogus = true; }
      if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

      return result
    }

    // Work around problem with bounding client rects on ranges being
    // returned incorrectly when zoomed on IE10 and below.
    function maybeUpdateRectForZooming(measure, rect) {
      if (!window.screen || screen.logicalXDPI == null ||
          screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
        { return rect }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {left: rect.left * scaleX, right: rect.right * scaleX,
              top: rect.top * scaleY, bottom: rect.bottom * scaleY}
    }

    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
          { lineView.measure.caches[i] = {}; } }
      }
    }

    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i = 0; i < cm.display.view.length; i++)
        { clearLineMeasurementCacheFor(cm.display.view[i]); }
    }

    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
      cm.display.lineNumChars = null;
    }

    function pageScrollX() {
      // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
      // which causes page_Offset and bounding client rects to use
      // different reference viewports and invalidate our calculations.
      if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft
    }
    function pageScrollY() {
      if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop
    }

    function widgetTopHeight(lineObj) {
      var height = 0;
      if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
        { height += widgetHeight(lineObj.widgets[i]); } } }
      return height
    }

    // Converts a {top, bottom, left, right} box from line-local
    // coordinates into another coordinate system. Context may be one of
    // "line", "div" (display.lineDiv), "local"./null (editor), "window",
    // or "page".
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
      if (!includeWidgets) {
        var height = widgetTopHeight(lineObj);
        rect.top += height; rect.bottom += height;
      }
      if (context == "line") { return rect }
      if (!context) { context = "local"; }
      var yOff = heightAtLine(lineObj);
      if (context == "local") { yOff += paddingTop(cm.display); }
      else { yOff -= cm.display.viewOffset; }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect.left += xOff; rect.right += xOff;
      }
      rect.top += yOff; rect.bottom += yOff;
      return rect
    }

    // Coverts a box from "div" coords to another coordinate system.
    // Context may be "window", "page", "div", or "local"./null.
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") { return coords }
      var left = coords.left, top = coords.top;
      // First move into "page" coordinate system
      if (context == "page") {
        left -= pageScrollX();
        top -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left += localBox.left;
        top += localBox.top;
      }

      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
    }

    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
    }

    // Returns a box for a given cursor position, which may have an
    // 'other' property containing the position of the secondary cursor
    // on a bidi boundary.
    // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
    // and after `char - 1` in writing order of `char - 1`
    // A cursor Pos(line, char, "after") is on the same visual line as `char`
    // and before `char` in writing order of `char`
    // Examples (upper-case letters are RTL, lower-case are LTR):
    //     Pos(0, 1, ...)
    //     before   after
    // ab     a|b     a|b
    // aB     a|B     aB|
    // Ab     |Ab     A|b
    // AB     B|A     B|A
    // Every position after the last character on a line is considered to stick
    // to the last character on the line.
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine(cm.doc, pos.line);
      if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
      function get(ch, right) {
        var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
        if (right) { m.left = m.right; } else { m.right = m.left; }
        return intoCoordSystem(cm, lineObj, m, context)
      }
      var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
      if (ch >= lineObj.text.length) {
        ch = lineObj.text.length;
        sticky = "before";
      } else if (ch <= 0) {
        ch = 0;
        sticky = "after";
      }
      if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

      function getBidi(ch, partPos, invert) {
        var part = order[partPos], right = part.level == 1;
        return get(invert ? ch - 1 : ch, right != invert)
      }
      var partPos = getBidiPartAt(order, ch, sticky);
      var other = bidiOther;
      var val = getBidi(ch, partPos, sticky == "before");
      if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
      return val
    }

    // Used to cheaply estimate the coordinates for a position. Used for
    // intermediate scroll updates.
    function estimateCoords(cm, pos) {
      var left = 0;
      pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
      var lineObj = getLine(cm.doc, pos.line);
      var top = heightAtLine(lineObj) + paddingTop(cm.display);
      return {left: left, right: left, top: top, bottom: top + lineObj.height}
    }

    // Positions returned by coordsChar contain some extra information.
    // xRel is the relative x position of the input coordinates compared
    // to the found position (so xRel > 0 means the coordinates are to
    // the right of the character position, for example). When outside
    // is true, that means the coordinates lie outside the line's
    // vertical range.
    function PosWithInfo(line, ch, sticky, outside, xRel) {
      var pos = Pos(line, ch, sticky);
      pos.xRel = xRel;
      if (outside) { pos.outside = outside; }
      return pos
    }

    // Compute the character position closest to the given coordinates.
    // Input must be lineSpace-local ("div" coordinate system).
    function coordsChar(cm, x, y) {
      var doc = cm.doc;
      y += cm.display.viewOffset;
      if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
      if (lineN > last)
        { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
      if (x < 0) { x = 0; }

      var lineObj = getLine(doc, lineN);
      for (;;) {
        var found = coordsCharInner(cm, lineObj, lineN, x, y);
        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) { return found }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) { return rangeEnd }
        lineObj = getLine(doc, lineN = rangeEnd.line);
      }
    }

    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
      y -= widgetTopHeight(lineObj);
      var end = lineObj.text.length;
      var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
      end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
      return {begin: begin, end: end}
    }

    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
      if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
    }

    // Returns true if the given side of a box is after the given
    // coordinates, in top-to-bottom, left-to-right order.
    function boxIsAfter(box, x, y, left) {
      return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
    }

    function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
      // Move y into line-local coordinate space
      y -= heightAtLine(lineObj);
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
      // When directly calling `measureCharPrepared`, we have to adjust
      // for the widgets at this line.
      var widgetHeight$$1 = widgetTopHeight(lineObj);
      var begin = 0, end = lineObj.text.length, ltr = true;

      var order = getOrder(lineObj, cm.doc.direction);
      // If the line isn't plain left-to-right text, first figure out
      // which bidi section the coordinates fall into.
      if (order) {
        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                     (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
        ltr = part.level != 1;
        // The awkward -1 offsets are needed because findFirst (called
        // on these below) will treat its first bound as inclusive,
        // second as exclusive, but we want to actually address the
        // characters in the part's range
        begin = ltr ? part.from : part.to - 1;
        end = ltr ? part.to : part.from - 1;
      }

      // A binary search to find the first character whose bounding box
      // starts after the coordinates. If we run across any whose box wrap
      // the coordinates, store that.
      var chAround = null, boxAround = null;
      var ch = findFirst(function (ch) {
        var box = measureCharPrepared(cm, preparedMeasure, ch);
        box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
        if (!boxIsAfter(box, x, y, false)) { return false }
        if (box.top <= y && box.left <= x) {
          chAround = ch;
          boxAround = box;
        }
        return true
      }, begin, end);

      var baseX, sticky, outside = false;
      // If a box around the coordinates was found, use that
      if (boxAround) {
        // Distinguish coordinates nearer to the left or right side of the box
        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
        ch = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        // (Adjust for extended bound, if necessary.)
        if (!ltr && (ch == end || ch == begin)) { ch++; }
        // To determine which side to associate with, get the box to the
        // left of the character and compare it's vertical position to the
        // coordinates
        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
          (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
          "after" : "before";
        // Now get accurate coordinates for this place, in order to get a
        // base X position
        var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
      }

      ch = skipExtendingChars(lineObj.text, ch, 1);
      return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
    }

    function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
      // Bidi parts are sorted left-to-right, and in a non-line-wrapping
      // situation, we can take this ordering to correspond to the visual
      // ordering. This finds the first part whose end is after the given
      // coordinates.
      var index = findFirst(function (i) {
        var part = order[i], ltr = part.level != 1;
        return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                       "line", lineObj, preparedMeasure), x, y, true)
      }, 0, order.length - 1);
      var part = order[index];
      // If this isn't the first part, the part's start is also after
      // the coordinates, and the coordinates aren't on the same line as
      // that start, move one part back.
      if (index > 0) {
        var ltr = part.level != 1;
        var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                                 "line", lineObj, preparedMeasure);
        if (boxIsAfter(start, x, y, true) && start.top > y)
          { part = order[index - 1]; }
      }
      return part
    }

    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
      // In a wrapped line, rtl text on wrapping boundaries can do things
      // that don't correspond to the ordering in our `order` array at
      // all, so a binary search doesn't work, and we want to return a
      // part that only spans one line so that the binary search in
      // coordsCharInner is safe. As such, we first find the extent of the
      // wrapped line, and then do a flat search in which we discard any
      // spans that aren't on the line.
      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
      var begin = ref.begin;
      var end = ref.end;
      if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
      var part = null, closestDist = null;
      for (var i = 0; i < order.length; i++) {
        var p = order[i];
        if (p.from >= end || p.to <= begin) { continue }
        var ltr = p.level != 1;
        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
        // Weigh against spans ending before this, so that they are only
        // picked if nothing ends after
        var dist = endX < x ? x - endX + 1e9 : endX - x;
        if (!part || closestDist > dist) {
          part = p;
          closestDist = dist;
        }
      }
      if (!part) { part = order[order.length - 1]; }
      // Clip the part to the wrapped line.
      if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
      if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
      return part
    }

    var measureText;
    // Compute the default text height.
    function textHeight(display) {
      if (display.cachedTextHeight != null) { return display.cachedTextHeight }
      if (measureText == null) {
        measureText = elt("pre", null, "CodeMirror-line-like");
        // Measure a bunch of lines, for browsers that compute
        // fractional heights.
        for (var i = 0; i < 49; ++i) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height = measureText.offsetHeight / 50;
      if (height > 3) { display.cachedTextHeight = height; }
      removeChildren(display.measure);
      return height || 1
    }

    // Compute the default character width.
    function charWidth(display) {
      if (display.cachedCharWidth != null) { return display.cachedCharWidth }
      var anchor = elt("span", "xxxxxxxxxx");
      var pre = elt("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd(display.measure, pre);
      var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
      if (width > 2) { display.cachedCharWidth = width; }
      return width || 10
    }

    // Do a bulk-read of the DOM positions and sizes needed to draw the
    // view, so that we don't interleave reading and writing to the DOM.
    function getDimensions(cm) {
      var d = cm.display, left = {}, width = {};
      var gutterLeft = d.gutters.clientLeft;
      for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
        var id = cm.display.gutterSpecs[i].className;
        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
        width[id] = n.clientWidth;
      }
      return {fixedPos: compensateForHScroll(d),
              gutterTotalWidth: d.gutters.offsetWidth,
              gutterLeft: left,
              gutterWidth: width,
              wrapperWidth: d.wrapper.clientWidth}
    }

    // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
    // but using getBoundingClientRect to get a sub-pixel-accurate
    // result.
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
    }

    // Returns a function that estimates the height of a line, to use as
    // first approximation until the line becomes visible (and is thus
    // properly measurable).
    function estimateHeight(cm) {
      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function (line) {
        if (lineIsHidden(cm.doc, line)) { return 0 }

        var widgetsHeight = 0;
        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
        } }

        if (wrapping)
          { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
        else
          { return widgetsHeight + th }
      }
    }

    function estimateLineHeights(cm) {
      var doc = cm.doc, est = estimateHeight(cm);
      doc.iter(function (line) {
        var estHeight = est(line);
        if (estHeight != line.height) { updateLineHeight(line, estHeight); }
      });
    }

    // Given a mouse event, find the corresponding position. If liberal
    // is false, it checks whether a gutter or scrollbar was clicked,
    // and returns null if it was. forRect is used by rectangular
    // selections, and tries to estimate a character position even for
    // coordinates beyond the right of the text.
    function posFromMouse(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

      var x, y, space = display.lineSpace.getBoundingClientRect();
      // Fails unpredictably on IE[67] when mouse is dragged around quickly.
      try { x = e.clientX - space.left; y = e.clientY - space.top; }
      catch (e) { return null }
      var coords = coordsChar(cm, x, y), line;
      if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords
    }

    // Find the view element corresponding to a given line. Return null
    // when the line isn't visible.
    function findViewIndex(cm, n) {
      if (n >= cm.display.viewTo) { return null }
      n -= cm.display.viewFrom;
      if (n < 0) { return null }
      var view = cm.display.view;
      for (var i = 0; i < view.length; i++) {
        n -= view[i].size;
        if (n < 0) { return i }
      }
    }

    // Updates the display.view data structure for a given change to the
    // document. From and to are in pre-change coordinates. Lendiff is
    // the amount of lines added or subtracted by the change. This is
    // used for changes that span multiple lines, or change the way
    // lines are divided into visual lines. regLineChange (below)
    // registers single-line changes.
    function regChange(cm, from, to, lendiff) {
      if (from == null) { from = cm.doc.first; }
      if (to == null) { to = cm.doc.first + cm.doc.size; }
      if (!lendiff) { lendiff = 0; }

      var display = cm.display;
      if (lendiff && to < display.viewTo &&
          (display.updateLineNumbers == null || display.updateLineNumbers > from))
        { display.updateLineNumbers = from; }

      cm.curOp.viewChanged = true;

      if (from >= display.viewTo) { // Change after
        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
          { resetView(cm); }
      } else if (to <= display.viewFrom) { // Change before
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
        resetView(cm);
      } else if (from <= display.viewFrom) { // Top overlap
        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to >= display.viewTo) { // Bottom overlap
        var cut$1 = viewCuttingPoint(cm, from, from, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView(cm);
        }
      } else { // Gap in the middle
        var cutTop = viewCuttingPoint(cm, from, from, -1);
        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index)
            .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
            .concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }

      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN)
          { ext.lineN += lendiff; }
        else if (from < ext.lineN + ext.size)
          { display.externalMeasured = null; }
      }
    }

    // Register a change to a single line. Type must be one of "text",
    // "gutter", "class", "widget"
    function regLineChange(cm, line, type) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
        { display.externalMeasured = null; }

      if (line < display.viewFrom || line >= display.viewTo) { return }
      var lineView = display.view[findViewIndex(cm, line)];
      if (lineView.node == null) { return }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf(arr, type) == -1) { arr.push(type); }
    }

    // Clear the view.
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }

    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
        { return {index: index, lineN: newN} }
      var n = cm.display.viewFrom;
      for (var i = 0; i < index; i++)
        { n += view[i].size; }
      if (n != oldN) {
        if (dir > 0) {
          if (index == view.length - 1) { return null }
          diff = (n + view[index].size) - oldN;
          index++;
        } else {
          diff = n - oldN;
        }
        oldN += diff; newN += diff;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
        index += dir;
      }
      return {index: index, lineN: newN}
    }

    // Force the view to cover a given range, adding empty view element
    // or clipping off existing ones as needed.
    function adjustView(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from)
          { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
        else if (display.viewFrom < from)
          { display.view = display.view.slice(findViewIndex(cm, from)); }
        display.viewFrom = from;
        if (display.viewTo < to)
          { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
        else if (display.viewTo > to)
          { display.view = display.view.slice(0, findViewIndex(cm, to)); }
      }
      display.viewTo = to;
    }

    // Count the number of lines in the view whose DOM representation is
    // out of date (or nonexistent).
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i = 0; i < view.length; i++) {
        var lineView = view[i];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
      }
      return dirty
    }

    function updateSelection(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }

    function prepareSelection(cm, primary) {
      if ( primary === void 0 ) primary = true;

      var doc = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();

      for (var i = 0; i < doc.sel.ranges.length; i++) {
        if (!primary && i == doc.sel.primIndex) { continue }
        var range$$1 = doc.sel.ranges[i];
        if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
        var collapsed = range$$1.empty();
        if (collapsed || cm.options.showCursorWhenSelecting)
          { drawSelectionCursor(cm, range$$1.head, curFragment); }
        if (!collapsed)
          { drawSelectionRange(cm, range$$1, selFragment); }
      }
      return result
    }

    // Draws a cursor for the given range
    function drawSelectionCursor(cm, head, output) {
      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

      var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

      if (pos.other) {
        // Secondary cursor, shown when on a 'jump' in bi-directional text
        var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
      }
    }

    function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

    // Draws the given range as a highlighted selection
    function drawSelectionRange(cm, range$$1, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH(cm.display), leftSide = padding.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
      var docLTR = doc.direction == "ltr";

      function add(left, top, width, bottom) {
        if (top < 0) { top = 0; }
        top = Math.round(top);
        bottom = Math.round(bottom);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
      }

      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine(doc, line);
        var lineLen = lineObj.text.length;
        var start, end;
        function coords(ch, bias) {
          return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
        }

        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
          var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch, prop)[prop]
        }

        var order = getOrder(lineObj, doc.direction);
        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
          var ltr = dir == "ltr";
          var fromPos = coords(from, ltr ? "left" : "right");
          var toPos = coords(to - 1, ltr ? "right" : "left");

          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
          var first = i == 0, last = !order || i == order.length - 1;
          if (toPos.top - fromPos.top <= 3) { // Single line
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add(left, fromPos.top, right - left, fromPos.bottom);
          } else { // Multiple lines
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
            }
            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }

          if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
          if (cmpCoords(toPos, start) < 0) { start = toPos; }
          if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
          if (cmpCoords(toPos, end) < 0) { end = toPos; }
        });
        return {start: start, end: end}
      }

      var sFrom = range$$1.from(), sTo = range$$1.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top)
          { add(leftSide, leftEnd.bottom, null, rightStart.top); }
      }

      output.appendChild(fragment);
    }

    // Cursor-blinking
    function restartBlink(cm) {
      if (!cm.state.focused) { return }
      var display = cm.display;
      clearInterval(display.blinker);
      var on = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0)
        { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
          cm.options.cursorBlinkRate); }
      else if (cm.options.cursorBlinkRate < 0)
        { display.cursorDiv.style.visibility = "hidden"; }
    }

    function ensureFocus(cm) {
      if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
    }

    function delayBlurEvent(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function () { if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      } }, 100);
    }

    function onFocus(cm, e) {
      if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

      if (cm.options.readOnly == "nocursor") { return }
      if (!cm.state.focused) {
        signal(cm, "focus", cm, e);
        cm.state.focused = true;
        addClass(cm.display.wrapper, "CodeMirror-focused");
        // This test prevents this from firing when a context
        // menu is closed (since the input reset would kill the
        // select-all detection hack)
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
        }
        cm.display.input.receivedFocus();
      }
      restartBlink(cm);
    }
    function onBlur(cm, e) {
      if (cm.state.delayingBlurEvent) { return }

      if (cm.state.focused) {
        signal(cm, "blur", cm, e);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
    }

    // Read the actual heights of the rendered lines, and update their
    // stored heights to match.
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      for (var i = 0; i < display.view.length; i++) {
        var cur = display.view[i], wrapping = cm.options.lineWrapping;
        var height = (void 0), width = 0;
        if (cur.hidden) { continue }
        if (ie && ie_version < 8) {
          var bot = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
          // Check that lines don't extend past the right of the current
          // editor width
          if (!wrapping && cur.text.firstChild)
            { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
        }
        var diff = cur.line.height - height;
        if (diff > .005 || diff < -.005) {
          updateLineHeight(cur.line, height);
          updateWidgetHeight(cur.line);
          if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
            { updateWidgetHeight(cur.rest[j]); } }
        }
        if (width > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width / charWidth(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
    }

    // Read and store the height of line widgets associated with the
    // given line.
    function updateWidgetHeight(line) {
      if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i], parent = w.node.parentNode;
        if (parent) { w.height = parent.offsetHeight; }
      } }
    }

    // Compute the lines that are visible in a given viewport (defaults
    // the the current scroll position). viewport may contain top,
    // height, and ensure (see op.scrollToPos) properties.
    function visibleLines(display, doc, viewport) {
      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
      top = Math.floor(top - paddingTop(display));
      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

      var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
      // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
      // forces those lines into the viewport (if possible).
      if (viewport && viewport.ensure) {
        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
        if (ensureFrom < from) {
          from = ensureFrom;
          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
          to = ensureTo;
        }
      }
      return {from: from, to: Math.max(to, from + 1)}
    }

    // SCROLLING THINGS INTO VIEW

    // If an editor sits on the top or bottom of the window, partially
    // scrolled out of view, this ensures that the cursor is visible.
    function maybeScrollWindow(cm, rect) {
      if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect.top + box.top < 0) { doScroll = true; }
      else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }

    // Scroll a given position into view (immediately), verifying that
    // it actually became visible (as line heights are accurately
    // measured, the position of something may 'drift' during drawing).
    function scrollPosIntoView(cm, pos, end, margin) {
      if (margin == null) { margin = 0; }
      var rect;
      if (!cm.options.lineWrapping && pos == end) {
        // Set pos and end to the cursor positions around the character pos sticks to
        // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
        // If pos == Pos(_, 0, "before"), pos and end are unchanged
        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      }
      for (var limit = 0; limit < 5; limit++) {
        var changed = false;
        var coords = cursorCoords(cm, pos);
        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
        rect = {left: Math.min(coords.left, endCoords.left),
                top: Math.min(coords.top, endCoords.top) - margin,
                right: Math.max(coords.left, endCoords.left),
                bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
        var scrollPos = calculateScrollPos(cm, rect);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
        }
        if (!changed) { break }
      }
      return rect
    }

    // Scroll a given set of coordinates into view (immediately).
    function scrollIntoView(cm, rect) {
      var scrollPos = calculateScrollPos(cm, rect);
      if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
      if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
    }

    // Calculate a new scroll position needed to scroll the given
    // rectangle into view. Returns an object with scrollTop and
    // scrollLeft properties. When these are undefined, the
    // vertical/horizontal position does not need to be adjusted.
    function calculateScrollPos(cm, rect) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (rect.top < 0) { rect.top = 0; }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen = displayHeight(cm), result = {};
      if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
      if (rect.top < screentop) {
        result.scrollTop = atTop ? 0 : rect.top;
      } else if (rect.bottom > screentop + screen) {
        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
        if (newTop != screentop) { result.scrollTop = newTop; }
      }

      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
      var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
      var tooWide = rect.right - rect.left > screenw;
      if (tooWide) { rect.right = rect.left + screenw; }
      if (rect.left < 10)
        { result.scrollLeft = 0; }
      else if (rect.left < screenleft)
        { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
      else if (rect.right > screenw + screenleft - 3)
        { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
      return result
    }

    // Store a relative adjustment to the scroll position in the current
    // operation (to be applied when the operation finishes).
    function addToScrollTop(cm, top) {
      if (top == null) { return }
      resolveScrollToPos(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }

    // Make sure that at the end of the operation the current cursor is
    // shown.
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
    }

    function scrollToCoords(cm, x, y) {
      if (x != null || y != null) { resolveScrollToPos(cm); }
      if (x != null) { cm.curOp.scrollLeft = x; }
      if (y != null) { cm.curOp.scrollTop = y; }
    }

    function scrollToRange(cm, range$$1) {
      resolveScrollToPos(cm);
      cm.curOp.scrollToPos = range$$1;
    }

    // When an operation has its scrollToPos property set, and another
    // scroll action is applied before the end of the operation, this
    // 'simulates' scrolling that position into view in a cheap way, so
    // that the effect of intermediate scroll commands is not ignored.
    function resolveScrollToPos(cm) {
      var range$$1 = cm.curOp.scrollToPos;
      if (range$$1) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
        scrollToCoordsRange(cm, from, to, range$$1.margin);
      }
    }

    function scrollToCoordsRange(cm, from, to, margin) {
      var sPos = calculateScrollPos(cm, {
        left: Math.min(from.left, to.left),
        top: Math.min(from.top, to.top) - margin,
        right: Math.max(from.right, to.right),
        bottom: Math.max(from.bottom, to.bottom) + margin
      });
      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }

    // Sync the scrollable area and scrollbars, ensure the viewport
    // covers the visible area.
    function updateScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
      if (!gecko) { updateDisplaySimple(cm, {top: val}); }
      setScrollTop(cm, val, true);
      if (gecko) { updateDisplaySimple(cm); }
      startWorker(cm, 100);
    }

    function setScrollTop(cm, val, forceScroll) {
      val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
      if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
    }

    // Sync scroller and scrollbar, ensure the gutter elements are
    // aligned.
    function setScrollLeft(cm, val, isScroller, forceScroll) {
      val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
      cm.display.scrollbars.setScrollLeft(val);
    }

    // SCROLLBARS

    // Prepare DOM reads needed to update the scrollbars. Done in one
    // shot to minimize update/measure roundtrips.
    function measureForScrollbars(cm) {
      var d = cm.display, gutterW = d.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
      return {
        clientHeight: d.scroller.clientHeight,
        viewHeight: d.wrapper.clientHeight,
        scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
        viewWidth: d.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap(cm) + d.barHeight,
        nativeBarWidth: d.nativeBarWidth,
        gutterWidth: gutterW
      }
    }

    var NativeScrollbars = function(place, scroll, cm) {
      this.cm = cm;
      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert.tabIndex = horiz.tabIndex = -1;
      place(vert); place(horiz);

      on(vert, "scroll", function () {
        if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
      });
      on(horiz, "scroll", function () {
        if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
      });

      this.checkedZeroWidth = false;
      // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
      if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
    };

    NativeScrollbars.prototype.update = function (measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) { this.zeroWidthHack(); }
        this.checkedZeroWidth = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
    };

    NativeScrollbars.prototype.setScrollLeft = function (pos) {
      if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
      if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
    };

    NativeScrollbars.prototype.setScrollTop = function (pos) {
      if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
      if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
    };

    NativeScrollbars.prototype.zeroWidthHack = function () {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed;
      this.disableVert = new Delayed;
    };

    NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // right corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
            : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
        else { delay.set(1000, maybeDisable); }
      }
      delay.set(1000, maybeDisable);
    };

    NativeScrollbars.prototype.clear = function () {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    };

    var NullScrollbars = function () {};

    NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
    NullScrollbars.prototype.setScrollLeft = function () {};
    NullScrollbars.prototype.setScrollTop = function () {};
    NullScrollbars.prototype.clear = function () {};

    function updateScrollbars(cm, measure) {
      if (!measure) { measure = measureForScrollbars(cm); }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner(cm, measure);
      for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
          { updateHeightsInViewport(cm); }
        updateScrollbarsInner(cm, measureForScrollbars(cm));
        startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
      }
    }

    // Re-synchronize the fake scrollbars with the actual size of the
    // content.
    function updateScrollbarsInner(cm, measure) {
      var d = cm.display;
      var sizes = d.scrollbars.update(measure);

      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

      if (sizes.right && sizes.bottom) {
        d.scrollbarFiller.style.display = "block";
        d.scrollbarFiller.style.height = sizes.bottom + "px";
        d.scrollbarFiller.style.width = sizes.right + "px";
      } else { d.scrollbarFiller.style.display = ""; }
      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d.gutterFiller.style.display = "block";
        d.gutterFiller.style.height = sizes.bottom + "px";
        d.gutterFiller.style.width = measure.gutterWidth + "px";
      } else { d.gutterFiller.style.display = ""; }
    }

    var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

    function initScrollbars(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass)
          { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
      }

      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        // Prevent clicks in the scrollbars from killing focus
        on(node, "mousedown", function () {
          if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
        });
        node.setAttribute("cm-not-content", "true");
      }, function (pos, axis) {
        if (axis == "horizontal") { setScrollLeft(cm, pos); }
        else { updateScrollTop(cm, pos); }
      }, cm);
      if (cm.display.scrollbars.addClass)
        { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    // Operations are used to wrap a series of changes to the editor
    // state in such a way that each change won't have to update the
    // cursor and display (which would be awkward, slow, and
    // error-prone). Instead, display updates are batched and then all
    // combined and executed at once.

    var nextOpId = 0;
    // Start a new operation.
    function startOperation(cm) {
      cm.curOp = {
        cm: cm,
        viewChanged: false,      // Flag that indicates that lines might need to be redrawn
        startHeight: cm.doc.height, // Used to detect need to update scrollbar
        forceUpdate: false,      // Used to force a redraw
        updateInput: 0,       // Whether to reset the input textarea
        typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
        changeObjs: null,        // Accumulated changes, for firing change events
        cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
        cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
        selectionChanged: false, // Whether the selection needs to be redrawn
        updateMaxLine: false,    // Set when the widest line needs to be determined anew
        scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
        scrollToPos: null,       // Used to scroll to a specific position
        focus: false,
        id: ++nextOpId           // Unique ID
      };
      pushOperation(cm.curOp);
    }

    // Finish an operation, updating the display and signalling delayed events
    function endOperation(cm) {
      var op = cm.curOp;
      if (op) { finishOperation(op, function (group) {
        for (var i = 0; i < group.ops.length; i++)
          { group.ops[i].cm.curOp = null; }
        endOperations(group);
      }); }
    }

    // The DOM updates done when an operation finishes are batched so
    // that the minimum number of relayouts are required.
    function endOperations(group) {
      var ops = group.ops;
      for (var i = 0; i < ops.length; i++) // Read DOM
        { endOperation_R1(ops[i]); }
      for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
        { endOperation_W1(ops[i$1]); }
      for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
        { endOperation_R2(ops[i$2]); }
      for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
        { endOperation_W2(ops[i$3]); }
      for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
        { endOperation_finish(ops[i$4]); }
    }

    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars(cm);
      if (op.updateMaxLine) { findMaxLine(cm); }

      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
        op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                           op.scrollToPos.to.line >= display.viewTo) ||
        display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate &&
        new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
    }

    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }

    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) { updateHeightsInViewport(cm); }

      op.barMeasure = measureForScrollbars(cm);

      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      // updateDisplay_W2 will use these properties to do the actual resizing
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth =
          Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
      }

      if (op.updatedDisplay || op.selectionChanged)
        { op.preparedSelection = display.input.prepareSelection(); }
    }

    function endOperation_W2(op) {
      var cm = op.cm;

      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft)
          { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
        cm.display.maxLineChanged = false;
      }

      var takeFocus = op.focus && op.focus == activeElt();
      if (op.preparedSelection)
        { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
      if (op.updatedDisplay || op.startHeight != cm.doc.height)
        { updateScrollbars(cm, op.barMeasure); }
      if (op.updatedDisplay)
        { setDocumentHeight(cm, op.barMeasure); }

      if (op.selectionChanged) { restartBlink(cm); }

      if (cm.state.focused && op.updateInput)
        { cm.display.input.reset(op.typing); }
      if (takeFocus) { ensureFocus(op.cm); }
    }

    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;

      if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

      // Abort mouse wheel delta measurement, when scrolling explicitly
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
        { display.wheelStartX = display.wheelStartY = null; }

      // Propagate the scroll position to the actual DOM scroller
      if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

      if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
      // If we need to scroll a specific position into view, do so.
      if (op.scrollToPos) {
        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow(cm, rect);
      }

      // Fire events for markers that are hidden/unidden by editing or
      // undoing
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) { for (var i = 0; i < hidden.length; ++i)
        { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
      if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
        { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

      if (display.wrapper.offsetHeight)
        { doc.scrollTop = cm.display.scroller.scrollTop; }

      // Fire change events, and delayed event handlers
      if (op.changeObjs)
        { signal(cm, "changes", cm, op.changeObjs); }
      if (op.update)
        { op.update.finish(); }
    }

    // Run the given function in an operation
    function runInOp(cm, f) {
      if (cm.curOp) { return f() }
      startOperation(cm);
      try { return f() }
      finally { endOperation(cm); }
    }
    // Wraps a function in an operation. Returns the wrapped function.
    function operation(cm, f) {
      return function() {
        if (cm.curOp) { return f.apply(cm, arguments) }
        startOperation(cm);
        try { return f.apply(cm, arguments) }
        finally { endOperation(cm); }
      }
    }
    // Used to add methods to editor and doc instances, wrapping them in
    // operations.
    function methodOp(f) {
      return function() {
        if (this.curOp) { return f.apply(this, arguments) }
        startOperation(this);
        try { return f.apply(this, arguments) }
        finally { endOperation(this); }
      }
    }
    function docMethodOp(f) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) { return f.apply(this, arguments) }
        startOperation(cm);
        try { return f.apply(this, arguments) }
        finally { endOperation(cm); }
      }
    }

    // HIGHLIGHT WORKER

    function startWorker(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo)
        { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
    }

    function highlightWorker(cm) {
      var doc = cm.doc;
      if (doc.highlightFrontier >= cm.display.viewTo) { return }
      var end = +new Date + cm.options.workTime;
      var context = getContextBefore(cm, doc.highlightFrontier);
      var changedLines = [];

      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
        if (context.line >= cm.display.viewFrom) { // Visible
          var oldStyles = line.styles;
          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
          var highlighted = highlightLine(cm, line, context, true);
          if (resetState) { context.state = resetState; }
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) { line.styleClasses = newCls; }
          else if (oldCls) { line.styleClasses = null; }
          var ischange = !oldStyles || oldStyles.length != line.styles.length ||
            oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
          if (ischange) { changedLines.push(context.line); }
          line.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line.text.length <= cm.options.maxHighlightLength)
            { processLine(cm, line.text, context); }
          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date > end) {
          startWorker(cm, cm.options.workDelay);
          return true
        }
      });
      doc.highlightFrontier = context.line;
      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
      if (changedLines.length) { runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++)
          { regLineChange(cm, changedLines[i], "text"); }
      }); }
    }

    // DISPLAY DRAWING

    var DisplayUpdate = function(cm, viewport, force) {
      var display = cm.display;

      this.viewport = viewport;
      // Store some values that we'll need later (but don't want to force a relayout for)
      this.visible = visibleLines(display, cm.doc, viewport);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth(cm);
      this.force = force;
      this.dims = getDimensions(cm);
      this.events = [];
    };

    DisplayUpdate.prototype.signal = function (emitter, type) {
      if (hasHandler(emitter, type))
        { this.events.push(arguments); }
    };
    DisplayUpdate.prototype.finish = function () {
        var this$1 = this;

      for (var i = 0; i < this.events.length; i++)
        { signal.apply(null, this$1.events[i]); }
    };

    function maybeClipScrollbars(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }

    function selectionSnapshot(cm) {
      if (cm.hasFocus()) { return null }
      var active = activeElt();
      if (!active || !contains(cm.display.lineDiv, active)) { return null }
      var result = {activeElt: active};
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
          result.anchorNode = sel.anchorNode;
          result.anchorOffset = sel.anchorOffset;
          result.focusNode = sel.focusNode;
          result.focusOffset = sel.focusOffset;
        }
      }
      return result
    }

    function restoreSelection(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
      snapshot.activeElt.focus();
      if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range$$1 = document.createRange();
        range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range$$1.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range$$1);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }

    // Does the actual updating of the line display. Bails out
    // (returning false) when there is nothing to be done and forced is
    // false.
    function updateDisplayIfNeeded(cm, update) {
      var display = cm.display, doc = cm.doc;

      if (update.editorIsHidden) {
        resetView(cm);
        return false
      }

      // Bail out if the visible area is already rendered and nothing changed.
      if (!update.force &&
          update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
          (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
          display.renderedView == display.view && countDirtyView(cm) == 0)
        { return false }

      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update.dims = getDimensions(cm);
      }

      // Compute a suitable new viewport (from & to)
      var end = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
      if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
      if (sawCollapsedSpans) {
        from = visualLineNo(cm.doc, from);
        to = visualLineEndNo(cm.doc, to);
      }

      var different = from != display.viewFrom || to != display.viewTo ||
        display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
      adjustView(cm, from, to);

      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
      // Position the mover div to align with the current scroll position
      cm.display.mover.style.top = display.viewOffset + "px";

      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
          (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
        { return false }

      // For big changes, we hide the enclosing element during the
      // update, since that speeds up the operations on most browsers.
      var selSnapshot = selectionSnapshot(cm);
      if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
      patchDisplay(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) { display.lineDiv.style.display = ""; }
      display.renderedView = display.view;
      // There might have been a widget with a focused element that got
      // hidden or updated, if so re-focus it.
      restoreSelection(selSnapshot);

      // Prevent selection and cursors from interfering with the scroll
      // width and height.
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;

      if (different) {
        display.lastWrapHeight = update.wrapperHeight;
        display.lastWrapWidth = update.wrapperWidth;
        startWorker(cm, 400);
      }

      display.updateLineNumbers = null;

      return true
    }

    function postUpdateDisplay(cm, update) {
      var viewport = update.viewport;

      for (var first = true;; first = false) {
        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
          // Clip forced viewport to actual scrollable area.
          if (viewport && viewport.top != null)
            { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
          // Updated line heights might result in the drawn area not
          // actually covering the viewport. Keep looping until it does.
          update.visible = visibleLines(cm.display, cm.doc, viewport);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
            { break }
        }
        if (!updateDisplayIfNeeded(cm, update)) { break }
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.force = false;
      }

      update.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
      }
    }

    function updateDisplaySimple(cm, viewport) {
      var update = new DisplayUpdate(cm, viewport);
      if (updateDisplayIfNeeded(cm, update)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.finish();
      }
    }

    // Sync the actual display DOM structure with display.view, removing
    // nodes for lines that are no longer in view, and creating the ones
    // that are not there yet, and updating the ones that are out of
    // date.
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;

      function rm(node) {
        var next = node.nextSibling;
        // Works around a throw-scroll bug in OS X Webkit
        if (webkit && mac && cm.display.currentWheelTarget == node)
          { node.style.display = "none"; }
        else
          { node.parentNode.removeChild(node); }
        return next
      }

      var view = display.view, lineN = display.viewFrom;
      // Loop over the elements in the view, syncing cur (the DOM nodes
      // in display.lineDiv) with the view as we go.
      for (var i = 0; i < view.length; i++) {
        var lineView = view[i];
        if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else { // Already drawn
          while (cur != lineView.node) { cur = rm(cur); }
          var updateNumber = lineNumbers && updateNumbersFrom != null &&
            updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) { cur = rm(cur); }
    }

    function updateGutterSpace(display) {
      var width = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width + "px";
    }

    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
    }

    // Re-align line numbers and gutter marks to compensate for
    // horizontal scrolling.
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left = comp + "px";
      for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter)
            { view[i].gutter.style.left = left; }
          if (view[i].gutterBackground)
            { view[i].gutterBackground.style.left = left; }
        }
        var align = view[i].alignable;
        if (align) { for (var j = 0; j < align.length; j++)
          { align[j].style.left = left; } }
      } }
      if (cm.options.fixedGutter)
        { display.gutters.style.left = (comp + gutterW) + "px"; }
    }

    // Used to ensure that the line number gutter is still the right
    // size for the current document size. Returns true when an update
    // is needed.
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) { return false }
      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                   "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm.display);
        return true
      }
      return false
    }

    function getGutters(gutters, lineNumbers) {
      var result = [], sawLineNumbers = false;
      for (var i = 0; i < gutters.length; i++) {
        var name = gutters[i], style = null;
        if (typeof name != "string") { style = name.style; name = name.className; }
        if (name == "CodeMirror-linenumbers") {
          if (!lineNumbers) { continue }
          else { sawLineNumbers = true; }
        }
        result.push({className: name, style: style});
      }
      if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
      return result
    }

    // Rebuild the gutter elements, ensure the margin to the left of the
    // code matches their width.
    function renderGutters(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren(gutters);
      display.lineGutter = null;
      for (var i = 0; i < specs.length; ++i) {
        var ref = specs[i];
        var className = ref.className;
        var style = ref.style;
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
        if (style) { gElt.style.cssText = style; }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace(display);
    }

    function updateGutters(cm) {
      renderGutters(cm.display);
      regChange(cm);
      alignHorizontally(cm);
    }

    // The display handles the DOM integration, both for input reading
    // and content drawing. It holds references to DOM nodes and
    // display-related state.

    function Display(place, doc, input, options) {
      var d = this;
      this.input = input;

      // Covers bottom-right square when both scrollbars are present.
      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      d.scrollbarFiller.setAttribute("cm-not-content", "true");
      // Covers bottom of gutter when coverGutterNextToScrollbar is on
      // and h scrollbar is present.
      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      d.gutterFiller.setAttribute("cm-not-content", "true");
      // Will contain the actual code, positioned to cover the viewport.
      d.lineDiv = eltP("div", null, "CodeMirror-code");
      // Elements are added to these to represent selection and cursors.
      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d.cursorDiv = elt("div", null, "CodeMirror-cursors");
      // A visibility: hidden element used to find the size of things.
      d.measure = elt("div", null, "CodeMirror-measure");
      // When lines outside of the viewport are measured, they are drawn in this.
      d.lineMeasure = elt("div", null, "CodeMirror-measure");
      // Wraps everything that needs to exist inside the vertically-padded coordinate system
      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                        null, "position: relative; outline: none");
      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
      // Moved around its parent to cover visible view.
      d.mover = elt("div", [lines], null, "position: relative");
      // Set to the height of the document, allowing scrolling.
      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
      d.sizerWidth = null;
      // Behavior of elts with overflow: auto and padding is
      // inconsistent across browsers. This is used to ensure the
      // scrollable area is big enough.
      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
      // Will contain the gutters, if any.
      d.gutters = elt("div", null, "CodeMirror-gutters");
      d.lineGutter = null;
      // Actual scrollable element.
      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
      d.scroller.setAttribute("tabIndex", "-1");
      // The element in which the editor lives.
      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

      // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
      if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
      if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

      if (place) {
        if (place.appendChild) { place.appendChild(d.wrapper); }
        else { place(d.wrapper); }
      }

      // Current rendered range (may be bigger than the view window).
      d.viewFrom = d.viewTo = doc.first;
      d.reportedViewFrom = d.reportedViewTo = doc.first;
      // Information about the rendered lines.
      d.view = [];
      d.renderedView = null;
      // Holds info about a single rendered line when it was rendered
      // for measurement, while not in view.
      d.externalMeasured = null;
      // Empty space (in pixels) above the view
      d.viewOffset = 0;
      d.lastWrapHeight = d.lastWrapWidth = 0;
      d.updateLineNumbers = null;

      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
      d.scrollbarsClipped = false;

      // Used to only resize the line number gutter when necessary (when
      // the amount of lines crosses a boundary that makes its width change)
      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
      // Set to true when a non-horizontal-scrolling line widget is
      // added. As an optimization, line widget aligning is skipped when
      // this is false.
      d.alignWidgets = false;

      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

      // Tracks the maximum line length so that the horizontal scrollbar
      // can be kept static when scrolling.
      d.maxLine = null;
      d.maxLineLength = 0;
      d.maxLineChanged = false;

      // Used for measuring wheel scrolling granularity
      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

      // True when shift is held down.
      d.shift = false;

      // Used to track whether anything happened since the context menu
      // was opened.
      d.selForContextMenu = null;

      d.activeTouch = null;

      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
      renderGutters(d);

      input.init(d);
    }

    // Since the delta values reported on mouse wheel events are
    // unstandardized between browsers and even browser versions, and
    // generally horribly unpredictable, this code starts by measuring
    // the scroll effect that the first few mouse wheel events have,
    // and, from that, detects the way it can convert deltas to pixel
    // offsets afterwards.
    //
    // The reason we want to know the amount a wheel event will scroll
    // is that it gives us a chance to update the display before the
    // actual scrolling happens, reducing flickering.

    var wheelSamples = 0, wheelPixelsPerUnit = null;
    // Fill in a browser-detected starting value on browsers where we
    // know one. These don't have to be accurate -- the result of them
    // being wrong would just be a slight flicker on the first wheel
    // scroll (if it is large enough).
    if (ie) { wheelPixelsPerUnit = -.53; }
    else if (gecko) { wheelPixelsPerUnit = 15; }
    else if (chrome) { wheelPixelsPerUnit = -.7; }
    else if (safari) { wheelPixelsPerUnit = -1/3; }

    function wheelEventDelta(e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
      else if (dy == null) { dy = e.wheelDelta; }
      return {x: dx, y: dy}
    }
    function wheelEventPixels(e) {
      var delta = wheelEventDelta(e);
      delta.x *= wheelPixelsPerUnit;
      delta.y *= wheelPixelsPerUnit;
      return delta
    }

    function onScrollWheel(cm, e) {
      var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

      var display = cm.display, scroll = display.scroller;
      // Quit if there's nothing to scroll here
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) { return }

      // Webkit browsers on OS X abort momentum scrolls when the target
      // of the scroll event is removed from the scrollable element.
      // This hack (see related code in patchDisplay) makes sure the
      // element is kept around.
      if (dy && mac && webkit) {
        outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
          for (var i = 0; i < view.length; i++) {
            if (view[i].node == cur) {
              cm.display.currentWheelTarget = cur;
              break outer
            }
          }
        }
      }

      // On some browsers, horizontal scrolling will cause redraws to
      // happen before the gutter has been realigned, causing it to
      // wriggle around in a most unseemly way. When we have an
      // estimated pixels/delta value, we just handle horizontal
      // scrolling entirely here. It'll be slightly off from native, but
      // better than glitching out.
      if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
        if (dy && canScrollY)
          { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
        // Only prevent default scrolling if vertical scrolling is
        // actually possible. Otherwise, it causes vertical scroll
        // jitter on OSX trackpads when deltaX is small and deltaY
        // is large (issue #3579)
        if (!dy || (dy && canScrollY))
          { e_preventDefault(e); }
        display.wheelStartX = null; // Abort measurement, if in progress
        return
      }

      // 'Project' the visible viewport to cover the area that is being
      // scrolled into view (if we know enough to estimate it).
      if (dy && wheelPixelsPerUnit != null) {
        var pixels = dy * wheelPixelsPerUnit;
        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
        if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
        else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
        updateDisplaySimple(cm, {top: top, bottom: bot});
      }

      if (wheelSamples < 20) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx; display.wheelDY = dy;
          setTimeout(function () {
            if (display.wheelStartX == null) { return }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
              (movedX && display.wheelDX && movedX / display.wheelDX);
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) { return }
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx; display.wheelDY += dy;
        }
      }
    }

    // Selection objects are immutable. A new one is created every time
    // the selection changes. A selection is one or more non-overlapping
    // (and non-touching) ranges, sorted, and an integer that indicates
    // which one is the primary selection (the one that's scrolled into
    // view, that getCursor returns, etc).
    var Selection = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };

    Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

    Selection.prototype.equals = function (other) {
        var this$1 = this;

      if (other == this) { return true }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this$1.ranges[i], there = other.ranges[i];
        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
      }
      return true
    };

    Selection.prototype.deepCopy = function () {
        var this$1 = this;

      var out = [];
      for (var i = 0; i < this.ranges.length; i++)
        { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
      return new Selection(out, this.primIndex)
    };

    Selection.prototype.somethingSelected = function () {
        var this$1 = this;

      for (var i = 0; i < this.ranges.length; i++)
        { if (!this$1.ranges[i].empty()) { return true } }
      return false
    };

    Selection.prototype.contains = function (pos, end) {
        var this$1 = this;

      if (!end) { end = pos; }
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this$1.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          { return i }
      }
      return -1
    };

    var Range = function(anchor, head) {
      this.anchor = anchor; this.head = head;
    };

    Range.prototype.from = function () { return minPos(this.anchor, this.head) };
    Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
    Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

    // Take an unsorted, potentially overlapping set of ranges, and
    // build a selection out of it. 'Consumes' ranges array (modifying
    // it).
    function normalizeSelection(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
      primIndex = indexOf(ranges, prim);
      for (var i = 1; i < ranges.length; i++) {
        var cur = ranges[i], prev = ranges[i - 1];
        var diff = cmp(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i <= primIndex) { --primIndex; }
          ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection(ranges, primIndex)
    }

    function simpleSelection(anchor, head) {
      return new Selection([new Range(anchor, head || anchor)], 0)
    }

    // Compute the position of the end of a change (its 'to' property
    // refers to the pre-change end).
    function changeEnd(change) {
      if (!change.text) { return change.to }
      return Pos(change.from.line + change.text.length - 1,
                 lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
    }

    // Adjust a position to refer to the post-change position of the
    // same text, or the end of the change if the change covers it.
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) { return pos }
      if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
      return Pos(line, ch)
    }

    function computeSelAfterChange(doc, change) {
      var out = [];
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        out.push(new Range(adjustForChange(range.anchor, change),
                           adjustForChange(range.head, change)));
      }
      return normalizeSelection(doc.cm, out, doc.sel.primIndex)
    }

    function offsetPos(pos, old, nw) {
      if (pos.line == old.line)
        { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
      else
        { return Pos(nw.line + (pos.line - old.line), pos.ch) }
    }

    // Used by replaceSelections to allow moving the selection to the
    // start or around the replaced test. Hint may be "start" or "around".
    function computeReplacedSel(doc, changes, hint) {
      var out = [];
      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        var from = offsetPos(change.from, oldPrev, newPrev);
        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint == "around") {
          var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
          out[i] = new Range(inv ? to : from, inv ? from : to);
        } else {
          out[i] = new Range(from, from);
        }
      }
      return new Selection(out, doc.sel.primIndex)
    }

    // Used to get the editor into a consistent state again when options change.

    function loadMode(cm) {
      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }

    function resetModeState(cm) {
      cm.doc.iter(function (line) {
        if (line.stateAfter) { line.stateAfter = null; }
        if (line.styles) { line.styles = null; }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) { regChange(cm); }
    }

    // DOCUMENT DATA STRUCTURE

    // By default, updates that start and end at the beginning of a line
    // are treated specially, in order to make the association of line
    // widgets and marker elements with the text behave more intuitive.
    function isWholeLineUpdate(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
    }

    // Perform a change on the document data structure.
    function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
      function spansFor(n) {return markedSpans ? markedSpans[n] : null}
      function update(line, text, spans) {
        updateLine(line, text, spans, estimateHeight$$1);
        signalLater(line, "change", line, change);
      }
      function linesFor(start, end) {
        var result = [];
        for (var i = start; i < end; ++i)
          { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
        return result
      }

      var from = change.from, to = change.to, text = change.text;
      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
      var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

      // Adjust the line structure
      if (change.full) {
        doc.insert(0, linesFor(0, text.length));
        doc.remove(text.length, doc.size - text.length);
      } else if (isWholeLineUpdate(doc, change)) {
        // This is a whole-line replace. Treated specially to make
        // sure line objects move the way they are supposed to.
        var added = linesFor(0, text.length - 1);
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) { doc.remove(from.line, nlines); }
        if (added.length) { doc.insert(from.line, added); }
      } else if (firstLine == lastLine) {
        if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text.length - 1);
          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          doc.insert(from.line + 1, added$1);
        }
      } else if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        var added$2 = linesFor(1, text.length - 1);
        if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
        doc.insert(from.line + 1, added$2);
      }

      signalLater(doc, "change", doc, change);
    }

    // Call f for all linked documents.
    function linkedDocs(doc, f, sharedHistOnly) {
      function propagate(doc, skip, sharedHist) {
        if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) { continue }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) { continue }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        } }
      }
      propagate(doc, null, true);
    }

    // Attach a document to an editor.
    function attachDoc(cm, doc) {
      if (doc.cm) { throw new Error("This document is already in use.") }
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      setDirectionClass(cm);
      if (!cm.options.lineWrapping) { findMaxLine(cm); }
      cm.options.mode = doc.modeOption;
      regChange(cm);
    }

    function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }

    function directionChanged(cm) {
      runInOp(cm, function () {
        setDirectionClass(cm);
        regChange(cm);
      });
    }

    function History(startGen) {
      // Arrays of change events and selections. Doing something adds an
      // event to done and clears undo. Undoing moves events from done
      // to undone, redoing moves them in the other direction.
      this.done = []; this.undone = [];
      this.undoDepth = Infinity;
      // Used to track when changes can be merged into a single undo
      // event
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      // Used by the isClean() method
      this.generation = this.maxGeneration = startGen || 1;
    }

    // Create a history change event from an updateDoc-style change
    // object.
    function historyChangeFromChange(doc, change) {
      var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
      return histChange
    }

    // Pop all selection events off the end of a history array. Stop at
    // a change event.
    function clearSelectionEvents(array) {
      while (array.length) {
        var last = lst(array);
        if (last.ranges) { array.pop(); }
        else { break }
      }
    }

    // Find the top change event in the history. Pop off selection
    // events that are in the way.
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done)
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done)
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done)
      }
    }

    // Register a change in the history. Merges changes that are within
    // a single operation, or are close together with an origin that
    // allows merging (starting with "+") into a single event.
    function addChangeToHistory(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date, cur;
      var last;

      if ((hist.lastOp == opId ||
           hist.lastOrigin == change.origin && change.origin &&
           ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
            change.origin.charAt(0) == "*")) &&
          (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        // Merge this change into the last event
        last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          // Optimized case for simple insertion -- don't want to add
          // new changesets for every character typed
          last.to = changeEnd(change);
        } else {
          // Add new sub-event
          cur.changes.push(historyChangeFromChange(doc, change));
        }
      } else {
        // Can not be merged, start a new event.
        var before = lst(hist.done);
        if (!before || !before.ranges)
          { pushSelectionToHistory(doc.sel, hist.done); }
        cur = {changes: [historyChangeFromChange(doc, change)],
               generation: hist.generation};
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) { hist.done.shift(); }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;

      if (!last) { signal(doc, "historyAdded"); }
    }

    function selectionEventCanBeMerged(doc, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" ||
        ch == "+" &&
        prev.ranges.length == sel.ranges.length &&
        prev.somethingSelected() == sel.somethingSelected() &&
        new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
    }

    // Called whenever the selection changes, sets the new selection as
    // the pending selection in the history, and pushes the old pending
    // selection into the 'done' array when it was significantly
    // different (in number of selected ranges, emptiness, or time).
    function addSelectionToHistory(doc, sel, opId, options) {
      var hist = doc.history, origin = options && options.origin;

      // A new event is started when the previous origin does not match
      // the current, or the origins don't allow matching. Origins
      // starting with * are always merged, those starting with + are
      // merged when similar and close together in time.
      if (opId == hist.lastSelOp ||
          (origin && hist.lastSelOrigin == origin &&
           (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
            selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
        { hist.done[hist.done.length - 1] = sel; }
      else
        { pushSelectionToHistory(sel, hist.done); }

      hist.lastSelTime = +new Date;
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options && options.clearRedo !== false)
        { clearSelectionEvents(hist.undone); }
    }

    function pushSelectionToHistory(sel, dest) {
      var top = lst(dest);
      if (!(top && top.ranges && top.equals(sel)))
        { dest.push(sel); }
    }

    // Used to store marked span information in the history.
    function attachLocalSpans(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
        if (line.markedSpans)
          { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
        ++n;
      });
    }

    // When un/re-doing restores text containing marked spans, those
    // that have been explicitly cleared should not be restored.
    function removeClearedSpans(spans) {
      if (!spans) { return null }
      var out;
      for (var i = 0; i < spans.length; ++i) {
        if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
        else if (out) { out.push(spans[i]); }
      }
      return !out ? spans : out.length ? out : null
    }

    // Retrieve and filter the old marked spans stored in a change event.
    function getOldSpans(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) { return null }
      var nw = [];
      for (var i = 0; i < change.text.length; ++i)
        { nw.push(removeClearedSpans(found[i])); }
      return nw
    }

    // Used for un/re-doing changes from the history. Combines the
    // result of computing the existing spans with the set of spans that
    // existed in the history (so that deleting around a span and then
    // undoing brings back the span).
    function mergeOldSpans(doc, change) {
      var old = getOldSpans(doc, change);
      var stretched = stretchSpansOverChange(doc, change);
      if (!old) { return stretched }
      if (!stretched) { return old }

      for (var i = 0; i < old.length; ++i) {
        var oldCur = old[i], stretchCur = stretched[i];
        if (oldCur && stretchCur) {
          spans: for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              { if (oldCur[k].marker == span.marker) { continue spans } }
            oldCur.push(span);
          }
        } else if (stretchCur) {
          old[i] = stretchCur;
        }
      }
      return old
    }

    // Used both to provide a JSON-safe object in .getHistory, and, when
    // detaching a document, to split the history in two
    function copyHistoryArray(events, newGroup, instantiateSel) {
      var copy = [];
      for (var i = 0; i < events.length; ++i) {
        var event = events[i];
        if (event.ranges) {
          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
          continue
        }
        var changes = event.changes, newChanges = [];
        copy.push({changes: newChanges});
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m = (void 0);
          newChanges.push({from: change.from, to: change.to, text: change.text});
          if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
            if (indexOf(newGroup, Number(m[1])) > -1) {
              lst(newChanges)[prop] = change[prop];
              delete change[prop];
            }
          } } }
        }
      }
      return copy
    }

    // The 'scroll' parameter given to many of these indicated whether
    // the new cursor position should be scrolled into view after
    // modifying the selection.

    // If shift is held or the extend flag is set, extends a range to
    // include a given position (and optionally a second position).
    // Otherwise, simply returns the range between the given positions.
    // Used for cursor motion and such.
    function extendRange(range, head, other, extend) {
      if (extend) {
        var anchor = range.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != (cmp(other, anchor) < 0)) {
            anchor = head;
            head = other;
          } else if (posBefore != (cmp(head, other) < 0)) {
            head = other;
          }
        }
        return new Range(anchor, head)
      } else {
        return new Range(other || head, head)
      }
    }

    // Extend the primary selection range, discard the rest.
    function extendSelection(doc, head, other, options, extend) {
      if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
    }

    // Extend all selections (pos is an array of selections with length
    // equal the number of selections)
    function extendSelections(doc, heads, options) {
      var out = [];
      var extend = doc.cm && (doc.cm.display.shift || doc.extend);
      for (var i = 0; i < doc.sel.ranges.length; i++)
        { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
      setSelection(doc, newSel, options);
    }

    // Updates a single range in the selection.
    function replaceOneSelection(doc, i, range, options) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i] = range;
      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
    }

    // Reset the selection to a single range.
    function setSimpleSelection(doc, anchor, head, options) {
      setSelection(doc, simpleSelection(anchor, head), options);
    }

    // Give beforeSelectionChange handlers a change to influence a
    // selection update.
    function filterSelectionChange(doc, sel, options) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          var this$1 = this;

          this.ranges = [];
          for (var i = 0; i < ranges.length; i++)
            { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                       clipPos(doc, ranges[i].head)); }
        },
        origin: options && options.origin
      };
      signal(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
      if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
      else { return sel }
    }

    function setSelectionReplaceHistory(doc, sel, options) {
      var done = doc.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc, sel, options);
      } else {
        setSelection(doc, sel, options);
      }
    }

    // Set a new selection.
    function setSelection(doc, sel, options) {
      setSelectionNoUndo(doc, sel, options);
      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }

    function setSelectionNoUndo(doc, sel, options) {
      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
        { sel = filterSelectionChange(doc, sel, options); }

      var bias = options && options.bias ||
        (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

      if (!(options && options.scroll === false) && doc.cm)
        { ensureCursorVisible(doc.cm); }
    }

    function setSelectionInner(doc, sel) {
      if (sel.equals(doc.sel)) { return }

      doc.sel = sel;

      if (doc.cm) {
        doc.cm.curOp.updateInput = 1;
        doc.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc.cm);
      }
      signalLater(doc, "cursorActivity", doc);
    }

    // Verify that the selection does not partially select any atomic
    // marked ranges.
    function reCheckSelection(doc) {
      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }

    // Return a selection that does not partially select any atomic
    // ranges.
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
      var out;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
        var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range.anchor || newHead != range.head) {
          if (!out) { out = sel.ranges.slice(0, i); }
          out[i] = new Range(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
    }

    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
      var line = getLine(doc, pos.line);
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i], m = sp.marker;

        // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
        // is with selectLeft/Right
        var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
            (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) { break }
              else {--i; continue}
            }
          }
          if (!m.atomic) { continue }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
            if (dir < 0 ? preventCursorRight : preventCursorLeft)
              { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
              { return skipAtomicInner(doc, near, pos, dir, mayClear) }
          }

          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? preventCursorLeft : preventCursorRight)
            { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
        }
      } }
      return pos
    }

    // Ensure a given position is not inside an atomic range.
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
          (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
          skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
          (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
      if (!found) {
        doc.cantEdit = true;
        return Pos(doc.first, 0)
      }
      return found
    }

    function movePos(doc, pos, dir, line) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
        else { return null }
      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
        if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
        else { return null }
      } else {
        return new Pos(pos.line, pos.ch + dir)
      }
    }

    function selectAll(cm) {
      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }

    // UPDATING

    // Allow "beforeChange" event handlers to influence a change
    function filterChange(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function () { return obj.canceled = true; }
      };
      if (update) { obj.update = function (from, to, text, origin) {
        if (from) { obj.from = clipPos(doc, from); }
        if (to) { obj.to = clipPos(doc, to); }
        if (text) { obj.text = text; }
        if (origin !== undefined) { obj.origin = origin; }
      }; }
      signal(doc, "beforeChange", doc, obj);
      if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

      if (obj.canceled) {
        if (doc.cm) { doc.cm.curOp.updateInput = 2; }
        return null
      }
      return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
    }

    // Apply a change to a document, and add it to the document's
    // history, and propagating it to all linked documents.
    function makeChange(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
        if (doc.cm.state.suppressEdits) { return }
      }

      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
        change = filterChange(doc, change, true);
        if (!change) { return }
      }

      // Possibly split or suppress the update based on the presence
      // of read-only spans in its range.
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
      if (split) {
        for (var i = split.length - 1; i >= 0; --i)
          { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
      } else {
        makeChangeInner(doc, change);
      }
    }

    function makeChangeInner(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
      var selAfter = computeSelAfterChange(doc, change);
      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
      var rebased = [];

      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
      });
    }

    // Revert a change stored in a document's history.
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
      var suppress = doc.cm && doc.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) { return }

      var hist = doc.history, event, selAfter = doc.sel;
      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

      // Verify that there is a useable event (so that ctrl-z won't
      // needlessly clear selection events)
      var i = 0;
      for (; i < source.length; i++) {
        event = source[i];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
          { break }
      }
      if (i == source.length) { return }
      hist.lastOrigin = hist.lastSelOrigin = null;

      for (;;) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc.sel)) {
            setSelection(doc, event, {clearRedo: false});
            return
          }
          selAfter = event;
        } else if (suppress) {
          source.push(event);
          return
        } else { break }
      }

      // Build up a reverse change object to add to the opposite history
      // stack (redo when undoing, and vice versa).
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({changes: antiChanges, generation: hist.generation});
      hist.generation = event.generation || ++hist.maxGeneration;

      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

      var loop = function ( i ) {
        var change = event.changes[i];
        change.origin = type;
        if (filter && !filterChange(doc, change, false)) {
          source.length = 0;
          return {}
        }

        antiChanges.push(historyChangeFromChange(doc, change));

        var after = i ? computeSelAfterChange(doc, change) : lst(source);
        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
        if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
        var rebased = [];

        // Propagate to the linked documents
        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
        });
      };

      for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
        var returned = loop( i$1 );

        if ( returned ) return returned.v;
      }
    }

    // Sub-views need their line numbers shifted when text is added
    // above or below them in the parent document.
    function shiftDoc(doc, distance) {
      if (distance == 0) { return }
      doc.first += distance;
      doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
        Pos(range.anchor.line + distance, range.anchor.ch),
        Pos(range.head.line + distance, range.head.ch)
      ); }), doc.sel.primIndex);
      if (doc.cm) {
        regChange(doc.cm, doc.first, doc.first - distance, distance);
        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
          { regLineChange(doc.cm, l, "gutter"); }
      }
    }

    // More lower-level change function, handling only a single document
    // (not linked ones).
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp)
        { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

      if (change.to.line < doc.first) {
        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return
      }
      if (change.from.line > doc.lastLine()) { return }

      // Clip the change to the size of this doc
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc(doc, shift);
        change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                  text: [lst(change.text)], origin: change.origin};
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                  text: [change.text[0]], origin: change.origin};
      }

      change.removed = getBetween(doc, change.from, change.to);

      if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
      if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
      else { updateDoc(doc, change, spans); }
      setSelectionNoUndo(doc, selAfter, sel_dontScroll);

      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
        { doc.cantEdit = false; }
    }

    // Handle the interaction of a change to a document with the editor
    // that this document is part of.
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function (line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true
          }
        });
      }

      if (doc.sel.contains(change.from, change.to) > -1)
        { signalCursorActivity(cm); }

      updateDoc(doc, change, spans, estimateHeight(cm));

      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
          var len = lineLength(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
      }

      retreatFrontier(doc, from.line);
      startWorker(cm, 400);

      var lendiff = change.text.length - (to.line - from.line) - 1;
      // Remember that these lines changed, for updating the display
      if (change.full)
        { regChange(cm); }
      else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
        { regLineChange(cm, from.line, "text"); }
      else
        { regChange(cm, from.line, to.line + 1, lendiff); }

      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from: from, to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) { signalLater(cm, "change", cm, obj); }
        if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
      }
      cm.display.selForContextMenu = null;
    }

    function replaceRange(doc, code, from, to, origin) {
      var assign;

      if (!to) { to = from; }
      if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
      if (typeof code == "string") { code = doc.splitLines(code); }
      makeChange(doc, {from: from, to: to, text: code, origin: origin});
    }

    // Rebasing/resetting history to deal with externally-sourced changes

    function rebaseHistSelSingle(pos, from, to, diff) {
      if (to < pos.line) {
        pos.line += diff;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }

    // Tries to rebase an array of history events given a change in the
    // document. If the change touches the same lines as the event, the
    // event, and everything 'behind' it, is discarded. If the change is
    // before the event, the event's positions are updated. Uses a
    // copy-on-write scheme for the positions, to avoid having to
    // reallocate them all on every rebase, but also avoid problems with
    // shared position objects being unsafely updated.
    function rebaseHistArray(array, from, to, diff) {
      for (var i = 0; i < array.length; ++i) {
        var sub = array[i], ok = true;
        if (sub.ranges) {
          if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
          for (var j = 0; j < sub.ranges.length; j++) {
            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
          }
          continue
        }
        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
          var cur = sub.changes[j$1];
          if (to < cur.from.line) {
            cur.from = Pos(cur.from.line + diff, cur.from.ch);
            cur.to = Pos(cur.to.line + diff, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok = false;
            break
          }
        }
        if (!ok) {
          array.splice(0, i + 1);
          i = 0;
        }
      }
    }

    function rebaseHist(hist, change) {
      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
      rebaseHistArray(hist.done, from, to, diff);
      rebaseHistArray(hist.undone, from, to, diff);
    }

    // Utility for applying a change to a line by handle or number,
    // returning the number and optionally registering the line as
    // changed.
    function changeLine(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
      else { no = lineNo(handle); }
      if (no == null) { return null }
      if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
      return line
    }

    // The document is represented as a BTree consisting of leaves, with
    // chunk of lines in them, and branches, with up to ten leaves or
    // other branch nodes below them. The top node is always a branch
    // node, and is the document object itself (meaning it has
    // additional methods and properties).
    //
    // All nodes have parent links. The tree is used both to go from
    // line numbers to line objects, and to go from objects to numbers.
    // It also indexes by height, and is used to convert between height
    // and line object, and to find the total height of the document.
    //
    // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

    function LeafChunk(lines) {
      var this$1 = this;

      this.lines = lines;
      this.parent = null;
      var height = 0;
      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
        height += lines[i].height;
      }
      this.height = height;
    }

    LeafChunk.prototype = {
      chunkSize: function() { return this.lines.length },

      // Remove the n lines at offset 'at'.
      removeInner: function(at, n) {
        var this$1 = this;

        for (var i = at, e = at + n; i < e; ++i) {
          var line = this$1.lines[i];
          this$1.height -= line.height;
          cleanUpLine(line);
          signalLater(line, "delete");
        }
        this.lines.splice(at, n);
      },

      // Helper used to collapse a small branch into a single leaf.
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },

      // Insert the given array of lines at offset 'at', count them as
      // having the given height.
      insertInner: function(at, lines, height) {
        var this$1 = this;

        this.height += height;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
      },

      // Used to iterate over a part of the tree.
      iterN: function(at, n, op) {
        var this$1 = this;

        for (var e = at + n; at < e; ++at)
          { if (op(this$1.lines[at])) { return true } }
      }
    };

    function BranchChunk(children) {
      var this$1 = this;

      this.children = children;
      var size = 0, height = 0;
      for (var i = 0; i < children.length; ++i) {
        var ch = children[i];
        size += ch.chunkSize(); height += ch.height;
        ch.parent = this$1;
      }
      this.size = size;
      this.height = height;
      this.parent = null;
    }

    BranchChunk.prototype = {
      chunkSize: function() { return this.size },

      removeInner: function(at, n) {
        var this$1 = this;

        this.size -= n;
        for (var i = 0; i < this.children.length; ++i) {
          var child = this$1.children[i], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this$1.height -= oldHeight - child.height;
            if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
            if ((n -= rm) == 0) { break }
            at = 0;
          } else { at -= sz; }
        }
        // If the result is smaller than 25 lines, ensure that it is a
        // single leaf node.
        if (this.size - n < 25 &&
            (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },

      collapse: function(lines) {
        var this$1 = this;

        for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
      },

      insertInner: function(at, lines, height) {
        var this$1 = this;

        this.size += lines.length;
        this.height += height;
        for (var i = 0; i < this.children.length; ++i) {
          var child = this$1.children[i], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height);
            if (child.lines && child.lines.length > 50) {
              // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
              // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length;) {
                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this$1.children.splice(++i, 0, leaf);
                leaf.parent = this$1;
              }
              child.lines = child.lines.slice(0, remaining);
              this$1.maybeSpill();
            }
            break
          }
          at -= sz;
        }
      },

      // When a node has grown, check whether it should be split.
      maybeSpill: function() {
        if (this.children.length <= 10) { return }
        var me = this;
        do {
          var spilled = me.children.splice(me.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me.parent) { // Become the parent node
            var copy = new BranchChunk(me.children);
            copy.parent = me;
            me.children = [copy, sibling];
            me = copy;
         } else {
            me.size -= sibling.size;
            me.height -= sibling.height;
            var myIndex = indexOf(me.parent.children, me);
            me.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me.parent;
        } while (me.children.length > 10)
        me.parent.maybeSpill();
      },

      iterN: function(at, n, op) {
        var this$1 = this;

        for (var i = 0; i < this.children.length; ++i) {
          var child = this$1.children[i], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n, sz - at);
            if (child.iterN(at, used, op)) { return true }
            if ((n -= used) == 0) { break }
            at = 0;
          } else { at -= sz; }
        }
      }
    };

    // Line widgets are block elements displayed above or below a line.

    var LineWidget = function(doc, node, options) {
      var this$1 = this;

      if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
        { this$1[opt] = options[opt]; } } }
      this.doc = doc;
      this.node = node;
    };

    LineWidget.prototype.clear = function () {
        var this$1 = this;

      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
      if (no == null || !ws) { return }
      for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
      if (!ws.length) { line.widgets = null; }
      var height = widgetHeight(this);
      updateLineHeight(line, Math.max(0, line.height - height));
      if (cm) {
        runInOp(cm, function () {
          adjustScrollWhenAboveVisible(cm, line, -height);
          regLineChange(cm, no, "widget");
        });
        signalLater(cm, "lineWidgetCleared", cm, this, no);
      }
    };

    LineWidget.prototype.changed = function () {
        var this$1 = this;

      var oldH = this.height, cm = this.doc.cm, line = this.line;
      this.height = null;
      var diff = widgetHeight(this) - oldH;
      if (!diff) { return }
      if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
      if (cm) {
        runInOp(cm, function () {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible(cm, line, diff);
          signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
        });
      }
    };
    eventMixin(LineWidget);

    function adjustScrollWhenAboveVisible(cm, line, diff) {
      if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
        { addToScrollTop(cm, diff); }
    }

    function addLineWidget(doc, handle, node, options) {
      var widget = new LineWidget(doc, node, options);
      var cm = doc.cm;
      if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
      changeLine(doc, handle, "widget", function (line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) { widgets.push(widget); }
        else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
        widget.line = line;
        if (cm && !lineIsHidden(doc, line)) {
          var aboveVisible = heightAtLine(line) < doc.scrollTop;
          updateLineHeight(line, line.height + widgetHeight(widget));
          if (aboveVisible) { addToScrollTop(cm, widget.height); }
          cm.curOp.forceUpdate = true;
        }
        return true
      });
      if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
      return widget
    }

    // TEXTMARKERS

    // Created with markText and setBookmark methods. A TextMarker is a
    // handle that can be used to clear or find a marked position in the
    // document. Line objects hold arrays (markedSpans) containing
    // {from, to, marker} object pointing to such marker objects, and
    // indicating that such a marker is present on that line. Multiple
    // lines may point to the same marker when it spans across lines.
    // The spans will have null for their from/to properties when the
    // marker continues beyond the start/end of the line. Markers have
    // links back to the lines they currently touch.

    // Collapsed markers have unique ids, in order to be able to order
    // them, which is needed for uniquely determining an outer marker
    // when they overlap (they may nest, but not partially overlap).
    var nextMarkerId = 0;

    var TextMarker = function(doc, type) {
      this.lines = [];
      this.type = type;
      this.doc = doc;
      this.id = ++nextMarkerId;
    };

    // Clear the marker.
    TextMarker.prototype.clear = function () {
        var this$1 = this;

      if (this.explicitlyCleared) { return }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) { startOperation(cm); }
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) { signalLater(this, "clear", found.from, found.to); }
      }
      var min = null, max = null;
      for (var i = 0; i < this.lines.length; ++i) {
        var line = this$1.lines[i];
        var span = getMarkedSpanFor(line.markedSpans, this$1);
        if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
        else if (cm) {
          if (span.to != null) { max = lineNo(line); }
          if (span.from != null) { min = lineNo(line); }
        }
        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
        if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
          { updateLineHeight(line, textHeight(cm.display)); }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      } }

      if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) { reCheckSelection(cm.doc); }
      }
      if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
      if (withOp) { endOperation(cm); }
      if (this.parent) { this.parent.clear(); }
    };

    // Find the position of the marker in the document. Returns a {from,
    // to} object by default. Side can be passed to get a specific side
    // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
    // Pos objects returned contain a line object, rather than a line
    // number (used to prevent looking up the same line twice).
    TextMarker.prototype.find = function (side, lineObj) {
        var this$1 = this;

      if (side == null && this.type == "bookmark") { side = 1; }
      var from, to;
      for (var i = 0; i < this.lines.length; ++i) {
        var line = this$1.lines[i];
        var span = getMarkedSpanFor(line.markedSpans, this$1);
        if (span.from != null) {
          from = Pos(lineObj ? line : lineNo(line), span.from);
          if (side == -1) { return from }
        }
        if (span.to != null) {
          to = Pos(lineObj ? line : lineNo(line), span.to);
          if (side == 1) { return to }
        }
      }
      return from && {from: from, to: to}
    };

    // Signals that the marker's widget changed, and surrounding layout
    // should be recomputed.
    TextMarker.prototype.changed = function () {
        var this$1 = this;

      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) { return }
      runInOp(cm, function () {
        var line = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight)
            { updateLineHeight(line, line.height + dHeight); }
        }
        signalLater(cm, "markerChanged", cm, this$1);
      });
    };

    TextMarker.prototype.attachLine = function (line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
          { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
      }
      this.lines.push(line);
    };

    TextMarker.prototype.detachLine = function (line) {
      this.lines.splice(indexOf(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp
        ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin(TextMarker);

    // Create a marker, wire it up to the right lines, and
    function markText(doc, from, to, options, type) {
      // Shared markers (across linked documents) are handled separately
      // (markTextShared will call out to this again, once per
      // document).
      if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
      // Ensure we are in an operation.
      if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

      var marker = new TextMarker(doc, type), diff = cmp(from, to);
      if (options) { copyObj(options, marker, false); }
      // Don't connect empty markers unless clearWhenEmpty is false
      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
        { return marker }
      if (marker.replacedWith) {
        // Showing up as a widget implies collapsed (widget replaces text)
        marker.collapsed = true;
        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
        if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
        if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
      }
      if (marker.collapsed) {
        if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
            from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
          { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
        seeCollapsedSpans();
      }

      if (marker.addToHistory)
        { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function (line) {
        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
          { updateMaxLine = true; }
        if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
        addMarkedSpan(line, new MarkedSpan(marker,
                                           curLine == from.line ? from.ch : null,
                                           curLine == to.line ? to.ch : null));
        ++curLine;
      });
      // lineIsHidden depends on the presence of the spans, so needs a second pass
      if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
      }); }

      if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

      if (marker.readOnly) {
        seeReadOnlySpans();
        if (doc.history.done.length || doc.history.undone.length)
          { doc.clearHistory(); }
      }
      if (marker.collapsed) {
        marker.id = ++nextMarkerId;
        marker.atomic = true;
      }
      if (cm) {
        // Sync editor state
        if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
        if (marker.collapsed)
          { regChange(cm, from.line, to.line + 1); }
        else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
                 marker.attributes || marker.title)
          { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
        if (marker.atomic) { reCheckSelection(cm.doc); }
        signalLater(cm, "markerAdded", cm, marker);
      }
      return marker
    }

    // SHARED TEXTMARKERS

    // A shared marker spans multiple linked documents. It is
    // implemented as a meta-marker-object controlling multiple normal
    // markers.
    var SharedTextMarker = function(markers, primary) {
      var this$1 = this;

      this.markers = markers;
      this.primary = primary;
      for (var i = 0; i < markers.length; ++i)
        { markers[i].parent = this$1; }
    };

    SharedTextMarker.prototype.clear = function () {
        var this$1 = this;

      if (this.explicitlyCleared) { return }
      this.explicitlyCleared = true;
      for (var i = 0; i < this.markers.length; ++i)
        { this$1.markers[i].clear(); }
      signalLater(this, "clear");
    };

    SharedTextMarker.prototype.find = function (side, lineObj) {
      return this.primary.find(side, lineObj)
    };
    eventMixin(SharedTextMarker);

    function markTextShared(doc, from, to, options, type) {
      options = copyObj(options);
      options.shared = false;
      var markers = [markText(doc, from, to, options, type)], primary = markers[0];
      var widget = options.widgetNode;
      linkedDocs(doc, function (doc) {
        if (widget) { options.widgetNode = widget.cloneNode(true); }
        markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
        for (var i = 0; i < doc.linked.length; ++i)
          { if (doc.linked[i].isParent) { return } }
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary)
    }

    function findSharedMarkers(doc) {
      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
    }

    function copySharedMarkers(doc, markers) {
      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i], pos = marker.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
          marker.markers.push(subMark);
          subMark.parent = marker;
        }
      }
    }

    function detachSharedMarkers(markers) {
      var loop = function ( i ) {
        var marker = markers[i], linked = [marker.primary.doc];
        linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
        for (var j = 0; j < marker.markers.length; j++) {
          var subMarker = marker.markers[j];
          if (indexOf(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker.markers.splice(j--, 1);
          }
        }
      };

      for (var i = 0; i < markers.length; i++) loop( i );
    }

    var nextDocId = 0;
    var Doc = function(text, mode, firstLine, lineSep, direction) {
      if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
      if (firstLine == null) { firstLine = 0; }

      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = simpleSelection(start);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;
      this.lineSep = lineSep;
      this.direction = (direction == "rtl") ? "rtl" : "ltr";
      this.extend = false;

      if (typeof text == "string") { text = this.splitLines(text); }
      updateDoc(this, {from: start, to: start, text: text});
      setSelection(this, simpleSelection(start), sel_dontScroll);
    };

    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      // Iterate over the document. Supports two forms -- with only one
      // argument, it calls that for each line in the document. With
      // three, it iterates over the range given by the first two (with
      // the second being non-inclusive).
      iter: function(from, to, op) {
        if (op) { this.iterN(from - this.first, to - from, op); }
        else { this.iterN(this.first, this.first + this.size, from); }
      },

      // Non-public interface for adding and removing lines.
      insert: function(at, lines) {
        var height = 0;
        for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
        this.insertInner(at - this.first, lines, height);
      },
      remove: function(at, n) { this.removeInner(at - this.first, n); },

      // From here, the methods are part of the public interface. Most
      // are also available from CodeMirror (editor) instances.

      getValue: function(lineSep) {
        var lines = getLines(this, this.first, this.first + this.size);
        if (lineSep === false) { return lines }
        return lines.join(lineSep || this.lineSeparator())
      },
      setValue: docMethodOp(function(code) {
        var top = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                          text: this.splitLines(code), origin: "setValue", full: true}, true);
        if (this.cm) { scrollToCoords(this.cm, 0, 0); }
        setSelection(this, simpleSelection(top), sel_dontScroll);
      }),
      replaceRange: function(code, from, to, origin) {
        from = clipPos(this, from);
        to = to ? clipPos(this, to) : from;
        replaceRange(this, code, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
        if (lineSep === false) { return lines }
        return lines.join(lineSep || this.lineSeparator())
      },

      getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

      getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
      getLineNumber: function(line) {return lineNo(line)},

      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") { line = getLine(this, line); }
        return visualLine(line)
      },

      lineCount: function() {return this.size},
      firstLine: function() {return this.first},
      lastLine: function() {return this.first + this.size - 1},

      clipPos: function(pos) {return clipPos(this, pos)},

      getCursor: function(start) {
        var range$$1 = this.sel.primary(), pos;
        if (start == null || start == "head") { pos = range$$1.head; }
        else if (start == "anchor") { pos = range$$1.anchor; }
        else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
        else { pos = range$$1.from(); }
        return pos
      },
      listSelections: function() { return this.sel.ranges },
      somethingSelected: function() {return this.sel.somethingSelected()},

      setCursor: docMethodOp(function(line, ch, options) {
        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
      }),
      setSelection: docMethodOp(function(anchor, head, options) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
      }),
      extendSelection: docMethodOp(function(head, other, options) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
      }),
      extendSelections: docMethodOp(function(heads, options) {
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      extendSelectionsBy: docMethodOp(function(f, options) {
        var heads = map(this.sel.ranges, f);
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      setSelections: docMethodOp(function(ranges, primary, options) {
        var this$1 = this;

        if (!ranges.length) { return }
        var out = [];
        for (var i = 0; i < ranges.length; i++)
          { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                             clipPos(this$1, ranges[i].head)); }
        if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
        setSelection(this, normalizeSelection(this.cm, out, primary), options);
      }),
      addSelection: docMethodOp(function(anchor, head, options) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
      }),

      getSelection: function(lineSep) {
        var this$1 = this;

        var ranges = this.sel.ranges, lines;
        for (var i = 0; i < ranges.length; i++) {
          var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) { return lines }
        else { return lines.join(lineSep || this.lineSeparator()) }
      },
      getSelections: function(lineSep) {
        var this$1 = this;

        var parts = [], ranges = this.sel.ranges;
        for (var i = 0; i < ranges.length; i++) {
          var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
          if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
          parts[i] = sel;
        }
        return parts
      },
      replaceSelection: function(code, collapse, origin) {
        var dup = [];
        for (var i = 0; i < this.sel.ranges.length; i++)
          { dup[i] = code; }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code, collapse, origin) {
        var this$1 = this;

        var changes = [], sel = this.sel;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range$$1 = sel.ranges[i];
          changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
          { makeChange(this$1, changes[i$1]); }
        if (newSel) { setSelectionReplaceHistory(this, newSel); }
        else if (this.cm) { ensureCursorVisible(this.cm); }
      }),
      undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
      redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
      undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
      redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

      setExtending: function(val) {this.extend = val;},
      getExtending: function() {return this.extend},

      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
        for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
        return {undo: done, redo: undone}
      },
      clearHistory: function() {this.history = new History(this.history.maxGeneration);},

      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit)
          { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
        return this.history.generation
      },
      isClean: function (gen) {
        return this.history.generation == (gen || this.cleanGeneration)
      },

      getHistory: function() {
        return {done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)}
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history.maxGeneration);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },

      setGutterMarker: docMethodOp(function(line, gutterID, value) {
        return changeLine(this, line, "gutter", function (line) {
          var markers = line.gutterMarkers || (line.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
          return true
        })
      }),

      clearGutter: docMethodOp(function(gutterID) {
        var this$1 = this;

        this.iter(function (line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            changeLine(this$1, line, "gutter", function () {
              line.gutterMarkers[gutterID] = null;
              if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
              return true
            });
          }
        });
      }),

      lineInfo: function(line) {
        var n;
        if (typeof line == "number") {
          if (!isLine(this, line)) { return null }
          n = line;
          line = getLine(this, line);
          if (!line) { return null }
        } else {
          n = lineNo(line);
          if (n == null) { return null }
        }
        return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
                textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
                widgets: line.widgets}
      },

      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
          var prop = where == "text" ? "textClass"
                   : where == "background" ? "bgClass"
                   : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line[prop]) { line[prop] = cls; }
          else if (classTest(cls).test(line[prop])) { return false }
          else { line[prop] += " " + cls; }
          return true
        })
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
          var prop = where == "text" ? "textClass"
                   : where == "background" ? "bgClass"
                   : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line[prop];
          if (!cur) { return false }
          else if (cls == null) { line[prop] = null; }
          else {
            var found = cur.match(classTest(cls));
            if (!found) { return false }
            var end = found.index + found[0].length;
            line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
          }
          return true
        })
      }),

      addLineWidget: docMethodOp(function(handle, node, options) {
        return addLineWidget(this, handle, node, options)
      }),
      removeLineWidget: function(widget) { widget.clear(); },

      markText: function(from, to, options) {
        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
      },
      setBookmark: function(pos, options) {
        var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: false, shared: options && options.shared,
                        handleMouseEvents: options && options.handleMouseEvents};
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark")
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine(this, pos.line).markedSpans;
        if (spans) { for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) &&
              (span.to == null || span.to >= pos.ch))
            { markers.push(span.marker.parent || span.marker); }
        } }
        return markers
      },
      findMarks: function(from, to, filter) {
        from = clipPos(this, from); to = clipPos(this, to);
        var found = [], lineNo$$1 = from.line;
        this.iter(from.line, to.line + 1, function (line) {
          var spans = line.markedSpans;
          if (spans) { for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                  span.from == null && lineNo$$1 != from.line ||
                  span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
                (!filter || filter(span.marker)))
              { found.push(span.marker.parent || span.marker); }
          } }
          ++lineNo$$1;
        });
        return found
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function (line) {
          var sps = line.markedSpans;
          if (sps) { for (var i = 0; i < sps.length; ++i)
            { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
        });
        return markers
      },

      posFromIndex: function(off) {
        var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function (line) {
          var sz = line.text.length + sepSize;
          if (sz > off) { ch = off; return true }
          off -= sz;
          ++lineNo$$1;
        });
        return clipPos(this, Pos(lineNo$$1, ch))
      },
      indexFromPos: function (coords) {
        coords = clipPos(this, coords);
        var index = coords.ch;
        if (coords.line < this.first || coords.ch < 0) { return 0 }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
          index += line.text.length + sepSize;
        });
        return index
      },

      copy: function(copyHistory) {
        var doc = new Doc(getLines(this, this.first, this.first + this.size),
                          this.modeOption, this.first, this.lineSep, this.direction);
        doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc
      },

      linkedDoc: function(options) {
        if (!options) { options = {}; }
        var from = this.first, to = this.first + this.size;
        if (options.from != null && options.from > from) { from = options.from; }
        if (options.to != null && options.to < to) { to = options.to; }
        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
        if (options.sharedHist) { copy.history = this.history
        ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
        copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
        copySharedMarkers(copy, findSharedMarkers(this));
        return copy
      },
      unlinkDoc: function(other) {
        var this$1 = this;

        if (other instanceof CodeMirror) { other = other.doc; }
        if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];
          if (link.doc != other) { continue }
          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break
        } }
        // If the histories were shared, split them again
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f) {linkedDocs(this, f);},

      getMode: function() {return this.mode},
      getEditor: function() {return this.cm},

      splitLines: function(str) {
        if (this.lineSep) { return str.split(this.lineSep) }
        return splitLinesAuto(str)
      },
      lineSeparator: function() { return this.lineSep || "\n" },

      setDirection: docMethodOp(function (dir) {
        if (dir != "rtl") { dir = "ltr"; }
        if (dir == this.direction) { return }
        this.direction = dir;
        this.iter(function (line) { return line.order = null; });
        if (this.cm) { directionChanged(this.cm); }
      })
    });

    // Public alias.
    Doc.prototype.eachLine = Doc.prototype.iter;

    // Kludge to work around strange IE behavior where it'll sometimes
    // re-fire a series of drag-related events right after the drop (#1551)
    var lastDrop = 0;

    function onDrop(e) {
      var cm = this;
      clearDragCursor(cm);
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
        { return }
      e_preventDefault(e);
      if (ie) { lastDrop = +new Date; }
      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
      if (!pos || cm.isReadOnly()) { return }
      // Might be a file drop, in which case we simply extract the text
      // and insert it.
      if (files && files.length && window.FileReader && window.File) {
        var n = files.length, text = Array(n), read = 0;
        var loadFile = function (file, i) {
          if (cm.options.allowDropFileTypes &&
              indexOf(cm.options.allowDropFileTypes, file.type) == -1)
            { return }

          var reader = new FileReader;
          reader.onload = operation(cm, function () {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
            text[i] = content;
            if (++read == n) {
              pos = clipPos(cm.doc, pos);
              var change = {from: pos, to: pos,
                            text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                            origin: "paste"};
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
            }
          });
          reader.readAsText(file);
        };
        for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
      } else { // Normal drop
        // Don't do a replace if the drop happened inside of the selected text.
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          // Ensure the editor is re-focused
          setTimeout(function () { return cm.display.input.focus(); }, 20);
          return
        }
        try {
          var text$1 = e.dataTransfer.getData("Text");
          if (text$1) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy)
              { selected = cm.listSelections(); }
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
              { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
            cm.replaceSelection(text$1, "around", "paste");
            cm.display.input.focus();
          }
        }
        catch(e){}
      }
    }

    function onDragStart(cm, e) {
      if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

      e.dataTransfer.setData("Text", cm.getSelection());
      e.dataTransfer.effectAllowed = "copyMove";

      // Use dummy image instead of default browsers image.
      // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
      if (e.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          // Force a relayout, or Opera won't use our image for some obscure reason
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto) { img.parentNode.removeChild(img); }
      }
    }

    function onDragOver(cm, e) {
      var pos = posFromMouse(cm, e);
      if (!pos) { return }
      var frag = document.createDocumentFragment();
      drawSelectionCursor(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd(cm.display.dragCursor, frag);
    }

    function clearDragCursor(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }

    // These must be handled carefully, because naively registering a
    // handler for each editor will cause the editors to never be
    // garbage collected.

    function forEachCodeMirror(f) {
      if (!document.getElementsByClassName) { return }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i = 0; i < byClass.length; i++) {
        var cm = byClass[i].CodeMirror;
        if (cm) { editors.push(cm); }
      }
      if (editors.length) { editors[0].operation(function () {
        for (var i = 0; i < editors.length; i++) { f(editors[i]); }
      }); }
    }

    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) { return }
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      // When the window resizes, we need to refresh active editors.
      var resizeTimer;
      on(window, "resize", function () {
        if (resizeTimer == null) { resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100); }
      });
      // When the window loses focus, we want to show the editor as blurred
      on(window, "blur", function () { return forEachCodeMirror(onBlur); });
    }
    // Called when the window resizes
    function onResize(cm) {
      var d = cm.display;
      // Might be a text scaling operation, clear size caches.
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.scrollbarsClipped = false;
      cm.setSize();
    }

    var keyNames = {
      3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
      19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
      36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
      46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
      106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
      173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
      221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
      63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
    };

    // Number keys
    for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
    // Alphabetic keys
    for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
    // Function keys
    for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

    var keyMap = {};

    keyMap.basic = {
      "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
      "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
      "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab", "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    // Note that the save and find-related commands aren't defined by
    // default. User code or addons can define them. Unknown commands
    // are simply ignored.
    keyMap.pcDefault = {
      "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
      "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
      "fallthrough": "basic"
    };
    // Very basic readline/emacs-style bindings, which are standard on Mac.
    keyMap.emacsy = {
      "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
      "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
      "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap.macDefault = {
      "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
      "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
      "fallthrough": ["basic", "emacsy"]
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

    // KEYMAP DISPATCH

    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/);
      name = parts[parts.length - 1];
      var alt, ctrl, shift, cmd;
      for (var i = 0; i < parts.length - 1; i++) {
        var mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
        else if (/^a(lt)?$/i.test(mod)) { alt = true; }
        else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
        else if (/^s(hift)?$/i.test(mod)) { shift = true; }
        else { throw new Error("Unrecognized modifier name: " + mod) }
      }
      if (alt) { name = "Alt-" + name; }
      if (ctrl) { name = "Ctrl-" + name; }
      if (cmd) { name = "Cmd-" + name; }
      if (shift) { name = "Shift-" + name; }
      return name
    }

    // This is a kludge to keep keymaps mostly working as raw objects
    // (backwards compatibility) while at the same time support features
    // like normalization and multi-stroke key bindings. It compiles a
    // new normalized keymap, and then updates the old object to reflect
    // this.
    function normalizeKeyMap(keymap) {
      var copy = {};
      for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
        if (value == "...") { delete keymap[keyname]; continue }

        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = (void 0), name = (void 0);
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) { copy[name] = val; }
          else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
        }
        delete keymap[keyname];
      } }
      for (var prop in copy) { keymap[prop] = copy[prop]; }
      return keymap
    }

    function lookupKey(key, map$$1, handle, context) {
      map$$1 = getKeyMap(map$$1);
      var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
      if (found === false) { return "nothing" }
      if (found === "...") { return "multi" }
      if (found != null && handle(found)) { return "handled" }

      if (map$$1.fallthrough) {
        if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
          { return lookupKey(key, map$$1.fallthrough, handle, context) }
        for (var i = 0; i < map$$1.fallthrough.length; i++) {
          var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
          if (result) { return result }
        }
      }
    }

    // Modifier key presses don't count as 'real' key presses for the
    // purpose of keymap fallthrough.
    function isModifierKey(value) {
      var name = typeof value == "string" ? value : keyNames[value.keyCode];
      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
    }

    function addModifierNames(name, event, noShift) {
      var base = name;
      if (event.altKey && base != "Alt") { name = "Alt-" + name; }
      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
      if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
      return name
    }

    // Look up the name of a key as indicated by an event object.
    function keyName(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) { return false }
      var name = keyNames[event.keyCode];
      if (name == null || event.altGraphKey) { return false }
      // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
      // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
      if (event.keyCode == 3 && event.code) { name = event.code; }
      return addModifierNames(name, event, noShift)
    }

    function getKeyMap(val) {
      return typeof val == "string" ? keyMap[val] : val
    }

    // Helper for deleting text near the selection(s), used to implement
    // backspace, delete, and similar functionality.
    function deleteNearSelection(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      // Build up a set of ranges to kill first, merging overlapping
      // ranges.
      for (var i = 0; i < ranges.length; i++) {
        var toKill = compute(ranges[i]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break
          }
        }
        kill.push(toKill);
      }
      // Next, remove those actual ranges.
      runInOp(cm, function () {
        for (var i = kill.length - 1; i >= 0; i--)
          { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
        ensureCursorVisible(cm);
      });
    }

    function moveCharLogically(line, ch, dir) {
      var target = skipExtendingChars(line.text, ch + dir, dir);
      return target < 0 || target > line.text.length ? null : target
    }

    function moveLogically(line, start, dir) {
      var ch = moveCharLogically(line, start.ch, dir);
      return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
    }

    function endOfLine(visually, cm, lineObj, lineNo, dir) {
      if (visually) {
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
          var part = dir < 0 ? lst(order) : order[0];
          var moveInStorageOrder = (dir < 0) == (part.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch;
          // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
          // it could be that the last bidi part is not on the last visual line,
          // since visual lines contain content order-consecutive chunks.
          // Thus, in rtl, we are looking for the first (content-order) character
          // in the rtl chunk that is on the last line (that is, the same line
          // as the last (content-order) character).
          if (part.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine(cm, lineObj);
            ch = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared(cm, prep, ch).top;
            ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
            if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
          } else { ch = dir < 0 ? part.to : part.from; }
          return new Pos(lineNo, ch, sticky)
        }
      }
      return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
    }

    function moveVisually(cm, line, start, dir) {
      var bidi = getOrder(line, cm.doc.direction);
      if (!bidi) { return moveLogically(line, start, dir) }
      if (start.ch >= line.text.length) {
        start.ch = line.text.length;
        start.sticky = "before";
      } else if (start.ch <= 0) {
        start.ch = 0;
        start.sticky = "after";
      }
      var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
        // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
        // nothing interesting happens.
        return moveLogically(line, start, dir)
      }

      var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
      var prep;
      var getWrappedLineExtent = function (ch) {
        if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
        prep = prep || prepareMeasureForLine(cm, line);
        return wrappedLineExtentChar(cm, line, prep, ch)
      };
      var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

      if (cm.doc.direction == "rtl" || part.level == 1) {
        var moveInStorageOrder = (part.level == 1) == (dir < 0);
        var ch = mv(start, moveInStorageOrder ? 1 : -1);
        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
          // Case 2: We move within an rtl part or in an rtl editor on the same visual line
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos(start.line, ch, sticky)
        }
      }

      // Case 3: Could not move within this bidi part in this visual line, so leave
      // the current bidi part

      var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
        var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
          ? new Pos(start.line, mv(ch, 1), "before")
          : new Pos(start.line, ch, "after"); };

        for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
          var part = bidi[partPos];
          var moveInStorageOrder = (dir > 0) == (part.level != 1);
          var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
          if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
          ch = moveInStorageOrder ? part.from : mv(part.to, -1);
          if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
        }
      };

      // Case 3a: Look for other bidi parts on the same visual line
      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
      if (res) { return res }

      // Case 3b: Look for other bidi parts on the next visual line
      var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res) { return res }
      }

      // Case 4: Nowhere to move
      return null
    }

    // Commands are parameter-less actions that can be performed on an
    // editor, mostly used for keybindings.
    var commands = {
      selectAll: selectAll,
      singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
      killLine: function (cm) { return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
          else
            { return {from: range.head, to: Pos(range.head.line, len)} }
        } else {
          return {from: range.from(), to: range.to()}
        }
      }); },
      deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
        from: Pos(range.from().line, 0),
        to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
      }); }); },
      delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
        from: Pos(range.from().line, 0), to: range.from()
      }); }); },
      delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()}
      }); },
      delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos }
      }); },
      undo: function (cm) { return cm.undo(); },
      redo: function (cm) { return cm.redo(); },
      undoSelection: function (cm) { return cm.undoSelection(); },
      redoSelection: function (cm) { return cm.redoSelection(); },
      goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
      goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
      goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
        {origin: "+move", bias: 1}
      ); },
      goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
        {origin: "+move", bias: 1}
      ); },
      goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
        {origin: "+move", bias: -1}
      ); },
      goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
      }, sel_move); },
      goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div")
      }, sel_move); },
      goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
        return pos
      }, sel_move); },
      goLineUp: function (cm) { return cm.moveV(-1, "line"); },
      goLineDown: function (cm) { return cm.moveV(1, "line"); },
      goPageUp: function (cm) { return cm.moveV(-1, "page"); },
      goPageDown: function (cm) { return cm.moveV(1, "page"); },
      goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
      goCharRight: function (cm) { return cm.moveH(1, "char"); },
      goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
      goColumnRight: function (cm) { return cm.moveH(1, "column"); },
      goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
      goGroupRight: function (cm) { return cm.moveH(1, "group"); },
      goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
      goWordRight: function (cm) { return cm.moveH(1, "word"); },
      delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
      delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
      delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
      delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
      delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
      delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
      indentAuto: function (cm) { return cm.indentSelection("smart"); },
      indentMore: function (cm) { return cm.indentSelection("add"); },
      indentLess: function (cm) { return cm.indentSelection("subtract"); },
      insertTab: function (cm) { return cm.replaceSelection("\t"); },
      insertSoftTab: function (cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i = 0; i < ranges.length; i++) {
          var pos = ranges[i].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected()) { cm.indentSelection("add"); }
        else { cm.execCommand("insertTab"); }
      },
      // Swap the two chars left and right of each selection's head.
      // Move cursor behind the two swapped characters afterwards.
      //
      // Doesn't consider line feeds a character.
      // Doesn't scan more than one line above to find a character.
      // Doesn't do anything on an empty line.
      // Doesn't do anything with non-empty selections.
      transposeChars: function (cm) { return runInOp(cm, function () {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) { continue }
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      }); },
      newlineAndIndent: function (cm) { return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--)
          { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++)
          { cm.indentLine(sels[i$1].from().line, null, true); }
        ensureCursorVisible(cm);
      }); },
      openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
      toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
    };


    function lineStart(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLine(line);
      if (visual != line) { lineN = lineNo(visual); }
      return endOfLine(true, cm, visual, lineN, 1)
    }
    function lineEnd(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLineEnd(line);
      if (visual != line) { lineN = lineNo(visual); }
      return endOfLine(true, cm, line, lineN, -1)
    }
    function lineStartSmart(cm, pos) {
      var start = lineStart(cm, pos.line);
      var line = getLine(cm.doc, start.line);
      var order = getOrder(line, cm.doc.direction);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
      }
      return start
    }

    // Run a handler that was bound to a key.
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) { return false }
      }
      // Ensure previous input has been read, so that the handler sees a
      // consistent view of the document
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        if (dropShift) { cm.display.shift = false; }
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done
    }

    function lookupKeyForEditor(cm, name, handle) {
      for (var i = 0; i < cm.state.keyMaps.length; i++) {
        var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
        if (result) { return result }
      }
      return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
        || lookupKey(name, cm.options.keyMap, handle, cm)
    }

    // Note that, despite the name, this function is also used to check
    // for bound mouse clicks.

    var stopSeq = new Delayed;

    function dispatchKey(cm, name, e, handle) {
      var seq = cm.state.keySeq;
      if (seq) {
        if (isModifierKey(name)) { return "handled" }
        if (/\'$/.test(name))
          { cm.state.keySeq = null; }
        else
          { stopSeq.set(50, function () {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          }); }
        if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
      }
      return dispatchKeyInner(cm, name, e, handle)
    }

    function dispatchKeyInner(cm, name, e, handle) {
      var result = lookupKeyForEditor(cm, name, handle);

      if (result == "multi")
        { cm.state.keySeq = name; }
      if (result == "handled")
        { signalLater(cm, "keyHandled", cm, name, e); }

      if (result == "handled" || result == "multi") {
        e_preventDefault(e);
        restartBlink(cm);
      }

      return !!result
    }

    // Handle a key from the keydown event.
    function handleKeyBinding(cm, e) {
      var name = keyName(e, true);
      if (!name) { return false }

      if (e.shiftKey && !cm.state.keySeq) {
        // First try to resolve full name (including 'Shift-'). Failing
        // that, see if there is a cursor-motion command (starting with
        // 'go') bound to the keyname without 'Shift-'.
        return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
            || dispatchKey(cm, name, e, function (b) {
                 if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                   { return doHandleBinding(cm, b) }
               })
      } else {
        return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
      }
    }

    // Handle a key from the keypress event
    function handleCharBinding(cm, e, ch) {
      return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
    }

    var lastStoppedKey = null;
    function onKeyDown(e) {
      var cm = this;
      cm.curOp.focus = activeElt();
      if (signalDOMEvent(cm, e)) { return }
      // IE does strange things with escape.
      if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
      var code = e.keyCode;
      cm.display.shift = code == 16 || e.shiftKey;
      var handled = handleKeyBinding(cm, e);
      if (presto) {
        lastStoppedKey = handled ? code : null;
        // Opera has no cut event... we try to at least catch the key combo
        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
          { cm.replaceSelection("", null, "cut"); }
      }

      // Turn mouse into crosshair when Alt is held on Mac.
      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
        { showCrossHair(cm); }
    }

    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass(lineDiv, "CodeMirror-crosshair");

      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off(document, "keyup", up);
          off(document, "mouseover", up);
        }
      }
      on(document, "keyup", up);
      on(document, "mouseover", up);
    }

    function onKeyUp(e) {
      if (e.keyCode == 16) { this.doc.sel.shift = false; }
      signalDOMEvent(this, e);
    }

    function onKeyPress(e) {
      var cm = this;
      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
      if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      // Some browsers fire keypress events for backspace
      if (ch == "\x08") { return }
      if (handleCharBinding(cm, e, ch)) { return }
      cm.display.input.onKeyPress(e);
    }

    var DOUBLECLICK_DELAY = 400;

    var PastClick = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };

    PastClick.prototype.compare = function (time, pos, button) {
      return this.time + DOUBLECLICK_DELAY > time &&
        cmp(pos, this.pos) == 0 && button == this.button
    };

    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
      var now = +new Date;
      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
        lastClick = lastDoubleClick = null;
        return "triple"
      } else if (lastClick && lastClick.compare(now, pos, button)) {
        lastDoubleClick = new PastClick(now, pos, button);
        lastClick = null;
        return "double"
      } else {
        lastClick = new PastClick(now, pos, button);
        lastDoubleClick = null;
        return "single"
      }
    }

    // A mouse down can be a single click, double click, triple click,
    // start of selection drag, start of text drag, new cursor
    // (ctrl-click), rectangle drag (alt-drag), or xwin
    // middle-click-paste. Or it might be a click on something we should
    // not interfere with, such as a scrollbar or widget.
    function onMouseDown(e) {
      var cm = this, display = cm.display;
      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
      display.input.ensurePolled();
      display.shift = e.shiftKey;

      if (eventInWidget(display, e)) {
        if (!webkit) {
          // Briefly turn off draggability, to allow widgets to do
          // normal dragging things.
          display.scroller.draggable = false;
          setTimeout(function () { return display.scroller.draggable = true; }, 100);
        }
        return
      }
      if (clickInGutter(cm, e)) { return }
      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
      window.focus();

      // #3261: make sure, that we're not starting a second selection
      if (button == 1 && cm.state.selectingText)
        { cm.state.selectingText(e); }

      if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

      if (button == 1) {
        if (pos) { leftButtonDown(cm, pos, repeat, e); }
        else if (e_target(e) == display.scroller) { e_preventDefault(e); }
      } else if (button == 2) {
        if (pos) { extendSelection(cm.doc, pos); }
        setTimeout(function () { return display.input.focus(); }, 20);
      } else if (button == 3) {
        if (captureRightClick) { cm.display.input.onContextMenu(e); }
        else { delayBlurEvent(cm); }
      }
    }

    function handleMappedButton(cm, button, pos, repeat, event) {
      var name = "Click";
      if (repeat == "double") { name = "Double" + name; }
      else if (repeat == "triple") { name = "Triple" + name; }
      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

      return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
        if (typeof bound == "string") { bound = commands[bound]; }
        if (!bound) { return false }
        var done = false;
        try {
          if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
          done = bound(cm, pos) != Pass;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done
      })
    }

    function configureMouse(cm, repeat, event) {
      var option = cm.getOption("configureMouse");
      var value = option ? option(cm, repeat, event) : {};
      if (value.unit == null) {
        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
      }
      if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
      if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
      if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
      return value
    }

    function leftButtonDown(cm, pos, repeat, event) {
      if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
      else { cm.curOp.focus = activeElt(); }

      var behavior = configureMouse(cm, repeat, event);

      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
          repeat == "single" && (contained = sel.contains(pos)) > -1 &&
          (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
          (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
        { leftButtonStartDrag(cm, event, pos, behavior); }
      else
        { leftButtonSelect(cm, event, pos, behavior); }
    }

    // Start a text drag. When it ends, see if any dragging actually
    // happen, and treat as a click if it didn't.
    function leftButtonStartDrag(cm, event, pos, behavior) {
      var display = cm.display, moved = false;
      var dragEnd = operation(cm, function (e) {
        if (webkit) { display.scroller.draggable = false; }
        cm.state.draggingText = false;
        off(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off(display.scroller, "dragstart", dragStart);
        off(display.scroller, "drop", dragEnd);
        if (!moved) {
          e_preventDefault(e);
          if (!behavior.addNew)
            { extendSelection(cm.doc, pos, null, null, behavior.extend); }
          // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
          if (webkit || ie && ie_version == 9)
            { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
          else
            { display.input.focus(); }
        }
      });
      var mouseMove = function(e2) {
        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
      };
      var dragStart = function () { return moved = true; };
      // Let the drag handler handle this.
      if (webkit) { display.scroller.draggable = true; }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      // IE's approach to draggable
      if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
      on(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on(display.scroller, "dragstart", dragStart);
      on(display.scroller, "drop", dragEnd);

      delayBlurEvent(cm);
      setTimeout(function () { return display.input.focus(); }, 20);
    }

    function rangeForUnit(cm, pos, unit) {
      if (unit == "char") { return new Range(pos, pos) }
      if (unit == "word") { return cm.findWordAt(pos) }
      if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
      var result = unit(cm, pos);
      return new Range(result.from, result.to)
    }

    // Normal selection, as opposed to text dragging.
    function leftButtonSelect(cm, event, start, behavior) {
      var display = cm.display, doc = cm.doc;
      e_preventDefault(event);

      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc.sel.contains(start);
        if (ourIndex > -1)
          { ourRange = ranges[ourIndex]; }
        else
          { ourRange = new Range(start, start); }
      } else {
        ourRange = doc.sel.primary();
        ourIndex = doc.sel.primIndex;
      }

      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) { ourRange = new Range(start, start); }
        start = posFromMouse(cm, event, true, true);
        ourIndex = -1;
      } else {
        var range$$1 = rangeForUnit(cm, start, behavior.unit);
        if (behavior.extend)
          { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
        else
          { ourRange = range$$1; }
      }

      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
        startSel = doc.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                     {scroll: false, origin: "*mouse"});
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                     {scroll: false, origin: "*mouse"});
        startSel = doc.sel;
      } else {
        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
      }

      var lastPos = start;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) { return }
        lastPos = pos;

        if (behavior.unit == "rectangle") {
          var ranges = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
               line <= end; line++) {
            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
            if (left == right)
              { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
            else if (text.length > leftPos)
              { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
          }
          if (!ranges.length) { ranges.push(new Range(start, start)); }
          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                       {origin: "*mouse", scroll: false});
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range$$1 = rangeForUnit(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp(range$$1.anchor, anchor) > 0) {
            head = range$$1.head;
            anchor = minPos(oldRange.from(), range$$1.anchor);
          } else {
            head = range$$1.anchor;
            anchor = maxPos(oldRange.to(), range$$1.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
        }
      }

      var editorSize = display.wrapper.getBoundingClientRect();
      // Used to ensure timeout re-tries don't fire when another extend
      // happened in the meantime (clearTimeout isn't reliable -- at
      // least on Chrome, the timeouts still happen even when cleared,
      // if the clear happens after their scheduled firing time).
      var counter = 0;

      function extend(e) {
        var curCount = ++counter;
        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
        if (!cur) { return }
        if (cmp(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt();
          extendTo(cur);
          var visible = visibleLines(display, doc);
          if (cur.line >= visible.to || cur.line < visible.from)
            { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) { setTimeout(operation(cm, function () {
            if (counter != curCount) { return }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50); }
        }
      }

      function done(e) {
        cm.state.selectingText = false;
        counter = Infinity;
        // If e is null or undefined we interpret this as someone trying
        // to explicitly cancel the selection rather than the user
        // letting go of the mouse button.
        if (e) {
          e_preventDefault(e);
          display.input.focus();
        }
        off(display.wrapper.ownerDocument, "mousemove", move);
        off(display.wrapper.ownerDocument, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }

      var move = operation(cm, function (e) {
        if (e.buttons === 0 || !e_button(e)) { done(e); }
        else { extend(e); }
      });
      var up = operation(cm, done);
      cm.state.selectingText = up;
      on(display.wrapper.ownerDocument, "mousemove", move);
      on(display.wrapper.ownerDocument, "mouseup", up);
    }

    // Used when mouse-selecting to adjust the anchor to the proper side
    // of a bidi jump depending on the visual position of the head.
    function bidiSimplify(cm, range$$1) {
      var anchor = range$$1.anchor;
      var head = range$$1.head;
      var anchorLine = getLine(cm.doc, anchor.line);
      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
      var order = getOrder(anchorLine);
      if (!order) { return range$$1 }
      var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
      if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
      var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order.length) { return range$$1 }

      // Compute the relative visual position of the head compared to the
      // anchor (<0 is to the left, >0 to the right)
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt(order, head.ch, head.sticky);
        var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary)
          { leftSide = dir < 0; }
        else
          { leftSide = dir > 0; }
      }

      var usePart = order[boundary + (leftSide ? -1 : 0)];
      var from = leftSide == (usePart.level == 1);
      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
      return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
    }


    // Determines whether an event happened in the gutter, and fires the
    // handlers for the corresponding event.
    function gutterEvent(cm, e, type, prevent) {
      var mX, mY;
      if (e.touches) {
        mX = e.touches[0].clientX;
        mY = e.touches[0].clientY;
      } else {
        try { mX = e.clientX; mY = e.clientY; }
        catch(e) { return false }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
      if (prevent) { e_preventDefault(e); }

      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();

      if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
      mY -= lineBox.top - display.viewOffset;

      for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
        var g = display.gutters.childNodes[i];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight(cm.doc, mY);
          var gutter = cm.display.gutterSpecs[i];
          signal(cm, type, cm, line, gutter.className, e);
          return e_defaultPrevented(e)
        }
      }
    }

    function clickInGutter(cm, e) {
      return gutterEvent(cm, e, "gutterClick", true)
    }

    // CONTEXT MENU HANDLING

    // To make the context menu work, we need to briefly unhide the
    // textarea (making it as unobtrusive as possible) to let the
    // right-click take effect on it.
    function onContextMenu(cm, e) {
      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
      if (signalDOMEvent(cm, e, "contextmenu")) { return }
      if (!captureRightClick) { cm.display.input.onContextMenu(e); }
    }

    function contextMenuInGutter(cm, e) {
      if (!hasHandler(cm, "gutterContextMenu")) { return false }
      return gutterEvent(cm, e, "gutterContextMenu", false)
    }

    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
        cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }

    var Init = {toString: function(){return "CodeMirror.Init"}};

    var defaults = {};
    var optionHandlers = {};

    function defineOptions(CodeMirror) {
      var optionHandlers = CodeMirror.optionHandlers;

      function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle) { optionHandlers[name] =
          notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
      }

      CodeMirror.defineOption = option;

      // Passed to option handlers when there is no old value.
      CodeMirror.Init = Init;

      // These two are, on init, called from the constructor because they
      // have to be initialized before the editor can start at all.
      option("value", "", function (cm, val) { return cm.setValue(val); }, true);
      option("mode", null, function (cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);

      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function (cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);

      option("lineSeparator", null, function (cm, val) {
        cm.doc.lineSep = val;
        if (!val) { return }
        var newBreaks = [], lineNo = cm.doc.first;
        cm.doc.iter(function (line) {
          for (var pos = 0;;) {
            var found = line.text.indexOf(val, pos);
            if (found == -1) { break }
            pos = found + val.length;
            newBreaks.push(Pos(lineNo, found));
          }
          lineNo++;
        });
        for (var i = newBreaks.length - 1; i >= 0; i--)
          { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
      });
      option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
        if (old != Init) { cm.refresh(); }
      });
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
      option("electricChars", true);
      option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
        throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
      }, true);
      option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
      option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
      option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);

      option("theme", "default", function (cm) {
        themeChanged(cm);
        updateGutters(cm);
      }, true);
      option("keyMap", "default", function (cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != Init && getKeyMap(old);
        if (prev && prev.detach) { prev.detach(cm, next); }
        if (next.attach) { next.attach(cm, prev || null); }
      });
      option("extraKeys", null);
      option("configureMouse", null);

      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function (cm, val) {
        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
        updateGutters(cm);
      }, true);
      option("fixedGutter", true, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
      option("scrollbarStyle", "native", function (cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option("lineNumbers", false, function (cm, val) {
        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
        updateGutters(cm);
      }, true);
      option("firstLineNumber", 1, updateGutters, true);
      option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
      option("showCursorWhenSelecting", false, updateSelection, true);

      option("resetSelectionOnContextMenu", true);
      option("lineWiseCopyCut", true);
      option("pasteLinesPerSelection", true);
      option("selectionsMayTouch", false);

      option("readOnly", false, function (cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
      option("dragDrop", true, dragDropChanged);
      option("allowDropFileTypes", null);

      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1, updateSelection, true);
      option("singleCursorHeightPerLine", true, updateSelection, true);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true, resetModeState, true);
      option("addModeClass", false, resetModeState, true);
      option("pollInterval", 100);
      option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
      option("historyEventDelay", 1250);
      option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
      option("maxHighlightLength", 10000, resetModeState, true);
      option("moveInputWithCursor", true, function (cm, val) {
        if (!val) { cm.display.input.resetPosition(); }
      });

      option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
      option("autofocus", null);
      option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
      option("phrases", null);
    }

    function dragDropChanged(cm, value, old) {
      var wasOn = old && old != Init;
      if (!value != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value ? on : off;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }

    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function () { return updateScrollbars(cm); }, 100);
    }

    // A CodeMirror instance represents an editor. This is the object
    // that user code is usually dealing with.

    function CodeMirror(place, options) {
      var this$1 = this;

      if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

      this.options = options = options ? copyObj(options) : {};
      // Determine effective options based on given values and defaults.
      copyObj(defaults, options, false);

      var doc = options.value;
      if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
      else if (options.mode) { doc.modeOption = options.mode; }
      this.doc = doc;

      var input = new CodeMirror.inputStyles[options.inputStyle](this);
      var display = this.display = new Display(place, doc, input, options);
      display.wrapper.CodeMirror = this;
      themeChanged(this);
      if (options.lineWrapping)
        { this.display.wrapper.className += " CodeMirror-wrap"; }
      initScrollbars(this);

      this.state = {
        keyMaps: [],  // stores maps added by addKeyMap
        overlays: [], // highlighting overlays, as added by addOverlay
        modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
        pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
        selectingText: false,
        draggingText: false,
        highlight: new Delayed(), // stores highlight worker timeout
        keySeq: null,  // Unfinished key sequence
        specialChars: null
      };

      if (options.autofocus && !mobile) { display.input.focus(); }

      // Override magic textarea content restore that IE sometimes does
      // on our hidden textarea on reload
      if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

      registerEventHandlers(this);
      ensureGlobalHandlers();

      startOperation(this);
      this.curOp.forceUpdate = true;
      attachDoc(this, doc);

      if ((options.autofocus && !mobile) || this.hasFocus())
        { setTimeout(bind(onFocus, this), 20); }
      else
        { onBlur(this); }

      for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
        { optionHandlers[opt](this$1, options[opt], Init); } }
      maybeUpdateLineNumberWidth(this);
      if (options.finishInit) { options.finishInit(this); }
      for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
      endOperation(this);
      // Suppress optimizelegibility in Webkit, since it breaks text
      // measuring on line wrapping boundaries.
      if (webkit && options.lineWrapping &&
          getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
        { display.lineDiv.style.textRendering = "auto"; }
    }

    // The default configuration options.
    CodeMirror.defaults = defaults;
    // Functions to run when options are changed.
    CodeMirror.optionHandlers = optionHandlers;

    // Attach the necessary event handlers when initializing the editor
    function registerEventHandlers(cm) {
      var d = cm.display;
      on(d.scroller, "mousedown", operation(cm, onMouseDown));
      // Older IE's will not fire a second mousedown for a double click
      if (ie && ie_version < 11)
        { on(d.scroller, "dblclick", operation(cm, function (e) {
          if (signalDOMEvent(cm, e)) { return }
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
          e_preventDefault(e);
          var word = cm.findWordAt(pos);
          extendSelection(cm.doc, word.anchor, word.head);
        })); }
      else
        { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
      // Some browsers fire contextmenu *after* opening the menu, at
      // which point we can't mess with it anymore. Context menu is
      // handled in onMouseDown for these browsers.
      on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

      // Used to suppress mouse event handling when a touch happens
      var touchFinished, prevTouch = {end: 0};
      function finishTouch() {
        if (d.activeTouch) {
          touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
          prevTouch = d.activeTouch;
          prevTouch.end = +new Date;
        }
      }
      function isMouseLikeTouchEvent(e) {
        if (e.touches.length != 1) { return false }
        var touch = e.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1
      }
      function farAway(touch, other) {
        if (other.left == null) { return true }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20
      }
      on(d.scroller, "touchstart", function (e) {
        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
          d.input.ensurePolled();
          clearTimeout(touchFinished);
          var now = +new Date;
          d.activeTouch = {start: now, moved: false,
                           prev: now - prevTouch.end <= 300 ? prevTouch : null};
          if (e.touches.length == 1) {
            d.activeTouch.left = e.touches[0].pageX;
            d.activeTouch.top = e.touches[0].pageY;
          }
        }
      });
      on(d.scroller, "touchmove", function () {
        if (d.activeTouch) { d.activeTouch.moved = true; }
      });
      on(d.scroller, "touchend", function (e) {
        var touch = d.activeTouch;
        if (touch && !eventInWidget(d, e) && touch.left != null &&
            !touch.moved && new Date - touch.start < 300) {
          var pos = cm.coordsChar(d.activeTouch, "page"), range;
          if (!touch.prev || farAway(touch, touch.prev)) // Single tap
            { range = new Range(pos, pos); }
          else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
            { range = cm.findWordAt(pos); }
          else // Triple tap
            { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
          cm.setSelection(range.anchor, range.head);
          cm.focus();
          e_preventDefault(e);
        }
        finishTouch();
      });
      on(d.scroller, "touchcancel", finishTouch);

      // Sync scrolling between fake scrollbars and real scrollable
      // area, ensure viewport is updated when scrolling.
      on(d.scroller, "scroll", function () {
        if (d.scroller.clientHeight) {
          updateScrollTop(cm, d.scroller.scrollTop);
          setScrollLeft(cm, d.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });

      // Listen to wheel events in order to try and update the viewport on time.
      on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
      on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

      // Prevent wrapper from ever scrolling
      on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

      d.dragFunctions = {
        enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
        over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
        start: function (e) { return onDragStart(cm, e); },
        drop: operation(cm, onDrop),
        leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
      };

      var inp = d.input.getField();
      on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
      on(inp, "keydown", operation(cm, onKeyDown));
      on(inp, "keypress", operation(cm, onKeyPress));
      on(inp, "focus", function (e) { return onFocus(cm, e); });
      on(inp, "blur", function (e) { return onBlur(cm, e); });
    }

    var initHooks = [];
    CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

    // Indent the given line. The how parameter can be "smart",
    // "add"/null, "subtract", or "prev". When aggressive is false
    // (typically set to true for forced single-line indents), empty
    // lines are not indented, and places where the mode returns Pass
    // are left alone.
    function indentLine(cm, n, how, aggressive) {
      var doc = cm.doc, state;
      if (how == null) { how = "add"; }
      if (how == "smart") {
        // Fall back to "prev" when the mode doesn't have an indentation
        // method.
        if (!doc.mode.indent) { how = "prev"; }
        else { state = getContextBefore(cm, n).state; }
      }

      var tabSize = cm.options.tabSize;
      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
      if (line.stateAfter) { line.stateAfter = null; }
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) { return }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
        else { indentation = 0; }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);

      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs)
        { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
      if (pos < indentation) { indentString += spaceStr(indentation - pos); }

      if (indentString != curSpaceString) {
        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
        line.stateAfter = null;
        return true
      } else {
        // Ensure that, if the cursor was in the whitespace at the start
        // of the line, it is moved to the end of that space.
        for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
          var range = doc.sel.ranges[i$1];
          if (range.head.line == n && range.head.ch < curSpaceString.length) {
            var pos$1 = Pos(n, curSpaceString.length);
            replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
            break
          }
        }
      }
    }

    // This will be set to a {lineWise: bool, text: [string]} object, so
    // that, when pasting, we know what kind of selections the copied
    // text was made out of.
    var lastCopied = null;

    function setLastCopied(newLastCopied) {
      lastCopied = newLastCopied;
    }

    function applyTextInput(cm, inserted, deleted, sel, origin) {
      var doc = cm.doc;
      cm.display.shift = false;
      if (!sel) { sel = doc.sel; }

      var recent = +new Date - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto(inserted), multiPaste = null;
      // When pasting N lines into N selections, insert one line per selection
      if (paste && sel.ranges.length > 1) {
        if (lastCopied && lastCopied.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied.text.length == 0) {
            multiPaste = [];
            for (var i = 0; i < lastCopied.text.length; i++)
              { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map(textLines, function (l) { return [l]; });
        }
      }

      var updateInput = cm.curOp.updateInput;
      // Normal behavior is to insert the new text into every selection
      for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
        var range$$1 = sel.ranges[i$1];
        var from = range$$1.from(), to = range$$1.to();
        if (range$$1.empty()) {
          if (deleted && deleted > 0) // Handle deletion
            { from = Pos(from.line, from.ch - deleted); }
          else if (cm.state.overwrite && !paste) // Handle overwrite
            { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
          else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
            { from = to = Pos(from.line, 0); }
        }
        var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                           origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste)
        { triggerElectric(cm, inserted); }

      ensureCursorVisible(cm);
      if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }

    function handlePaste(e, cm) {
      var pasted = e.clipboardData && e.clipboardData.getData("Text");
      if (pasted) {
        e.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput)
          { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
        return true
      }
    }

    function triggerElectric(cm, inserted) {
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (!cm.options.electricChars || !cm.options.smartIndent) { return }
      var sel = cm.doc.sel;

      for (var i = sel.ranges.length - 1; i >= 0; i--) {
        var range$$1 = sel.ranges[i];
        if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
        var mode = cm.getModeAt(range$$1.head);
        var indented = false;
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indented = indentLine(cm, range$$1.head.line, "smart");
              break
            } }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
            { indented = indentLine(cm, range$$1.head.line, "smart"); }
        }
        if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
      }
    }

    function copyableRanges(cm) {
      var text = [], ranges = [];
      for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
        var line = cm.doc.sel.ranges[i].head.line;
        var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
        ranges.push(lineRange);
        text.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return {text: text, ranges: ranges}
    }

    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }

    function hiddenTextarea() {
      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      // The textarea is kept positioned near the cursor to prevent the
      // fact that it'll be scrolled into view on input from scrolling
      // our fake cursor out of view. On webkit, when wrap=off, paste is
      // very slow. So make the area wide instead.
      if (webkit) { te.style.width = "1000px"; }
      else { te.setAttribute("wrap", "off"); }
      // If border: 0; -- iOS fails to open keyboard (issue #1287)
      if (ios) { te.style.border = "1px solid black"; }
      disableBrowserMagic(te);
      return div
    }

    // The publicly visible API. Note that methodOp(f) means
    // 'wrap f in an operation, performed on its `this` parameter'.

    // This is not the complete set of editor methods. Most of the
    // methods defined on the Doc type are also injected into
    // CodeMirror.prototype, for backwards compatibility and
    // convenience.

    function addEditorMethods(CodeMirror) {
      var optionHandlers = CodeMirror.optionHandlers;

      var helpers = CodeMirror.helpers = {};

      CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function(){window.focus(); this.display.input.focus();},

        setOption: function(option, value) {
          var options = this.options, old = options[option];
          if (options[option] == value && option != "mode") { return }
          options[option] = value;
          if (optionHandlers.hasOwnProperty(option))
            { operation(this, optionHandlers[option])(this, value, old); }
          signal(this, "optionChange", this, option);
        },

        getOption: function(option) {return this.options[option]},
        getDoc: function() {return this.doc},

        addKeyMap: function(map$$1, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
        },
        removeKeyMap: function(map$$1) {
          var maps = this.state.keyMaps;
          for (var i = 0; i < maps.length; ++i)
            { if (maps[i] == map$$1 || maps[i].name == map$$1) {
              maps.splice(i, 1);
              return true
            } }
        },

        addOverlay: methodOp(function(spec, options) {
          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
          if (mode.startState) { throw new Error("Overlays may not be stateful.") }
          insertSorted(this.state.overlays,
                       {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                        priority: (options && options.priority) || 0},
                       function (overlay) { return overlay.priority; });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var this$1 = this;

          var overlays = this.state.overlays;
          for (var i = 0; i < overlays.length; ++i) {
            var cur = overlays[i].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i, 1);
              this$1.state.modeGen++;
              regChange(this$1);
              return
            }
          }
        }),

        indentLine: methodOp(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
            else { dir = dir ? "add" : "subtract"; }
          }
          if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
        }),
        indentSelection: methodOp(function(how) {
          var this$1 = this;

          var ranges = this.doc.sel.ranges, end = -1;
          for (var i = 0; i < ranges.length; i++) {
            var range$$1 = ranges[i];
            if (!range$$1.empty()) {
              var from = range$$1.from(), to = range$$1.to();
              var start = Math.max(end, from.line);
              end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start; j < end; ++j)
                { indentLine(this$1, j, how); }
              var newRanges = this$1.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
            } else if (range$$1.head.line > end) {
              indentLine(this$1, range$$1.head.line, how, true);
              end = range$$1.head.line;
              if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
            }
          }
        }),

        // Fetch the parser token for a given character. Useful for hacks
        // that want to inspect the mode state (say, for completion).
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise)
        },

        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true)
        },

        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
          var type;
          if (ch == 0) { type = styles[2]; }
          else { for (;;) {
            var mid = (before + after) >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
            else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
            else { type = styles[mid * 2 + 2]; break }
          } }
          var cut = type ? type.indexOf("overlay ") : -1;
          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
        },

        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) { return mode }
          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
        },

        getHelper: function(pos, type) {
          return this.getHelpers(pos, type)[0]
        },

        getHelpers: function(pos, type) {
          var this$1 = this;

          var found = [];
          if (!helpers.hasOwnProperty(type)) { return found }
          var help = helpers[type], mode = this.getModeAt(pos);
          if (typeof mode[type] == "string") {
            if (help[mode[type]]) { found.push(help[mode[type]]); }
          } else if (mode[type]) {
            for (var i = 0; i < mode[type].length; i++) {
              var val = help[mode[type][i]];
              if (val) { found.push(val); }
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i$1 = 0; i$1 < help._global.length; i$1++) {
            var cur = help._global[i$1];
            if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
              { found.push(cur.val); }
          }
          return found
        },

        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
          return getContextBefore(this, line + 1, precise).state
        },

        cursorCoords: function(start, mode) {
          var pos, range$$1 = this.doc.sel.primary();
          if (start == null) { pos = range$$1.head; }
          else if (typeof start == "object") { pos = clipPos(this.doc, start); }
          else { pos = start ? range$$1.from() : range$$1.to(); }
          return cursorCoords(this, pos, mode || "page")
        },

        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page")
        },

        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top)
        },

        lineAtHeight: function(height, mode) {
          height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset)
        },
        heightAtLine: function(line, mode, includeWidgets) {
          var end = false, lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first) { line = this.doc.first; }
            else if (line > last) { line = last; end = true; }
            lineObj = getLine(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
            (end ? this.doc.height - heightAtLine(lineObj) : 0)
        },

        defaultTextHeight: function() { return textHeight(this.display) },
        defaultCharWidth: function() { return charWidth(this.display) },

        getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom, left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            // Default to positioning above (if specified and possible); otherwise default to positioning below
            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
              { top = pos.top - node.offsetHeight; }
            else if (pos.bottom + node.offsetHeight <= vspace)
              { top = pos.bottom; }
            if (left + node.offsetWidth > hspace)
              { left = hspace - node.offsetWidth; }
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") { left = 0; }
            else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
            node.style.left = left + "px";
          }
          if (scroll)
            { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
        },

        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        triggerOnMouseDown: methodOp(onMouseDown),

        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd))
            { return commands[cmd].call(null, this) }
        },

        triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

        findPosH: function(from, amount, unit, visually) {
          var this$1 = this;

          var dir = 1;
          if (amount < 0) { dir = -1; amount = -amount; }
          var cur = clipPos(this.doc, from);
          for (var i = 0; i < amount; ++i) {
            cur = findPosH(this$1.doc, cur, dir, unit, visually);
            if (cur.hitSide) { break }
          }
          return cur
        },

        moveH: methodOp(function(dir, unit) {
          var this$1 = this;

          this.extendSelectionsBy(function (range$$1) {
            if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
              { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
            else
              { return dir < 0 ? range$$1.from() : range$$1.to() }
          }, sel_move);
        }),

        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel, doc = this.doc;
          if (sel.somethingSelected())
            { doc.replaceSelection("", null, "+delete"); }
          else
            { deleteNearSelection(this, function (range$$1) {
              var other = findPosH(doc, range$$1.head, dir, unit, false);
              return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
            }); }
        }),

        findPosV: function(from, amount, unit, goalColumn) {
          var this$1 = this;

          var dir = 1, x = goalColumn;
          if (amount < 0) { dir = -1; amount = -amount; }
          var cur = clipPos(this.doc, from);
          for (var i = 0; i < amount; ++i) {
            var coords = cursorCoords(this$1, cur, "div");
            if (x == null) { x = coords.left; }
            else { coords.left = x; }
            cur = findPosV(this$1, coords, dir, unit);
            if (cur.hitSide) { break }
          }
          return cur
        },

        moveV: methodOp(function(dir, unit) {
          var this$1 = this;

          var doc = this.doc, goals = [];
          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function (range$$1) {
            if (collapse)
              { return dir < 0 ? range$$1.from() : range$$1.to() }
            var headPos = cursorCoords(this$1, range$$1.head, "div");
            if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
            goals.push(headPos.left);
            var pos = findPosV(this$1, headPos, dir, unit);
            if (unit == "page" && range$$1 == doc.sel.primary())
              { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
            return pos
          }, sel_move);
          if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
            { doc.sel.ranges[i].goalColumn = goals[i]; } }
        }),

        // Find the word at the given position (as returned by coordsChar).
        findWordAt: function(pos) {
          var doc = this.doc, line = getLine(doc, pos.line).text;
          var start = pos.ch, end = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
            var startChar = line.charAt(start);
            var check = isWordChar(startChar, helper)
              ? function (ch) { return isWordChar(ch, helper); }
              : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
              : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
            while (start > 0 && check(line.charAt(start - 1))) { --start; }
            while (end < line.length && check(line.charAt(end))) { ++end; }
          }
          return new Range(Pos(pos.line, start), Pos(pos.line, end))
        },

        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite) { return }
          if (this.state.overwrite = !this.state.overwrite)
            { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
          else
            { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() { return this.display.input.getField() == activeElt() },
        isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

        scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {left: scroller.scrollLeft, top: scroller.scrollTop,
                  height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                  width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                  clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
        },

        scrollIntoView: methodOp(function(range$$1, margin) {
          if (range$$1 == null) {
            range$$1 = {from: this.doc.sel.primary().head, to: null};
            if (margin == null) { margin = this.options.cursorScrollMargin; }
          } else if (typeof range$$1 == "number") {
            range$$1 = {from: Pos(range$$1, 0), to: null};
          } else if (range$$1.from == null) {
            range$$1 = {from: range$$1, to: null};
          }
          if (!range$$1.to) { range$$1.to = range$$1.from; }
          range$$1.margin = margin || 0;

          if (range$$1.from.line != null) {
            scrollToRange(this, range$$1);
          } else {
            scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
          }
        }),

        setSize: methodOp(function(width, height) {
          var this$1 = this;

          var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
          if (width != null) { this.display.wrapper.style.width = interpret(width); }
          if (height != null) { this.display.wrapper.style.height = interpret(height); }
          if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
          var lineNo$$1 = this.display.viewFrom;
          this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
            if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
              { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
            ++lineNo$$1;
          });
          this.curOp.forceUpdate = true;
          signal(this, "refresh", this);
        }),

        operation: function(f){return runInOp(this, f)},
        startOperation: function(){return startOperation(this)},
        endOperation: function(){return endOperation(this)},

        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
            { estimateLineHeights(this); }
          signal(this, "refresh", this);
        }),

        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          // Cancel the current text selection if any (#5821)
          if (this.state.selectingText) { this.state.selectingText(); }
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old
        }),

        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
        },

        getInputField: function(){return this.display.input.getField()},
        getWrapperElement: function(){return this.display.wrapper},
        getScrollerElement: function(){return this.display.scroller},
        getGutterElement: function(){return this.display.gutters}
      };
      eventMixin(CodeMirror);

      CodeMirror.registerHelper = function(type, name, value) {
        if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
        helpers[type][name] = value;
      };
      CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value);
        helpers[type]._global.push({pred: predicate, val: value});
      };
    }

    // Used for horizontal relative motion. Dir is -1 or 1 (left or
    // right), unit can be "char", "column" (like char, but doesn't
    // cross line boundaries), "word" (across next word), or "group" (to
    // the start of next group of word or non-word-non-whitespace
    // chars). The visually param controls whether, in right-to-left
    // text, direction 1 means to move towards the next index in the
    // string, or towards the character to the right of the current
    // position. The resulting position will have a hitSide=true
    // property if it reached the end of the document.
    function findPosH(doc, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine(doc, pos.line);
      function findNextLine() {
        var l = pos.line + dir;
        if (l < doc.first || l >= doc.first + doc.size) { return false }
        pos = new Pos(l, pos.ch, pos.sticky);
        return lineObj = getLine(doc, l)
      }
      function moveOnce(boundToLine) {
        var next;
        if (visually) {
          next = moveVisually(doc.cm, lineObj, pos, dir);
        } else {
          next = moveLogically(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine())
            { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
          else
            { return false }
        } else {
          pos = next;
        }
        return true
      }

      if (unit == "char") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true;; first = false) {
          if (dir < 0 && !moveOnce(!first)) { break }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type = isWordChar(cur, helper) ? "w"
            : group && cur == "\n" ? "n"
            : !group || /\s/.test(cur) ? null
            : "p";
          if (group && !first && !type) { type = "s"; }
          if (sawType && sawType != type) {
            if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
            break
          }

          if (type) { sawType = type; }
          if (dir > 0 && !moveOnce(!first)) { break }
        }
      }
      var result = skipAtomic(doc, pos, oldPos, origDir, true);
      if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
      return result
    }

    // For relative vertical movement. Dir may be -1 or 1. Unit can be
    // "page" or "line". The resulting position will have a hitSide=true
    // property if it reached the end of the document.
    function findPosV(cm, pos, dir, unit) {
      var doc = cm.doc, x = pos.left, y;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

      } else if (unit == "line") {
        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target;
      for (;;) {
        target = coordsChar(cm, x, y);
        if (!target.outside) { break }
        if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
        y += dir * 5;
      }
      return target
    }

    // CONTENTEDITABLE INPUT STYLE

    var ContentEditableInput = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };

    ContentEditableInput.prototype.init = function (display) {
        var this$1 = this;

      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

      on(div, "paste", function (e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
        // IE doesn't fire input events, so we schedule a read for the pasted content in this way
        if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
      });

      on(div, "compositionstart", function (e) {
        this$1.composing = {data: e.data, done: false};
      });
      on(div, "compositionupdate", function (e) {
        if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
      });
      on(div, "compositionend", function (e) {
        if (this$1.composing) {
          if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
          this$1.composing.done = true;
        }
      });

      on(div, "touchstart", function () { return input.forceCompositionEnd(); });

      on(div, "input", function () {
        if (!this$1.composing) { this$1.readFromDOMSoon(); }
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) { return }
        if (cm.somethingSelected()) {
          setLastCopied({lineWise: false, text: cm.getSelections()});
          if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
        } else if (!cm.options.lineWiseCopyCut) {
          return
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({lineWise: true, text: ranges.text});
          if (e.type == "cut") {
            cm.operation(function () {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          // iOS exposes the clipboard API, but seems to discard content inserted into it
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return
          }
        }
        // Old-fashioned briefly-focus-a-textarea hack
        var kludge = hiddenTextarea(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = document.activeElement;
        selectInput(te);
        setTimeout(function () {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) { input.showPrimarySelection(); }
        }, 50);
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    };

    ContentEditableInput.prototype.prepareSelection = function () {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result
    };

    ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
      if (!info || !this.cm.display.view.length) { return }
      if (info.focus || takeFocus) { this.showPrimarySelection(); }
      this.showMultipleSelections(info);
    };

    ContentEditableInput.prototype.getSelection = function () {
      return this.cm.display.wrapper.ownerDocument.getSelection()
    };

    ContentEditableInput.prototype.showPrimarySelection = function () {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from = prim.from(), to = prim.to();

      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return
      }

      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), from) == 0 &&
          cmp(maxPos(curAnchor, curFocus), to) == 0)
        { return }

      var view = cm.display.view;
      var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
          {node: view[0].measure.map[2], offset: 0};
      var end = to.line < cm.display.viewTo && posToDOM(cm, to);
      if (!end) {
        var measure = view[view.length - 1].measure;
        var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
      }

      if (!start || !end) {
        sel.removeAllRanges();
        return
      }

      var old = sel.rangeCount && sel.getRangeAt(0), rng;
      try { rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) { sel.addRange(old); }
        else if (gecko) { this.startGracePeriod(); }
      }
      this.rememberSelection();
    };

    ContentEditableInput.prototype.startGracePeriod = function () {
        var this$1 = this;

      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function () {
        this$1.gracePeriod = false;
        if (this$1.selectionChanged())
          { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
      }, 20);
    };

    ContentEditableInput.prototype.showMultipleSelections = function (info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    };

    ContentEditableInput.prototype.rememberSelection = function () {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    };

    ContentEditableInput.prototype.selectionInEditor = function () {
      var sel = this.getSelection();
      if (!sel.rangeCount) { return false }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node)
    };

    ContentEditableInput.prototype.focus = function () {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor())
          { this.showSelection(this.prepareSelection(), true); }
        this.div.focus();
      }
    };
    ContentEditableInput.prototype.blur = function () { this.div.blur(); };
    ContentEditableInput.prototype.getField = function () { return this.div };

    ContentEditableInput.prototype.supportsTouch = function () { return true };

    ContentEditableInput.prototype.receivedFocus = function () {
      var input = this;
      if (this.selectionInEditor())
        { this.pollSelection(); }
      else
        { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };

    ContentEditableInput.prototype.selectionChanged = function () {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
    };

    ContentEditableInput.prototype.pollSelection = function () {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
      var sel = this.getSelection(), cm = this.cm;
      // On Android Chrome (version 56, at least), backspacing into an
      // uneditable block element will put the cursor in that element,
      // and then, because it's not editable, hide the virtual keyboard.
      // Because Android doesn't allow us to actually detect backspace
      // presses in a sane way, this code checks for when that happens
      // and simulates a backspace press in this case.
      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
        this.blur();
        this.focus();
        return
      }
      if (this.composing) { return }
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) { runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
      }); }
    };

    ContentEditableInput.prototype.pollContent = function () {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }

      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine())
        { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
        { to = Pos(to.line + 1, 0); }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }

      if (!fromNode) { return false }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else { break }
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        { ++cutFront; }
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        { ++cutEnd; }
      // Try to move start of change to start of selection if ambiguous
      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch &&
               newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true
      }
    };

    ContentEditableInput.prototype.ensurePolled = function () {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function () {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function () {
      if (!this.composing) { return }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function () {
        var this$1 = this;

      if (this.readDOMTimeout != null) { return }
      this.readDOMTimeout = setTimeout(function () {
        this$1.readDOMTimeout = null;
        if (this$1.composing) {
          if (this$1.composing.done) { this$1.composing = null; }
          else { return }
        }
        this$1.updateFromDOM();
      }, 80);
    };

    ContentEditableInput.prototype.updateFromDOM = function () {
        var this$1 = this;

      if (this.cm.isReadOnly() || !this.pollContent())
        { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
    };

    ContentEditableInput.prototype.setUneditable = function (node) {
      node.contentEditable = "false";
    };

    ContentEditableInput.prototype.onKeyPress = function (e) {
      if (e.charCode == 0 || this.composing) { return }
      e.preventDefault();
      if (!this.cm.isReadOnly())
        { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
    };

    ContentEditableInput.prototype.readOnlyChanged = function (val) {
      this.div.contentEditable = String(val != "nocursor");
    };

    ContentEditableInput.prototype.onContextMenu = function () {};
    ContentEditableInput.prototype.resetPosition = function () {};

    ContentEditableInput.prototype.needsContentAttribute = true;

    function posToDOM(cm, pos) {
      var view = findViewForLine(cm, pos.line);
      if (!view || view.hidden) { return null }
      var line = getLine(cm.doc, pos.line);
      var info = mapFromLineView(view, line, pos.line);

      var order = getOrder(line, cm.doc.direction), side = "left";
      if (order) {
        var partPos = getBidiPartAt(order, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
      result.offset = result.collapse == "right" ? result.end : result.start;
      return result
    }

    function isInGutter(node) {
      for (var scan = node; scan; scan = scan.parentNode)
        { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
      return false
    }

    function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

    function domTextBetween(cm, from, to, fromLine, toLine) {
      var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
      function close() {
        if (closing) {
          text += lineSep;
          if (extraLinebreak) { text += lineSep; }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close();
          text += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return
          }
          var markerID = node.getAttribute("cm-marker"), range$$1;
          if (markerID) {
            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range$$1 = found[0].find(0)))
              { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
            return
          }
          if (node.getAttribute("contenteditable") == "false") { return }
          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

          if (isBlock) { close(); }
          for (var i = 0; i < node.childNodes.length; i++)
            { walk(node.childNodes[i]); }

          if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
          if (isBlock) { closing = true; }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (;;) {
        walk(from);
        if (from == to) { break }
        from = from.nextSibling;
        extraLinebreak = false;
      }
      return text
    }

    function domToPos(cm, node, offset) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset];
        if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
        node = null; offset = 0;
      } else {
        for (lineNode = node;; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) { return null }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
        }
      }
      for (var i = 0; i < cm.display.view.length; i++) {
        var lineView = cm.display.view[i];
        if (lineView.node == lineNode)
          { return locateNodeInLineView(lineView, node, offset) }
      }
    }

    function locateNodeInLineView(lineView, node, offset) {
      var wrapper = lineView.text.firstChild, bad = false;
      if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
      if (node == wrapper) {
        bad = true;
        node = wrapper.childNodes[offset];
        offset = 0;
        if (!node) {
          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
          return badPos(Pos(lineNo(line), line.text.length), bad)
        }
      }

      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset) { offset = textNode.nodeValue.length; }
      }
      while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
      var measure = lineView.measure, maps = measure.maps;

      function find(textNode, topNode, offset) {
        for (var i = -1; i < (maps ? maps.length : 0); i++) {
          var map$$1 = i < 0 ? measure.map : maps[i];
          for (var j = 0; j < map$$1.length; j += 3) {
            var curNode = map$$1[j + 2];
            if (curNode == textNode || curNode == topNode) {
              var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
              var ch = map$$1[j] + offset;
              if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
              return Pos(line, ch)
            }
          }
        }
      }
      var found = find(textNode, topNode, offset);
      if (found) { return badPos(found, bad) }

      // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
        found = find(after, after.firstChild, 0);
        if (found)
          { return badPos(Pos(found.line, found.ch - dist), bad) }
        else
          { dist += after.textContent.length; }
      }
      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
        found = find(before, before.firstChild, -1);
        if (found)
          { return badPos(Pos(found.line, found.ch + dist$1), bad) }
        else
          { dist$1 += before.textContent.length; }
      }
    }

    // TEXTAREA INPUT STYLE

    var TextareaInput = function(cm) {
      this.cm = cm;
      // See input.poll and input.reset
      this.prevInput = "";

      // Flag that indicates whether we expect input to appear real soon
      // now (after some event like 'keypress' or 'input') and are
      // polling intensively.
      this.pollingFast = false;
      // Self-resetting timeout for the poller
      this.polling = new Delayed();
      // Used to work around IE issue with selection being forgotten when focus moves away from textarea
      this.hasSelection = false;
      this.composing = null;
    };

    TextareaInput.prototype.init = function (display) {
        var this$1 = this;

      var input = this, cm = this.cm;
      this.createField(display);
      var te = this.textarea;

      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) { te.style.width = "0px"; }

      on(te, "input", function () {
        if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
        input.poll();
      });

      on(te, "paste", function (e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

        cm.state.pasteIncoming = +new Date;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) { return }
        if (cm.somethingSelected()) {
          setLastCopied({lineWise: false, text: cm.getSelections()});
        } else if (!cm.options.lineWiseCopyCut) {
          return
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({lineWise: true, text: ranges.text});
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function (e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
        if (!te.dispatchEvent) {
          cm.state.pasteIncoming = +new Date;
          input.focus();
          return
        }

        // Pass the `paste` event to the textarea so it's handled by its event listener.
        var event = new Event("paste");
        event.clipboardData = e.clipboardData;
        te.dispatchEvent(event);
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function (e) {
        if (!eventInWidget(display, e)) { e_preventDefault(e); }
      });

      on(te, "compositionstart", function () {
        var start = cm.getCursor("from");
        if (input.composing) { input.composing.range.clear(); }
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function () {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    };

    TextareaInput.prototype.createField = function (_display) {
      // Wraps and hides input textarea
      this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      this.textarea = this.wrapper.firstChild;
    };

    TextareaInput.prototype.prepareSelection = function () {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result
    };

    TextareaInput.prototype.showSelection = function (drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    TextareaInput.prototype.reset = function (typing) {
      if (this.contextMenuPending || this.composing) { return }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) { selectInput(this.textarea); }
        if (ie && ie_version >= 9) { this.hasSelection = content; }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) { this.hasSelection = null; }
      }
    };

    TextareaInput.prototype.getField = function () { return this.textarea };

    TextareaInput.prototype.supportsTouch = function () { return false };

    TextareaInput.prototype.focus = function () {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    };

    TextareaInput.prototype.blur = function () { this.textarea.blur(); };

    TextareaInput.prototype.resetPosition = function () {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };

    TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    TextareaInput.prototype.slowPoll = function () {
        var this$1 = this;

      if (this.pollingFast) { return }
      this.polling.set(this.cm.options.pollInterval, function () {
        this$1.poll();
        if (this$1.cm.state.focused) { this$1.slowPoll(); }
      });
    };

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    TextareaInput.prototype.fastPoll = function () {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    };

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    TextareaInput.prototype.poll = function () {
        var this$1 = this;

      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput && !this.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        { return false }

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) { return false }
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

      runInOp(cm, function () {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, this$1.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
        else { this$1.prevInput = text; }

        if (this$1.composing) {
          this$1.composing.range.clear();
          this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true
    };

    TextareaInput.prototype.ensurePolled = function () {
      if (this.pollingFast && this.poll()) { this.pollingFast = false; }
    };

    TextareaInput.prototype.onKeyPress = function () {
      if (ie && ie_version >= 9) { this.hasSelection = null; }
      this.fastPoll();
    };

    TextareaInput.prototype.onContextMenu = function (e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      if (input.contextMenuPending) { input.contextMenuPending(); }
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) { return } // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
      input.wrapper.style.cssText = "position: static";
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) { window.scrollTo(null, oldScrollY); }
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
      input.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input.contextMenuPending != rehide) { return }
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
          var i = 0, poll = function () {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b") {
              operation(cm, selectAll)(cm);
            } else if (i++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) { prepareSelectAllHack(); }
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function () {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };

    TextareaInput.prototype.readOnlyChanged = function (val) {
      if (!val) { this.reset(); }
      this.textarea.disabled = val == "nocursor";
    };

    TextareaInput.prototype.setUneditable = function () {};

    TextareaInput.prototype.needsContentAttribute = false;

    function fromTextArea(textarea, options) {
      options = options ? copyObj(options) : {};
      options.value = textarea.value;
      if (!options.tabindex && textarea.tabIndex)
        { options.tabindex = textarea.tabIndex; }
      if (!options.placeholder && textarea.placeholder)
        { options.placeholder = textarea.placeholder; }
      // Set autofocus to true if this textarea is focused, or if it has
      // autofocus and no other element is focused.
      if (options.autofocus == null) {
        var hasFocus = activeElt();
        options.autofocus = hasFocus == textarea ||
          textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }

      function save() {textarea.value = cm.getValue();}

      var realSubmit;
      if (textarea.form) {
        on(textarea.form, "submit", save);
        // Deplorable hack to make the submit method do the right thing.
        if (!options.leaveSubmitMethodAlone) {
          var form = textarea.form;
          realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch(e) {}
        }
      }

      options.finishInit = function (cm) {
        cm.save = save;
        cm.getTextArea = function () { return textarea; };
        cm.toTextArea = function () {
          cm.toTextArea = isNaN; // Prevent this from being ran twice
          save();
          textarea.parentNode.removeChild(cm.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off(textarea.form, "submit", save);
            if (typeof textarea.form.submit == "function")
              { textarea.form.submit = realSubmit; }
          }
        };
      };

      textarea.style.display = "none";
      var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
        options);
      return cm
    }

    function addLegacyProps(CodeMirror) {
      CodeMirror.off = off;
      CodeMirror.on = on;
      CodeMirror.wheelEventPixels = wheelEventPixels;
      CodeMirror.Doc = Doc;
      CodeMirror.splitLines = splitLinesAuto;
      CodeMirror.countColumn = countColumn;
      CodeMirror.findColumn = findColumn;
      CodeMirror.isWordChar = isWordCharBasic;
      CodeMirror.Pass = Pass;
      CodeMirror.signal = signal;
      CodeMirror.Line = Line;
      CodeMirror.changeEnd = changeEnd;
      CodeMirror.scrollbarModel = scrollbarModel;
      CodeMirror.Pos = Pos;
      CodeMirror.cmpPos = cmp;
      CodeMirror.modes = modes;
      CodeMirror.mimeModes = mimeModes;
      CodeMirror.resolveMode = resolveMode;
      CodeMirror.getMode = getMode;
      CodeMirror.modeExtensions = modeExtensions;
      CodeMirror.extendMode = extendMode;
      CodeMirror.copyState = copyState;
      CodeMirror.startState = startState;
      CodeMirror.innerMode = innerMode;
      CodeMirror.commands = commands;
      CodeMirror.keyMap = keyMap;
      CodeMirror.keyName = keyName;
      CodeMirror.isModifierKey = isModifierKey;
      CodeMirror.lookupKey = lookupKey;
      CodeMirror.normalizeKeyMap = normalizeKeyMap;
      CodeMirror.StringStream = StringStream;
      CodeMirror.SharedTextMarker = SharedTextMarker;
      CodeMirror.TextMarker = TextMarker;
      CodeMirror.LineWidget = LineWidget;
      CodeMirror.e_preventDefault = e_preventDefault;
      CodeMirror.e_stopPropagation = e_stopPropagation;
      CodeMirror.e_stop = e_stop;
      CodeMirror.addClass = addClass;
      CodeMirror.contains = contains;
      CodeMirror.rmClass = rmClass;
      CodeMirror.keyNames = keyNames;
    }

    // EDITOR CONSTRUCTOR

    defineOptions(CodeMirror);

    addEditorMethods(CodeMirror);

    // Set up methods on CodeMirror's prototype to redirect to the editor's document.
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      { CodeMirror.prototype[prop] = (function(method) {
        return function() {return method.apply(this.doc, arguments)}
      })(Doc.prototype[prop]); } }

    eventMixin(Doc);
    CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

    // Extra arguments are stored as the mode's dependencies, which is
    // used by (legacy) mechanisms like loadmode.js to automatically
    // load a mode. (Preferred mechanism is the require/define calls.)
    CodeMirror.defineMode = function(name/*, mode, …*/) {
      if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
      defineMode.apply(this, arguments);
    };

    CodeMirror.defineMIME = defineMIME;

    // Minimal default mode.
    CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
    CodeMirror.defineMIME("text/plain", "null");

    // EXTENSIONS

    CodeMirror.defineExtension = function (name, func) {
      CodeMirror.prototype[name] = func;
    };
    CodeMirror.defineDocExtension = function (name, func) {
      Doc.prototype[name] = func;
    };

    CodeMirror.fromTextArea = fromTextArea;

    addLegacyProps(CodeMirror);

    CodeMirror.version = "5.48.4";

    return CodeMirror;

  })));
  });

  //
   var script$g = {
       name: 'cat-jsavr',
       props: ['root','program','text','control','size','lightboard_feature','reset_feature','simid','debug_mode_feature'],
       data () {
  	 return {
  	     id: '',
  	     rendered: '',
  	     debug_log: this.do_nothing,
  	     status: "Ready",
  	     running: false,
  	     outputs: [],
  	     io_state: {'switch_state':["OFF","OFF","OFF","OFF","OFF","OFF","OFF","OFF"]},
  	     steps: {'count':1},
  	     output_type: {"selection":"program"},
  	     symbols: {},
  	     PM_display_mode: "t",
  	     RAM_display_mode: "d",
  	     RF_display_mode: "d",
  	     RAM: [],
  	     PM: [],
  	     RF: [],
  	     
  	     PIND: 0,
  	     PORTD: 0,
  	     DDRD: 0,
  	     SPH: 0,
  	     SPL: 0,
  	     
  	     RAM_size: 65536,
  	     PM_size: 65536,
  	     RF_size: 32,
  	     updated: [],
  	     error_line: 0,
  	     current_ram_data: [],
  	     display_pm_start: 0,
  	     display_ram_start: 0,
  	     display_pm_length: 16,
  	     display_ram_length: 16,
  	     directives: {
  		 "label":{"regex":/^([a-zA-Z_][a-zA-Z0-9_]*):$/,"process":function(args){
  		     return {"symbol":args[1],
  			     "symbol_type":"pm",
  		     };
  		 }},
  		 "word":{"regex":/^\.word ([0-9,]+)$/,"process":function(args){
  		     var rdata = args[1].split(",");
  		     for(var i = 0; i < rdata.length; i++){
  			 rdata[i] = this.truncate(parseInt(rdata[i]),16,false);
  		     }
  		     return {"symbol":args[1],
  			     "symbol_type":"pm",
  			     "pm_data":rdata
  		     };
  		 }},
  		 "byte_ram":{"regex":/^ *\.byte\(([a-zA-Z_][a-zA-Z0-9_]*)\) ([-0-9, ]+) *$/,"process":function(args){
  		     var rdata = args[2].split(",");
  		     for(var i = 0; i < rdata.length; i++){
  			 rdata[i] = this.truncate(parseInt(rdata[i].trim()),8,false);
  		     }
  		     return {"symbol":args[1],
  			     "symbol_type":"ram",
  			     "ram_data":rdata
  		     };
  		 }},
  		 "string_ram":{"regex":/^ *\.string\(([a-zA-Z_][a-zA-Z0-9_]*)\) "((?:[^"\\]|\\.)*)" *$/,"process":function(args){
  		     var str = this.handle_string_escapes(args[2]);
  		     var rdata = [];
  		     for(var i = 0; i < str.length; i++){
  			 rdata.push(this.truncate(str.charCodeAt(i),8,false));
  		     }
  		     rdata.push(0);
  		     return {"symbol":args[1],
  			     "symbol_type":"ram",
  			     "ram_data":rdata
  		     };
  		     
  		 }}
  	     },
  	     formats: {
  		 "4r8i":{
  		     "string":/ *r([0-9]+), *()(-?[a-zA-Z_0-9)(-]+|'..?') *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " r" + r + ","+i;},
  		     "binary":"CCCCIIIIRRRRIIII",
  		     "i_bits":8,
  		     "validator":function(c, r, s, i){return 16 <= r && r < 32 && -128 <= i && i < 256;}},
  		 "5r5s":{
  		     "string":/ *r([0-9]+), *r([0-9]+)() *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " r" + r + ",r"+s;},
  		     "binary":"CCCCCCSRRRRRSSSS",
  		     "validator":function(c, r, s, i){return 0 <= r && r < 32 && 0 <= s && s < 32;}},
  		 "6s5r":{
  		     "string":/ *r([0-9]+), *([0-9]+)() *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " r" + r + ","+s;},
  		     "binary":"CCCCCSSRRRRRSSSS",
  		     "validator":function(c, r, s, i){return 0 <= r && r < 32 && 0 <= s && s < 64;}},
  		 "5r6s":{
  		     "string":/ *([0-9]+), *r([0-9]+)() *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " " + r + ",r"+s;},
  		     "binary":"CCCCCSSRRRRRSSSS",
  		     "validator":function(c, r, s, i){return 0 <= r && r < 64 && 0 <= s && s < 32;}},
  		 "5r":{
  		     "string":/ *r([0-9]+)()() *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " r" + r;},
  		     "binary":"CCCCCCCRRRRRCCCC",
  		     "validator":function(c, r, s, i){return 0 <= r && r < 32;}},
  		 "5rX":{
  		     "string":/ *r([0-9]+)(), *(-[XYZ]|[XYZ]|[XYZ]\+) *$/,
  		     "to_string":function(mnemonic,c,r,s,i,x){return mnemonic + " r" + r + ","+i},
  		     "binary":"CCCXCCCRRRRRXXXX",
  		     "validator":function(c, r, s, i){return 0 <= r && r < 32;}},
  		 "X5r":{
  		     "string":/ *(-[XYZ]|[XYZ]|[XYZ]\+), *r([0-9]+)() *$/,
  		     "to_string":function(mnemonic,c,r,s,i,x){return mnemonic + " " + r + ",r"+s;},
  		     "binary":"CCCXCCCRRRRRXXXX",
  		     "validator":function(c, r, s, i){return 0 <= s && s < 32;}},
  		 "12i":{
  		     "string":/ *()()(-?[a-zA-Z_0-9)(]+) *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " " + i;},
  		     "binary":"CCCCIIIIIIIIIIII",
  		     "i_bits":12,
  		     "validator":function(c, r, s, i){return -2048 <= i && i < 2048;}},
  		 "7i":{
  		     "string":/ *()()(-?[a-zA-Z_0-9)(]+) *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic + " " + i;},
  		     "binary":"CCCCCCIIIIIIICCC",
  		     "i_bits":7,
  		     "validator":function(c, r, s, i){return -64 <= i && i < 64;}},
  		 "n":{
  		     "string":/ *()()() *$/,
  		     "to_string":function(mnemonic,c,r,s,i){return mnemonic;},
  		     "binary":"CCCCCCCCCCCCCCCC",
  		     "validator":function(c, r, s, i){return true;}}
  	     },
  	     instructions: {
  		 "ldi":{"format":"4r8i", "c": 14, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     console.log('T',emu);
  		     emu.RF[r] = emu.truncate(i,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "mov":{"format":"5r5s", "c": 11, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.RF[r] = emu.RF[s];
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "add":{"format":"5r5s", "c": 3, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] + emu.RF[s], true, true, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] + emu.RF[s],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "adc":{"format":"5r5s", "c": 7, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     var oldC = emu.C;
  		     emu.update_sreg(emu.RF[r] + emu.RF[s] + oldC, true, true, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] + emu.RF[s] + oldC,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "sbc":{"format":"5r5s", "c": 2, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     var oldC = emu.C;
  		     emu.update_sreg(emu.RF[r] - emu.RF[s] - oldC, true, true, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] - emu.RF[s] - oldC,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "sub":{"format":"5r5s", "c": 6, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] - emu.RF[s], true, true, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] - emu.RF[s],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "cp":{"format":"5r5s", "c": 5, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] - emu.RF[s], true, true, true);
  		     emu.C = emu.truncate(emu.RF[r],8,true) < emu.truncate(emu.RF[s],8,true) ? 1 : 0; // HACK TO MATCH PRESENTATION
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC", "Z", "C", "N"];}},
  		 "and":{"format":"5r5s", "c": 8, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] & emu.RF[s], true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] & emu.RF[s],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "or":{"format":"5r5s", "c": 10, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] | emu.RF[s], true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] | emu.RF[s],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "eor":{"format":"5r5s", "c": 9, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] ^ emu.RF[s], true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] ^ emu.RF[s],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r, "PC", "Z", "C", "N"];}},
  		 "cpi":{"format":"4r8i", "c": 3, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] - i, true, true, true);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","Z","C","N"];}},
  		 "subi":{"format":"4r8i", "c": 5, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] - i, true, true, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] - i,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","Z","C","N"];}},
  		 "andi":{"format":"4r8i", "c": 7, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] & i, true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] & i,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","Z","C","N"];}},
  		 "ori":{"format":"4r8i", "c": 6, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] | i, true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] | i,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","Z","C","N"];}},
  		 "dec":{"format":"5r", "c": 1194, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] - 1, true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] - 1,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "inc":{"format":"5r", "c": 1187, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(emu.RF[r] + 1, true, false, true);
  		     emu.RF[r] = emu.truncate(emu.RF[r] + 1,8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "neg":{"format":"5r", "c": 1185, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(-emu.RF[r], true, true, true);
  		     emu.RF[r] = emu.truncate(-emu.RF[r],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "com":{"format":"5r", "c": 1184, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.update_sreg(~(emu.RF[r]), true, false, true);
  		     emu.RF[r] = emu.truncate(~(emu.RF[r]),8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "ld":{"format":"5rX", "c": 32, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     var reg = 0;
  		     if(i == "X" || i == "-X" || i == "X+") reg = 26;
  		     if(i == "Y" || i == "-Y" || i == "Y+") reg = 28;
  		     if(i == "Z" || i == "-Z" || i == "Z+") reg = 30;
  		     if(i[0] == "-"){
  			 emu.updated.push(reg);
  			 emu.dec_ptr(reg);
  		     }
  		     var ptr = emu.truncate(emu.RF[reg],8,false)+256*emu.truncate(emu.RF[reg+1],8,false);
  		     emu.updated = [r,"PC"];
  		     emu.RF[r] = emu.truncate(emu.RAM[ptr],8,false);
  		     if(i[1] == "+"){
  			 emu.updated.push(reg);
  			 emu.inc_ptr(reg);
  		     }
  		     emu.ram_updated = [];
  		     emu.PC++;}},
  		 "st":{"format":"X5r", "c": 33, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     i = r;
  		     r = s;
  		     var reg = 0;
  		     if(i == "X" || i == "-X" || i == "X+") reg = 26;
  		     if(i == "Y" || i == "-Y" || i == "Y+") reg = 28;
  		     if(i == "Z" || i == "-Z" || i == "Z+") reg = 30;
  		     if(i[0] == "-"){
  			 emu.updated.push(reg);
  			 emu.dec_ptr(reg);
  		     }
  		     var ptr = emu.truncate(emu.RF[reg],8,false)+256*emu.truncate(emu.RF[reg+1],8,false);
  		     emu.updated = ["PC"];
  		     emu.ram_updated = [ptr];
  		     emu.RAM[ptr] = emu.RF[r];
  		     emu.PC++;
  		     if(i[1] == "+"){
  			 emu.updated.push(reg);
  			 emu.inc_ptr(reg);
  		     }
  		 }},
  		 "rjmp":{"format":"12i", "c": 12, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC = emu.truncate(emu.PC + i + 1,16,false);
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "breq":{"format":"7i", "c": 481, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC = emu.truncate(emu.PC + 1 + (emu.Z == 1 ? (i <= 64 ? i : i-128) : 0),16,false);
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "brne":{"format":"7i", "c": 489, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC = emu.truncate(emu.PC + 1 + (emu.Z == 0 ? (i <= 64 ? i : i-128) : 0),16,false);
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "brsh":{"format":"7i", "c": 488, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC = emu.truncate(emu.PC + 1 + (emu.C == 0 ? (i <= 64 ? i : i-128) : 0),16,false);
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "brlo":{"format":"7i", "c": 480, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC = emu.truncate(emu.PC + 1 + (emu.C == 1 ? (i <= 64 ? i : i-128) : 0),16,false);
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "in":{"format":"6s5r", "c": 22, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.RF[r] = emu.truncate(emu.read_IO(s),8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "out":{"format":"5r6s", "c": 23, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     i = s;
  		     s = r;
  		     r = i;
  		     emu.write_IO(s,emu.RF[r]);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "asr":{"format":"5r", "c": 1189, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     var C = emu.RF[r]%2 == 0 ? 0 : 1;
  		     emu.RF[r] = emu.truncate(emu.truncate(emu.RF[r],8,true) >> 1,8,false);
  		     emu.update_sreg(emu.RF[r], true, false, true);
  		     emu.C = C;
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = [r,"PC"];}},
  		 "push":{"format":"5r", "c": 1183, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     emu.RAM[SP] = emu.RF[r];
  		     emu.decSP();
  		     emu.PC++;
  		     emu.updated = ["PC","SPH","SPL"];
  		     emu.ram_updated = [SP];}},
  		 "pop":{"format":"5r", "c": 1167, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.incSP();
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     emu.RF[r] = emu.truncate(emu.RAM[SP],8,false);
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","SPH","SPL"];}},
  		 "rcall":{"format":"12i", "c": 13, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC++;
  		     var PCL = emu.PC % 256;
  		     var PCH = Math.floor(emu.PC / 256);
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     emu.RAM[SP] = PCH;
  		     emu.decSP();
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     emu.RAM[SP] = PCL;
  		     emu.decSP();
  		     emu.PC = emu.truncate(emu.PC + i,16,false);
  		     emu.updated = ["PC","SPH","SPL"];
  		     emu.ram_updated = [SP];}},
  		 "ret":{"format":"n", "c": 38152, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.incSP();
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     var PCL = emu.RAM[SP];
  		     emu.incSP();
  		     var SP = emu.SPH * 256 + emu.SPL;
  		     var PCH = emu.RAM[SP];
  		     emu.PC = PCL + 256*PCH;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC","SPH","SPL"];}},
  		 "nop":{"format":"n", "c": 0, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.PC++;
  		     emu.ram_updated = [];
  		     emu.updated = ["PC"];}},
  		 "halt":{"format":"n", "c": 1, "exec":function(c, r, s, i){
  		     var emu = this.parent;
  		     emu.end();}}
  	     }
  	 }
       },
       methods: {
  	 smul: function(str, num) {
  	     var acc = [];
  	     for (var i = 0; (1 << i) <= num; i++) {
  		 if ((1 << i) & num)
  		     acc.push(str);
  		 str += str;
  	     }
  	     return acc.join("");
  	 },
  	 do_nothing: function(a){},
  	 cm_setup: function(){
  	     var sim_textarea = document.getElementById("simavr"+this.simid+"_program_area");
  	     this.debug_log(this.simid,sim_textarea);
  	     if(sim_textarea == null) return;
  	     this.editor = codemirror.fromTextArea(sim_textarea, {
  		 lineNumbers: true,
  		 gutters: ["breakpoints", "CodeMirror-linenumbers"]
  	     });
  	     if(this.size){
  		 if(this.size == "auto"){
  		     this.editor.setSize(null, (this.program.split("\n").length + 2)*(this.editor.defaultTextHeight()) + 10);
  		 }
  		 else{
  		     this.editor.setSize(null, this.size);
  		 }
  	     }
  	     else{
  		 this.editor.setSize(null, "70%");
  	     }
  	     this.editor.setOption("extraKeys", {
  		 'Ctrl-Enter': function(cm) {
                       this.program_pm();
                       this.$apply();
  		 }
  	     });
  	     this.editor.setValue(this.program);
  	 },
  	 reset_program: function(){
  	     if(this.running) return;
  	     if(this.text){
  		 this.debug_log("Using text");
  		 this.program = this.text;
  	     }
  	     else if(this.original_program){
  		 this.program = this.original_program;
  	     }
  	     this.change_program(this.program);
  	 },
  	 reset: function(pm_reset){
  	     this.io_state.switch_state = ["OFF","OFF","OFF","OFF","OFF","OFF","OFF","OFF"];
  	     this.output_type.selection = "program";
  	     this.display_pm_start = 0;
  	     this.display_ram_start = 0;
  	     this.steps = {'count':1};
  	     this.PC = 0;
  	     this.Z = 0;
  	     this.C = 0;
  	     this.N = 0;
  	     this.PIND = 0;
  	     this.PORTD = 0;
  	     this.DDRD = 0;
  	     this.SPH = 0;
  	     this.SPL = 0;
  	     this.updated = [];
  	     this.ram_updated = [];
  	     this.outputs = [];
  	     this.mux = new this.output_mux();
  	     for(var i = 0; i < this.RF_size; i++) this.RF[i] = 0;
  	     for(var i = 0; i < this.RAM_size; i++) this.RAM[i] = 0;
  	     for(var i = 0; i < this.IORF_size; i++) this.IORF[i] = 0;
  	     var nop = this.parse("nop",0);
  	     if(pm_reset){ for(var i = 0; i < this.PM_size; i++){ nop.addr = i; this.PM[i] = nop; }}
  	     if(!pm_reset){ for(var i = 0; i < this.current_ram_data.length; i++) this.RAM[i+1024] = this.current_ram_data[i]; }
  	     if(this.editor) this.editor.removeLineClass(this.error_line, "background", "active_line");
  	 },
  	 change_program: function(prog){
  	     this.program = prog;
  	     if(this.editor) this.editor.setValue(prog);
  	 },
  	 display_ram: function(i){
  	     if(this.RAM_display_mode == "d"){
  		 return this.RAM[i];
  	     }
  	     else if(this.RAM_display_mode == "2"){
  		 return this.truncate(this.RAM[i],8,true);
  	     }
  	     else if(this.RAM_display_mode == "c"){
  		 return String.fromCharCode(this.RAM[i])
  	     }
  	 },
  	 display_rf: function(i){
  	     if(this.RF_display_mode == "d"){
  		 return this.truncate(this.RF[i],8,false);
  	     }
  	     if(this.RF_display_mode == "2"){
  		 return this.truncate(this.RF[i],8,true);
  	     }
  	     else if(this.RF_display_mode == "b"){
  		 var s = this.RF[i].toString(2);
  		 return smul("0",8-s.length)+s;
  	     }
  	     else if(this.RF_display_mode == "h"){
  		 var s = this.RF[i].toString(16);
  		 return "0x"+smul("0",2-s.length)+s;
  	     }
  	 },
  	 program_pm: function(){
  	     if(this.running) return;
  	     this.reset(true);
  	     this.running = true;
  	     this.program = this.editor.getValue();
  	     var pm_data = this.preparse(this.program);
  	     if(!pm_data){
  		 this.running = false;
  		 return;
  	     }
  	     var pm_addr = 0;
  	     for(var i = 0; i < pm_data.length; i++){
  		 var datum = pm_data[i];
  		 if(datum.inst){
  		     var inst = this.parse(datum.inst,pm_addr);
  		     if(!inst) continue;
  		     if(inst.error){
  			 this.error_on_line(datum.line, inst.error);
  			 return;
  		     }
  		     this.PM[pm_addr] = inst;
  		     pm_addr++;
  		 }
  		 else if(datum.word){
  		     var inst = this.decode(datum.word,pm_addr);
  		     if(inst.error){
  			 this.error_on_line(datum.line, inst.error);
  			 return;
  		     }
  		     this.PM[pm_addr] = inst;
  		     pm_addr++;
  		 }
  	     }
  	     this.status = "Ready";
  	 },
  	 error_on_line: function(linenum, err_msg){
  	     this.running = false;
  	     this.status = "Error on line " + linenum + ": " + err_msg;
  	     this.error_line = linenum;
  	     if(this.editor) this.editor.addLineClass(linenum, "background", "active_line");
  	 },
  	 preparse: function(){
  	     var lines = this.program.split("\n");
  	     var to_program = [];
  	     var pm_offset = 0;
  	     var ram_offset = 1024;
  	     for(var i = 0; i < lines.length; i++){
  		 var pieces = lines[i].match(/^((?:[^";]|';'|"(?:[^\\"]+|\\(?:\\\\)*[nt\\"])*")*)(;.*)?$/);
  		 this.debug_log("P",pieces);
  		 if(!pieces){
  		     this.error_on_line(i, "Invalid line: "+i);
  		     return;
  		 }
  		 if(!pieces[1]) continue;
  		 lines[i] = pieces[1].trim();
  		 var is_inst = true;
  		 for(var d in this.directives){
  		     var matches = lines[i].match(this.directives[d].regex);
  		     this.debug_log("D",lines[i],d,matches);
  		     if(matches){
  			 // process needs to return:
  			 // - What it inserts to PM (pm_data)
  			 // - What it inserts into RAM (ram_data)
  			 // - What symbol it wants to make (symbol)
  			 // - What kind of symbol it is (symbol_type == "pm" | "ram")
  			 // - Whether there was an error (error)
  			 
  			 var result = this.directives[d].process(matches);

  			 // Handle error
  			 if(result.error){
  			     this.error_on_line(i, result.error);
  			     return;
  			 }

  			 // Update symbol
  			 if(result.symbol && result.symbol_type){
  			     if(result.symbol_type == "pm"){
  				 this.symbols[result.symbol] = pm_offset;
  			     }
  			     else if(result.symbol_type == "ram"){
  				 this.symbols[result.symbol] = ram_offset;
  			     }
  			 }
  			 
  			 // Insert data and update offsets
  			 if(result.pm_data){
  			     for(var j = 0; j < result.pm_data.length; j++){
  				 to_program.push({'word':result.pm_data[j],'line':i});
  			     }
  			     pm_offset += result.pm_data.length;
  			 }
  			 if(result.ram_data){
  			     for(var j = 0; j < result.ram_data.length; j++){
  				 this.RAM[ram_offset + j] = result.ram_data[j];
  			     }
  			     this.current_ram_data = this.current_ram_data.concat(result.ram_data);
  			     ram_offset += result.ram_data.length;
  			 }
  			 is_inst = false;
  			 break;
  		     }
  		 }
  		 if(is_inst && !(/^[ \t]*$/.test(lines[i]))){
  		     to_program.push({'inst':lines[i],'line':i});
  		     pm_offset++;
  		 }
  	     }
  	     return to_program;
  	 },
  	 parse: function(inst,addr){
  	     this.debug_log(inst);
  	     var matches = inst.match(/^[ \t]*([a-zA-Z]+)[ \t]*((?:[^;]|';')*)[ \t]*$/);
  	     if(!matches){
  		 return {"error":"Line does not match any directive or instruction"};
  	     }
  	     var mnemonic = matches[1];
  	     var operand = matches[2];
  	     this.debug_log(mnemonic, "|||", operand);
  	     if(mnemonic in this.instructions){
  		 var format = this.instructions[mnemonic].format;
  		 var execf = this.instructions[mnemonic].exec;
  		 var ops = operand.match(this.formats[format].string);
  		 if(!ops){
  		     return {"error":"Operands to instruction " + inst + " did not parse"};
  		 }
  		 for(var i = 0; i < 3; i++){
  		     if(/^[0-9]+$/.test(ops[i])) ops[i] = parseInt(ops[i]);
  		     //else if(format.sym_valid[i]) ops[i] = symbols[ops[i]];
  		 }
  		 var opcode = this.instructions[mnemonic].c;
  		 this.debug_log(format, execf, ops, opcode);
  		 var data = {"r":ops[1],"s":ops[2],"i":ops[3],"c":opcode};
  		 var new_inst = new this.instruction(mnemonic + " " + operand, mnemonic, data, execf,addr, this);
  		 if(new_inst.error){
  		     return {"error":inst.error};
  		 }
  		 if(new_inst.check_valid()){
  		     return new_inst;
  		 }
  		 else{
  		     return {"error":"Illegal operands to instruction " + inst};
  		 }
  	     }
  	     else{
  		 return {"error":"Invalid instruction " + inst};
  	     }
  	 },
  	 is_updated: function(x){
  	     for(var i = 0; i < this.updated.length; i++){
  		 if(this.updated[i] == x) return true;
  	     }
  	     return false;
  	 },
  	 is_ram_updated: function(x){
  	     for(var i = 0; i < this.updated.length; i++){
  		 if(this.ram_updated[i] == x) return true;
  	     }
  	     return false;
  	 },
  	 handle_string_escapes: function(s){
  	     s = s.replace(/(([^\\]|)(\\\\)*)\\t/g,"$1\t");
  	     s = s.replace(/(([^\\]|)(\\\\)*)\\n/g,"$1\n");
  	     s = s.replace(/(([^\\]|)(\\\\)*)\\"/g,"$1\"");
  	     s = s.replace(/\\\\/g,"\\");
  	     return s;
  	 },

  	 // X,*:  111
  	 // Y,"": 010
  	 // Y,+-" 110
  	 // Z,"": 000
  	 // Z,+-: 100
  	 // "":  00
  	 // "+": 01
  	 // "-": 10
  	 encode_x: function(i){
  	     var x = 0;
  	     var ptr = i[0] == "-" ? i[1] : i[0];
  	     var mod = i[0] == "-" ? "-" : (i[1] == "+" ? "+" : "");
  	     if(ptr == "X") x = 7*4;
  	     if(ptr == "Y") x = 6*4;
  	     if(ptr == "Z") x = 4*4;
  	     if(ptr != "X" && mod == "") x -= 16;
  	     if(mod == "+") x += 1;
  	     if(mod == "-") x += 2;
  	     return x;
  	 },
  	 decode_x: function(x){
  	     var ptr = "";
  	     var mod = "";
  	     this.debug_log("XX",x,x&3,(x>>2)&3);
  	     if(((x >> 2)&3) == 3) ptr = "X";
  	     if(((x >> 2)&3) == 2) ptr = "Y";
  	     if(((x >> 2)&3) == 0) ptr = "Z";
  	     if((x&3) == 1) mod = "+";
  	     if((x&3) == 2) mod = "-";
  	     this.debug_log("X=",mod,ptr);
  	     return mod == "-" ? mod +""+ ptr : ptr +""+ mod;
  	 },
  	 encode: function(format, c, r, s, i){
  	     var fmt = this.formats[format].binary;
  	     var inst = 0;
  	     var x = 0;
  	     if(format == "5r6s"){
  		 i = s;
  		 s = r;
  		 r = i;
  	     }
  	     else if(format == "5rX" || format == "X5r"){
  		 if(format == "X5r"){
  		     i = r;
  		     r = s;
  		 }
  		 this.debug_log("Xe",i);
  		 x = this.encode_x(i);
  		 this.debug_log("Xd",x);
  	     }
  	     for(var j = 15; j >= 0; j--) {
  		 if(fmt[j] == "C"){
  		     inst += (c%2)<<(15-j);
  		     c >>= 1;
  		 }
  		 if(fmt[j] == "R"){
  		     inst += (r%2)<<(15-j);
  		     r >>= 1;
  		 }
  		 if(fmt[j] == "S"){
  		     inst += (s%2)<<(15-j);
  		     s >>= 1;
  		 }
  		 if(fmt[j] == "I"){
  		     inst += (i%2)<<(15-j);
  		     i >>= 1;
  		 }
  		 if(fmt[j] == "X"){
  		     inst += (x%2)<<(15-j);
  		     x >>= 1;
  		 }
  	     }
  	     return inst;
  	 },
  	 decode: function(x,addr){
  	     for(var f in this.formats){
  		 fmt = this.formats[f];
  		 var data = {"c":0,"r":0,"s":0,"i":0,"x":0};
  		 for(var j = 15; j >= 0; j--){
  		     //this.debug_log("J",j,fmt.binary[15-j],(x>>j)%2);
  		     if(fmt.binary[15-j] == "C") data.c = (data.c * 2) + ((x >> j) % 2);
  		     if(fmt.binary[15-j] == "R") data.r = (data.r * 2) + ((x >> j) % 2);
  		     if(fmt.binary[15-j] == "S") data.s = (data.s * 2) + ((x >> j) % 2);
  		     if(fmt.binary[15-j] == "I") data.i = (data.i * 2) + ((x >> j) % 2);
  		     if(fmt.binary[15-j] == "X") data.x = (data.x * 2) + ((x >> j) % 2);
  		 }
  		 if(f == "4r8i") data.r += 16;
  		 if(f == "12i") data.i = this.truncate(data.i,12,true);
  		 if(f == "7i") data.i = this.truncate(data.i,7,true);
  		 if(f == "5rX") data.i = this.decode_x(data.x);
  		 if(f == "X5r"){
  		     data.s = data.r;
  		     data.r = this.decode_x(data.x);
  		 }
  		 if(f == "5r6s"){
  		     var temp = data.r;
  		     data.r = data.s;
  		     data.s = temp;
  		 }
  		 for(var mnemonic in this.instructions){
  		     inst = this.instructions[mnemonic];
  		     if(inst.format == f && inst.c == data.c){
  			 return new this.instruction(x,mnemonic,data,inst.exec,addr,this);
  		     }
  		 }
  	     }
  	     return {"error":"Could not decode instruction: " + x};
  	 },
  	 label: function(name, addr){
  	     this.label = true;
  	     this.name = name;
  	     this.addr = addr;
  	 },
  	 output_mux: function(){
  	     this.SEL_ADDR = 0;
  	     this.SEL_LEN = 255;
  	     this.LCD_OUT = 1;
  	     this.LB_OUT = 2;
  	     this.target = 0;
  	     this.len = 0;
  	     this.state = 0;
  	     this.input = function(val){
  		 if(this.state == this.SEL_ADDR) {
  		     this.target = val;
  		     this.state = this.SEL_LEN;
  		 }
  		 else if(this.state == this.SEL_LEN){
  		     this.len = val;
  		     this.state = this.target;
  		     this.target = 0;
  		 }
  		 else if(this.len > 0){
  		     if(this.state-1 < this.output_devs.length)
  			 this.output_devs.input(val);
  		     this.len--;
  		 }
  		 else{
  		     this.state = this.SEL_ADDR;
  		 }
  	     };
  	 },
  	 lcd: function(){
  	     this.input = function(val){
  		 
  	     };
  	 },
  	 set_PM_display_mode: function(m){
  	     this.PM_display_mode = m;
  	 },
  	 set_RAM_display_mode: function(m){
  	     this.RAM_display_mode = m;
  	 },
  	 set_RF_display_mode: function(m){
  	     this.RF_display_mode = m;
  	 },
  	 instruction: function(text, mnemonic, data, exec, addr, parent){
  	     console.log(this);
  	     this.parent = parent;
  	     this.label = false;
  	     this.addr = addr;
  	     this.text = text;
  	     this.c = data.c;
  	     this.r = data.r;
  	     this.s = data.s;
  	     this.i = data.i;
  	     this.exec = exec;
  	     this.mnemonic = mnemonic;
  	     console.log(this.text, this.c, this.r, this.s, this.i, this.mnemonic);
  	     this.format = this.parent.instructions[this.mnemonic].format;
  	     if(this.i.match){
  		 var matches = this.i.match(/(lo|hi)8\(([a-zA-Z_][a-zA-Z0-9_]*)\)/);
  		 if(matches){
  		     if(matches[2] in this.parent.symbols){
  			 if(matches[1] == "lo") this.i = this.parent.truncate(this.parent.symbols[matches[2]],8,false);
  			 if(matches[1] == "hi") this.i = this.parent.truncate(this.parent.symbols[matches[2]]>>8,8,false);
  		     }
  		     else{
  			 this.error = "Symbol not found " + matches[2];
  		     }
  		 }
  		 else if(this.i in this.parent.symbols){
  		     this.i = this.parent.symbols[this.i];
  		     var fmt = this.parent.formats[this.format];
  		     //this.parent.debug_log(this.parent.symbols,fmt.i_bits);
  		     if(fmt.i_bits){
  			 this.i = this.parent.truncate(this.i - this.addr - 1,fmt.i_bits,true);
  		     }
  		 }
  		 else if(/'[^'\\]'/.test(this.i)){
  		     this.i = this.i.charCodeAt(1);
  		 }
  		 else if(this.i == "'\\''"){
  		     this.i = this.i.charCodeAt(2);
  		 }
  		 else if(this.i == "'\\\\'"){
  		     this.i = this.i.charCodeAt(2);
  		 }
  		 else if(this.i == "'\\n'"){
  		     this.i = 10;
  		 }
  		 else if(this.i == "'\\t'"){
  		     this.i = 9;
  		 }
  		 else if(/^[XYZ]$|^[XYZ]\+$|^-[XYZ]$/.test(this.i)){
  		     this.i = this.i;
  		 }
  		 else this.i = parseInt(this.i);
  	     }
  	     this.encoding = this.parent.encode(this.format, this.c, this.r, this.s, this.i < 0 ? this.parent.truncate(this.i,this.parent.formats[this.format].i_bits,false) : this.i);
  	     //this.debug_log(this.text, this.c, this.r, this.s, this.i, this.mnemonic);
  	     var self = this;
  	     this.display = function(){
  		 if(this.parent.PM_display_mode == "t"){
  		     return this.parent.formats[self.format].to_string(self.mnemonic,self.c,self.r,self.s,self.i);
  		 }
  		 else if(this.parent.PM_display_mode == "d"){
  		     return self.encoding;
  		 }
  		 else if(this.parent.PM_display_mode == "h"){
  		     var s = self.encoding.toString(16);
  		     return "0x"+this.parent.smul("0",4 - s.length)+s;
  		 }
  		 else if(this.parent.PM_display_mode == "b"){
  		     var s = self.encoding.toString(2);
  		     return this.parent.smul("0",16 - s.length) + s;
  		 }
  	     };
  	     this.check_valid = function(){
  		 return this.parent.formats[self.format].validator(self.c, self.r, self.s, self.i);
  	     };
  	     this.run = function(){
  		 self.exec(self.c, self.r, self.s, self.i);
  	     };
  	 },
  	 step: function(){
  	     if(!this.running) return;
  	     this.debug_log(this.steps.count);
  	     for(var k = 0; k < this.steps.count; k++){
  		 var i = this.PM[this.PC];
  		 this.debug_log("i",i);
  		 i.run();
  		 if(this.PC < this.display_pm_start || this.PC >= this.display_pm_start + this.display_pm_length){
  		     this.display_pm_start = Math.max(0, this.PC - this.display_ram_length/2);
  		 }
  		 if(this.ram_updated.length > 0){
  		     this.display_ram_start = Math.max(0, Math.min.apply(Math, this.ram_updated) - this.display_ram_length/2);
  		 }
  	     }
  	 },
  	 raise_error: function(s){
  	     this.status = "Error: " + s;
  	 },
  	 truncate: function(num, bits, twos_complement){
  	     var mod = 1<<bits;
  	     num = ((num % mod)+mod)%mod;
  	     return twos_complement ? (num >= 1<<(bits - 1) ? num - (1<<bits) : num) : num;
  	 },
  	 update_sreg: function(result, z, c, n){
  	     this.debug_log("SREG for",result);
  	     if(z) this.Z = this.truncate(result,8,false) == 0 ? 1 : 0;
  	     if(c) this.C = result >= 256 || result < 0 ? 1 : 0;
  	     if(n) this.N = this.truncate(result,8,true) <0 ? 1 : 0;
  	 },
  	 read_IO: function(s){
  	     if(s == 16) return this.PIND & (~(this.DDRD));
  	     else if(s == 17) return this.DDRD;
  	     else if(s == 61) return this.SPL;
  	     else if(s == 62) return this.SPH;
  	     return 0;
  	 },
  	 write_IO: function(s,val){
  	     if(s == 18){
  		 this.PORTD = this.DDRD & val;
  		 this.output();
  	     }
  	     else if(s == 17) this.DDRD = this.truncate(val,8,false);
  	     else if(s == 61) this.SPL = this.truncate(val,8,false);
  	     else if(s == 62) this.SPH = this.truncate(val,8,false);
  	     if(this.output_type.selection == "simple"){
  		 this.PIND = 0;
  		 for(var i = 0; i < 8; i++)
  		     this.PIND |= (this.io_state.switch_state[i] == "ON" ? 1 << i : 0);
  		 this.PIND &= ~this.DDRD;
  	     }
  	 },
  	 inc_ptr: function(reg){
  	     if(this.RF[reg] == -1 || this.RF[reg] == 255){
  		 this.RF[reg] = 0;
  		 this.RF[reg+1] = this.truncate(this.RF[reg+1]+1,8,false);
  	     }
  	     else this.RF[reg]++;
  	     if(this.RF[reg] == 128){
  		 this.RF[reg] = -128;
  	     }
  	 },
  	 dec_ptr: function(reg){
  	     this.RF[reg]--;
  	     if(this.RF[reg] == -1){
  		 this.RF[reg+1] = this.truncate(this.RF[reg+1]-1,8,false);
  	     }
  	     if(this.RF[reg] < -128){
  		 this.RF[reg] = 127;
  	     }
  	 },
  	 incSP: function(){
  	     this.SPL++;
  	     if(this.SPL == 256){
  		 this.SPL = 0;
  		 this.SPH = this.truncate(this.SPH+1,8,false);
  	     }
  	 },
  	 decSP: function(){
  	     this.SPL--;
  	     if(this.SPL == -1){
  		 this.SPL = 255;
  		 this.SPH = this.truncate(this.SPH-1,8,false);
  	     }
  	 },
  	 io_switch: function(i){
  	     if(this.io_state.switch_state[i] == "ON"){
  		 this.io_state.switch_state[i] = "OFF";
  		 this.PIND &= ~(1<<i);
  	     }
  	     else if(this.io_state.switch_state[i] == "OFF"){
  		 this.io_state.switch_state[i] = "ON";
  		 this.PIND |= 1<<i;
  	     }
  	     this.PIND = this.PIND & ~this.DDRD;
  	 },
  	 output: function(){
  	     var out_val = this.PORTD;
  	     this.outputs.push(out_val);
  	     //this.outputs.push(String.fromCharCode(out_val));
  	 },
  	 initialize: function(){
  	     this.reset_program();
  	     this.cm_setup();
  	 },
  	 end: function(){
  	     if(!this.running) return;
  	     this.running = false;
  	     setTimeout(this.cm_setup, 0);
  	 }

       },
       created: function(){
  	 console.log("init");
  	 this.$store.dispatch("RESET_PLUGIN_DATA","math");
  	 //Guppy.init({"path":"/node_modules/guppy-js","symbols":"/node_modules/guppy-js/sym/symbols.json"});
       }, 
       mounted: function(){
  	 console.log("Hello JSAVR");
  	 console.log(this.instructions);
  	 this.program = this.root.innerHTML.trim();
  	 this.reset(true);
  	 this.original_program = this.program;
  	 this.initialize();

  	 this.debug_log = this.debug_mode_feature == 'yes' ? console.log.bind(console) : this.do_nothing;
  	 if(this.control){
  	     this.control.set_program = function(new_prog){
  		 this.change_program(new_prog);
  	     };
  	     this.control.get_program = function(){
  		 if(this.editor) this.program = this.editor.getValue();
  		 return this.program;
  	     };
  	     this.control.get_PM = function(addr){
  		 return this.PM[addr].encoding;
  	     };
  	     this.control.get_RF = function(){
  		 return this.RF;
  	     };
  	     this.control.get_RAM = function(addr){
  		 return this.RAM[addr];
  	     };
  	     this.control.get_other = function(){
  		 return {
  		     "PC":this.PC,
  		     "Z":this.Z,
  		     "C":this.C,
  		     "N":this.N,
  		     "DDRD":this.DDRD,
  		     "PIND":this.PIND,
  		     "PORTD":this.PORTD,
  		     "SPL":this.SPL,
  		     "SPH":this.SPH
  		 }
  	     };
  	 }
  	 /* 
  	  * 	 
  	  * 	 var index = 0;
  	  * 	 var doc_id = node+"-"+index;
  	  * 	 var content = this.root.innerHTML.trim()
  	  * 	 console.log("R",this.root,content);
  	  * 	 //var res = Guppy.Doc.render(content, "text");
  	  * 	 var res = {doc:content};
  	  * 	 var doc_data = {};
  	  * 	 //doc_data[index] = res.doc.get_vars().concat(res.doc.get_symbols());
  	  * 	 doc_data[index] = ["x"];
  	  * 	 //res.container.setAttribute("id","category-math-container-"+doc_id);
  	  * 	 //var rendered_content = (new XMLSerializer()).serializeToString(res.container);
  	  * 
  	  * 	 
  	  * 	 // Put this doc ID in the index for each var and symbol in the document
  	  * 	 for(var i = 0; i < this.docs[node][index].length; i++) {
  	  * 	     var v = this.docs[node][index][i];
  	  * 	     if (!this.index[v]) this.index[v] = [];
  	  * 	     if (this.index[v].indexOf(doc_id) < 0) this.index[v].push(doc_id);
  	  * 	 }
  	  * 
  	  * 	 // Calculate the snippet that will be associated with this expression when it appears in listings
  	  * 	 var snippet = "";
  	  * 	 if(this.root.previousSibling){
  	  * 	     snippet += this.root.previousSibling.textContent.split(" ").slice(-4).join(" ");
  	  * 	 }
  	  * 	 snippet += " [formula] "
  	  * 
  	  * 	 if(this.root.nextSibling) {
  	  * 	     snippet += this.root.nextSibling.textContent.split(" ").slice(0,4).join(" ");
  	  * 	 }
  	  * 	 snippet = "..." + snippet + "...";
  	  * 	 console.log("parprev",this.root.parentNode.previousSibling);
  	  * 	 console.log("parnext",this.root.parentNode.nextSibling);
  	  * 	 this.snippets[doc_id] = snippet;
  	  * 
  	  * 	 // Finally, set up component attributes
  	  * 	 this.syms = this.docs[node][index];
  	  * 	 this.rendered = rendered_content;
  	  * 	 this.display_syms = false;
  	  * 	 this.id = doc_id;
  	  * 	 this.query = "";
  	  * 	 this.node = node;*/
       }
   };

  /* script */
  const __vue_script__$g = script$g;

  /* template */
  var __vue_render__$h = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "simavr" }, [
      !_vm.running
        ? _c("div", { staticClass: "simavr_programming" }, [
            _c("div", { staticClass: "simavr_controls" }, [
              _c(
                "div",
                {
                  class:
                    "simavr_button " +
                    (_vm.running == true
                      ? "simavr_disabled_button"
                      : "simavr_enabled_button"),
                  on: {
                    click: function($event) {
                      return _vm.program_pm()
                    }
                  }
                },
                [_vm._v("run")]
              ),
              _vm.reset_feature != "no"
                ? _c(
                    "div",
                    {
                      class:
                        "simavr_button " +
                        (_vm.running == true
                          ? "simavr_disabled_button"
                          : "simavr_enabled_button"),
                      on: {
                        click: function($event) {
                          return _vm.reset_program()
                        }
                      }
                    },
                    [_vm._v("reset")]
                  )
                : _vm._e(),
              _c("div", { staticClass: "simavr_status" }, [
                _vm._v("Status: " + _vm._s(_vm.status))
              ])
            ]),
            _c("br"),
            _c("form", [
              _c("textarea", {
                attrs: { id: "simavr" + _vm.simid + "_program_area" }
              })
            ]),
            _c("br")
          ])
        : _vm._e(),
      _vm.running
        ? _c("div", { staticClass: "simavr_output_container" }, [
            _c("div", { staticClass: "simavr_controls" }, [
              _c(
                "div",
                {
                  class:
                    "simavr_button " +
                    (_vm.running == false
                      ? "simavr_disabled_button"
                      : "simavr_enabled_button"),
                  on: {
                    click: function($event) {
                      return _vm.end()
                    }
                  }
                },
                [_vm._v("end")]
              ),
              _c(
                "div",
                {
                  staticStyle: { "margin-top": "10px", display: "inline-block" }
                },
                [
                  _c(
                    "select",
                    {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.output_type.selection,
                          expression: "output_type.selection"
                        }
                      ],
                      attrs: { name: "output_select" },
                      on: {
                        change: function($event) {
                          var $$selectedVal = Array.prototype.filter
                            .call($event.target.options, function(o) {
                              return o.selected
                            })
                            .map(function(o) {
                              var val = "_value" in o ? o._value : o.value;
                              return val
                            });
                          _vm.$set(
                            _vm.output_type,
                            "selection",
                            $event.target.multiple
                              ? $$selectedVal
                              : $$selectedVal[0]
                          );
                        }
                      }
                    },
                    [
                      _c("option", { attrs: { value: "program" } }, [
                        _vm._v("View Program")
                      ]),
                      _c("option", { attrs: { value: "simple" } }, [
                        _vm._v("View Simple I/O")
                      ])
                    ]
                  )
                ]
              )
            ]),
            _vm.output_type.selection == "program"
              ? _c("div", { staticClass: "simavr_output" }, [
                  _c("b", [_vm._v("Program: ")]),
                  _c("pre", [_vm._v(_vm._s(_vm.program))])
                ])
              : _vm._e(),
            _vm.output_type.selection == "simple"
              ? _c(
                  "div",
                  { staticClass: "simavr_output" },
                  [
                    _vm._v("\n\t\tOutput LCD: "),
                    _c("br"),
                    _vm._v("(Connected to pins 0-7 of D)"),
                    _c("br"),
                    _c("div", { staticClass: "simavr_io_num" }, [
                      _vm._v(
                        "\n\t\t    " +
                          _vm._s(_vm.truncate(_vm.PORTD, 8, false)) +
                          "\n\t\t"
                      )
                    ]),
                    _c("br"),
                    _c("br"),
                    _vm._v("\n\n\t\tToggle switches--click to toggle:"),
                    _c("br"),
                    _vm._v("(Connected to pins 0-7 of D): "),
                    _c("br"),
                    _vm._l([0, 1, 2, 3, 4, 5, 6, 7], function(i) {
                      return _c(
                        "div",
                        { staticStyle: { display: "inline-block" } },
                        [
                          _vm._v("\n\t\t    " + _vm._s(i) + ":\n\t\t    "),
                          _c(
                            "div",
                            {
                              class:
                                "simavr_io_switch " +
                                (_vm.io_state.switch_state[i] == "ON"
                                  ? "simavr_io_switch_on"
                                  : "simavr_io_switch_off"),
                              on: {
                                click: function($event) {
                                  return _vm.io_switch(i)
                                }
                              }
                            },
                            [
                              _vm._v(
                                "\n\t\t\t" +
                                  _vm._s(_vm.io_state.switch_state[i]) +
                                  "\n\t\t    "
                              )
                            ]
                          ),
                          _c("br"),
                          _c("br")
                        ]
                      )
                    })
                  ],
                  2
                )
              : _vm._e(),
            _vm.output_type.selection == "complex"
              ? _c("div", { staticClass: "simavr_output" }, [
                  _vm._v("\n\t\tPaceholder for full output panel\n\t    ")
                ])
              : _vm._e()
          ])
        : _vm._e(),
      _vm.running
        ? _c("div", { staticClass: "simavr_simulator" }, [
            _c("div", { staticClass: "simavr_controls" }, [
              _c(
                "div",
                {
                  class:
                    "simavr_button " +
                    (_vm.running == false
                      ? "simavr_disabled_button"
                      : "simavr_enabled_button"),
                  on: {
                    click: function($event) {
                      return _vm.reset(false)
                    }
                  }
                },
                [_vm._v("reset")]
              ),
              _c(
                "div",
                {
                  class:
                    "simavr_button " +
                    (_vm.running == false
                      ? "simavr_disabled_button"
                      : "simavr_enabled_button"),
                  on: {
                    click: function($event) {
                      return _vm.step()
                    }
                  }
                },
                [_vm._v("step")]
              ),
              _vm.running == true
                ? _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.steps.count,
                        expression: "steps.count"
                      }
                    ],
                    staticClass: "simavr_mem_start",
                    attrs: { type: "number" },
                    domProps: { value: _vm.steps.count },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.$set(_vm.steps, "count", $event.target.value);
                      }
                    }
                  })
                : _vm._e()
            ]),
            _c("br"),
            _c(
              "div",
              { attrs: { id: "simavr_pm" } },
              [
                _c("div", { staticClass: "simavr_title" }, [
                  _vm._v("PM at "),
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.display_pm_start,
                        expression: "display_pm_start"
                      }
                    ],
                    staticClass: "simavr_mem_start",
                    attrs: { type: "number" },
                    domProps: { value: _vm.display_pm_start },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.display_pm_start = $event.target.value;
                      }
                    }
                  })
                ]),
                _c("br"),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_PM_display_mode("t")
                      }
                    }
                  },
                  [_vm._v("[text]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_PM_display_mode("b")
                      }
                    }
                  },
                  [_vm._v("[bin]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_PM_display_mode("d")
                      }
                    }
                  },
                  [_vm._v("[dec]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_PM_display_mode("h")
                      }
                    }
                  },
                  [_vm._v("[hex]")]
                ),
                _vm._l(
                  _vm.PM.slice(
                    _vm.display_pm_start,
                    _vm.display_pm_start + _vm.display_pm_length
                  ),
                  function(i, idx) {
                    return _c("div", [
                      _c(
                        "div",
                        {
                          class:
                            "simavr_pm " +
                            (_vm.display_pm_start + idx == _vm.PC
                              ? "simavr_active"
                              : "simavr_normal")
                        },
                        [
                          _c("span", { staticClass: "simavr_label_long" }, [
                            _vm._v(_vm._s(_vm.display_pm_start + idx) + ": ")
                          ]),
                          _vm._v(
                            _vm._s(_vm.PM[_vm.display_pm_start + idx].display()) +
                              "\n\t\t    "
                          )
                        ]
                      ),
                      _c("br")
                    ])
                  }
                ),
                _c("br")
              ],
              2
            ),
            _c(
              "div",
              { attrs: { id: "simavr_rf" } },
              [
                _c("div", { staticClass: "simavr_title" }, [
                  _vm._v("Register file")
                ]),
                _c("br"),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RF_display_mode("b")
                      }
                    }
                  },
                  [_vm._v("[bin]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RF_display_mode("d")
                      }
                    }
                  },
                  [_vm._v("[dec]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RF_display_mode("2")
                      }
                    }
                  },
                  [_vm._v("[com]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RF_display_mode("h")
                      }
                    }
                  },
                  [_vm._v("[hex]")]
                ),
                _c("br"),
                _vm._l(_vm.RF, function(r, idx) {
                  return _c("span", [
                    _c(
                      "div",
                      {
                        class:
                          "simavr_reg " +
                          (_vm.is_updated(idx)
                            ? "simavr_updated"
                            : "simavr_normal")
                      },
                      [
                        _c("span", { staticClass: "simavr_label" }, [
                          _vm._v(_vm._s(idx) + ": ")
                        ]),
                        _vm._v(_vm._s(_vm.display_rf(idx)))
                      ]
                    ),
                    idx % 2 == 1 ? _c("br") : _vm._e()
                  ])
                }),
                _c("br")
              ],
              2
            ),
            _c(
              "div",
              { attrs: { id: "simavr_ram" } },
              [
                _c("div", { staticClass: "simavr_title" }, [
                  _vm._v("RAM at "),
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.display_ram_start,
                        expression: "display_ram_start"
                      }
                    ],
                    staticClass: "simavr_mem_start",
                    attrs: { type: "number" },
                    domProps: { value: _vm.display_ram_start },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.display_ram_start = $event.target.value;
                      }
                    }
                  })
                ]),
                _c("br"),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RAM_display_mode("d")
                      }
                    }
                  },
                  [_vm._v("[dec]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RAM_display_mode("2")
                      }
                    }
                  },
                  [_vm._v("[com]")]
                ),
                _c(
                  "div",
                  {
                    staticClass: "simavr_display_button",
                    on: {
                      click: function($event) {
                        return _vm.set_RAM_display_mode("c")
                      }
                    }
                  },
                  [_vm._v("[txt]")]
                ),
                _vm._l(
                  _vm.RAM.slice(
                    _vm.display_ram_start,
                    _vm.display_ram_start + _vm.display_ram_length
                  ),
                  function(i, idx) {
                    return _c("div", [
                      _c(
                        "div",
                        {
                          class:
                            "simavr_ram " +
                            (_vm.is_ram_updated(_vm.display_ram_start + idx)
                              ? "simavr_updated"
                              : "simavr_normal")
                        },
                        [
                          _c("span", { staticClass: "simavr_label_long" }, [
                            _vm._v(_vm._s(_vm.display_ram_start + idx) + ": ")
                          ]),
                          _vm._v(
                            _vm._s(_vm.display_ram(_vm.display_ram_start + idx)) +
                              "\n\t\t    "
                          )
                        ]
                      ),
                      _c("br")
                    ])
                  }
                ),
                _c("br")
              ],
              2
            ),
            _c("div", { attrs: { id: "simavr_other" } }, [
              _c("div", { staticClass: "simavr_title" }, [_vm._v("Other")]),
              _c("br"),
              _c(
                "div",
                {
                  staticClass: "simavr_display_button",
                  on: { click: function($event) {} }
                },
                [_vm._v(" ")]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class: {
                    simavr_reg: true,
                    simavr_updated: _vm.is_updated("PC"),
                    simavr_normal: !_vm.is_updated("PC")
                  }
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("PC: ")]),
                  _vm._v(_vm._s(_vm.PC))
                ]
              ),
              _c("br"),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("Z") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("Z: ")]),
                  _vm._v(_vm._s(_vm.Z))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("C") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("C: ")]),
                  _vm._v(_vm._s(_vm.C))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("N") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("N: ")]),
                  _vm._v(_vm._s(_vm.N))
                ]
              ),
              _c("br"),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated(26) || _vm.is_updated(27)
                      ? "simavr_updated"
                      : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("X: ")]),
                  _vm._v(
                    _vm._s(
                      _vm.truncate(_vm.RF[26], 8, false) +
                        256 * _vm.truncate(_vm.RF[27], 8, false)
                    )
                  )
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated(28) || _vm.is_updated(29)
                      ? "simavr_updated"
                      : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("Y: ")]),
                  _vm._v(
                    _vm._s(
                      _vm.truncate(_vm.RF[28], 8, false) +
                        256 * _vm.truncate(_vm.RF[29], 8, false)
                    )
                  )
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated(30) || _vm.is_updated(31)
                      ? "simavr_updated"
                      : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label" }, [_vm._v("Z: ")]),
                  _vm._v(
                    _vm._s(
                      _vm.truncate(_vm.RF[30], 8, false) +
                        256 * _vm.truncate(_vm.RF[31], 8, false)
                    )
                  )
                ]
              ),
              _c("br"),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("PIND") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label_long" }, [
                    _vm._v("PIND: ")
                  ]),
                  _vm._v(_vm._s(_vm.PIND))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("DDRD") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label_long" }, [
                    _vm._v("DDRD: ")
                  ]),
                  _vm._v(_vm._s(_vm.DDRD))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("PORTD") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label_long" }, [
                    _vm._v("PORTD: ")
                  ]),
                  _vm._v(_vm._s(_vm.PORTD))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("SPL") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label_long" }, [
                    _vm._v("SPL: ")
                  ]),
                  _vm._v(_vm._s(_vm.SPL))
                ]
              ),
              _c("br"),
              _c(
                "div",
                {
                  class:
                    "simavr_reg " +
                    (_vm.is_updated("SPH") ? "simavr_updated" : "simavr_normal")
                },
                [
                  _c("span", { staticClass: "simavr_label_long" }, [
                    _vm._v("SPH: ")
                  ]),
                  _vm._v(_vm._s(_vm.SPH))
                ]
              )
            ])
          ])
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$h = [];
  __vue_render__$h._withStripped = true;

    /* style */
    const __vue_inject_styles__$h = function (inject) {
      if (!inject) return
      inject("data-v-01dd48c1_0", { source: "\n.simavr[data-v-01dd48c1]{\n    display:inline-block;\n    width:73em;\n    /* min-height:40em; */\n    font-size:10pt;\n}\n#simavr_rf[data-v-01dd48c1]{\n    float:left;\n    width:16em;\n    border:1px solid #aaa;\n    text-align:center;\n}\n#simavr_pm[data-v-01dd48c1]{\n    float:left;\n    width:13em;\n    border:1px solid #aaa;\n    text-align:center;\n}\n#simavr_ram[data-v-01dd48c1]{\n    float:left;\n    width:10em;\n    border:1px solid #aaa;\n    text-align:center;\n}\n#simavr_other[data-v-01dd48c1]{\n    float:left;\n    width:10em;\n    border:1px solid #aaa;\n    text-align:center;\n}\n.simavr_title[data-v-01dd48c1]{\n    width:100%;\n    text-align:center;\n    display:inline-block;\n    font-size:12pt;\n    margin:auto;\n    padding-bottom:5px;\n    line-height:2.5em;\n}\n.simavr_status[data-v-01dd48c1]{\n    display:inline-block;\n    padding:5px;\n    border-left:1px solid #aaa;\n    /* border-radius:5px; */\n    margin:5px;\n    width:45%;\n    font-size:9pt;\n    float:right;\n}\n.active_line[data-v-01dd48c1]{\n    background-color:#f66;\n}\n.simavr_label[data-v-01dd48c1]{\n    font-size:10pt;\n    color:#333;\n    display:inline-block;\n    width:2em;\n}\n.simavr_label_long[data-v-01dd48c1]{\n    font-size:10pt;\n    color:#333;\n    display:inline-block;\n    margin-right:0.5ex;\n    min-width:2em;\n}\n.simavr_reg[data-v-01dd48c1]{\n    text-align:left;\n    display:inline-block;\n    padding:4px;\n    /*margin:0 2px 2px 0;*/\n    width:7em;\n}\n.simavr_pm[data-v-01dd48c1]{\n    text-align:left;\n    display:inline-block;\n    padding:4px;\n    /*margin:0 2px 2px 0;*/\n    width:12em;\n}\n.simavr_mem_start[data-v-01dd48c1]{\n    padding:4px;\n    width:4em;\n    margin:4px;\n}\n.simavr_ram[data-v-01dd48c1]{\n    text-align:left;\n    display:inline-block;\n    padding:4px;\n    /*margin:0 2px 2px 0;*/\n    width:7em;\n}\n.simavr_controls[data-v-01dd48c1]{\n    display:inline-block;\n    width:90%;\n    height:50px;\n    border: 2px solid #ccc;\n    margin:auto;\n    margin-bottom:5px;\n}\n.simavr_programming[data-v-01dd48c1]{\n    display:inline-block;\n    float:left;\n    width:70%;\n}\n.simavr_output_container[data-v-01dd48c1]{\n    display:inline-block;\n    float:left;\n    width:25%;\n}\n.simavr_simulator[data-v-01dd48c1]{\n    display:inline-block;\n    float:left;\n    width:75%;\n}\n.simavr_output[data-v-01dd48c1]{\n    display:inline-block;\n    padding:5px;\n    width:90%;\n    border:1px solid #aaa;\n    overflow-x:scroll;\n    overflow-y:scroll;\n}\n.simavr_program[data-v-01dd48c1]{\n    width:90%;\n}\n.simavr_normal[data-v-01dd48c1]{\n    background-color:#c66;\n}\n.simavr_updated[data-v-01dd48c1]{\n    background-color:#6c6;\n}\n.simavr_active[data-v-01dd48c1]{\n    background-color:#cc6;\n}\n.simavr_display_button[data-v-01dd48c1]{\n    display:inline-block;\n    padding:2px;\n}\n.simavr_enabled_button[data-v-01dd48c1]{\n    background-color:#66a;\n}\n.simavr_disabled_button[data-v-01dd48c1]{\n    background-color:#aaa;\n}\n.simavr_display_button[data-v-01dd48c1]:hover{\n    display:inline-block;\n    cursor:pointer;\n    color:#f33;\n}\n.simavr_button[data-v-01dd48c1]{\n    display:inline-block;\n    padding:8px;\n    border-radius:5px;\n    height:25px;\n    color:white;\n    margin:5px;\n    cursor:pointer;\n}\n.simavr_button[data-v-01dd48c1]:hover{\n    display:inline-block;\n    cursor:pointer;\n    color:#f33;\n}\n.simavr_io_num[data-v-01dd48c1]{\n    width:3em;\n    border:3px solid black;\n    background-color:#363;\n    color:#ff4;\n    font-size:17pt;\n    padding:5px;\n}\n.simavr_io_switch[data-v-01dd48c1]{\n    display:inline-block;\n    width:3em;\n    border:3px solid black;\n    font-size:17pt;\n    padding:5px;\n    cursor:pointer;\n}\n.simavr_io_switch_on[data-v-01dd48c1]{\n    background-color:#3f3;\n}\n.simavr_io_switch_off[data-v-01dd48c1]{\n    background-color:#f33;\n}\n", map: {"version":3,"sources":["/home/zoom/suit/category/page/src/plugins/jsavr.vue"],"names":[],"mappings":";AA+sCA;IACA,oBAAA;IACA,UAAA;IACA,qBAAA;IACA,cAAA;AACA;AACA;IACA,UAAA;IACA,UAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,UAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,UAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,UAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,oBAAA;IACA,cAAA;IACA,WAAA;IACA,kBAAA;IACA,iBAAA;AACA;AAEA;IACA,oBAAA;IACA,WAAA;IACA,0BAAA;IACA,uBAAA;IACA,UAAA;IACA,SAAA;IACA,aAAA;IACA,WAAA;AACA;AAEA;IACA,qBAAA;AACA;AACA;IACA,cAAA;IACA,UAAA;IACA,oBAAA;IACA,SAAA;AACA;AACA;IACA,cAAA;IACA,UAAA;IACA,oBAAA;IACA,kBAAA;IACA,aAAA;AACA;AAEA;IACA,eAAA;IACA,oBAAA;IACA,WAAA;IACA,sBAAA;IACA,SAAA;AACA;AACA;IACA,eAAA;IACA,oBAAA;IACA,WAAA;IACA,sBAAA;IACA,UAAA;AACA;AAEA;IACA,WAAA;IACA,SAAA;IACA,UAAA;AACA;AAEA;IACA,eAAA;IACA,oBAAA;IACA,WAAA;IACA,sBAAA;IACA,SAAA;AACA;AAEA;IACA,oBAAA;IACA,SAAA;IACA,WAAA;IACA,sBAAA;IACA,WAAA;IACA,iBAAA;AACA;AAEA;IACA,oBAAA;IACA,UAAA;IACA,SAAA;AACA;AAEA;IACA,oBAAA;IACA,UAAA;IACA,SAAA;AACA;AAEA;IACA,oBAAA;IACA,UAAA;IACA,SAAA;AACA;AAEA;IACA,oBAAA;IACA,WAAA;IACA,SAAA;IACA,qBAAA;IACA,iBAAA;IACA,iBAAA;AACA;AAEA;IACA,SAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,oBAAA;IACA,WAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,oBAAA;IACA,cAAA;IACA,UAAA;AACA;AACA;IACA,oBAAA;IACA,WAAA;IACA,iBAAA;IACA,WAAA;IACA,WAAA;IACA,UAAA;IACA,cAAA;AACA;AAEA;IACA,oBAAA;IACA,cAAA;IACA,UAAA;AACA;AAEA;IACA,SAAA;IACA,sBAAA;IACA,qBAAA;IACA,UAAA;IACA,cAAA;IACA,WAAA;AACA;AAEA;IACA,oBAAA;IACA,SAAA;IACA,sBAAA;IACA,cAAA;IACA,WAAA;IACA,cAAA;AACA;AAEA;IACA,qBAAA;AACA;AAEA;IACA,qBAAA;AACA","file":"jsavr.vue","sourcesContent":["<template>\n    <div class=\"simavr\">\n\t<div class=\"simavr_programming\" v-if=\"!running\">\n\t    <div class=\"simavr_controls\">\n\t\t<div v-bind:class=\"'simavr_button ' + (running == true ? 'simavr_disabled_button' : 'simavr_enabled_button')\" v-on:click=\"program_pm()\">run</div>\n\t\t<div v-bind:class=\"'simavr_button ' + (running == true ? 'simavr_disabled_button' : 'simavr_enabled_button')\" v-on:click=\"reset_program()\" v-if=\"reset_feature != 'no'\">reset</div>\n\t\t<div class=\"simavr_status\">Status: {{status}}</div>\n\t    </div><br />\n\t    <form><textarea v-bind:id=\"'simavr'+simid+'_program_area'\"></textarea></form>\n\t    <br />\n\t</div>\n\t<div class=\"simavr_output_container\" v-if=\"running\">\n\t    <div class=\"simavr_controls\">\n\t\t<div v-bind:class=\"'simavr_button ' + (running == false ? 'simavr_disabled_button' : 'simavr_enabled_button')\" v-on:click=\"end()\">end</div>\n\t\t<div style=\"margin-top:10px;display:inline-block;\">\n\t\t    <select name=\"output_select\" v-model=\"output_type.selection\">\n\t\t\t<option value=\"program\">View Program</option>\n\t\t\t<option value=\"simple\">View Simple I/O</option>\n\t\t\t<!-- <option value=\"complex\">View Complex I/O</option> -->\n\t\t    </select>\n\t\t</div>\n\t    </div>\n\t    <div class=\"simavr_output\" v-if=\"output_type.selection == 'program'\">\n\t\t<b>Program: </b>\n\t\t<pre>{{program}}</pre>\n\t    </div>\n\t    <div class=\"simavr_output\" v-if=\"output_type.selection == 'simple'\">\n\t\tOutput LCD: <br />(Connected to pins 0-7 of D)<br />\n\t\t<div class=\"simavr_io_num\">\n\t\t    {{truncate(PORTD,8,false)}}\n\t\t</div>\n\n\t\t<br /><br />\n\n\t\tToggle switches--click to toggle:<br />(Connected to pins 0-7 of D): <br />\n\t\t<div style=\"display:inline-block;\" v-for=\"i in [0,1,2,3,4,5,6,7]\">\n\t\t    {{i}}:\n\t\t    <div v-bind:class=\"'simavr_io_switch ' + (io_state.switch_state[i] == 'ON' ? 'simavr_io_switch_on' : 'simavr_io_switch_off')\" v-on:click=\"io_switch(i)\">\n\t\t\t{{io_state.switch_state[i]}}\n\t\t    </div>\n\t\t    <br /><br />\n\t\t</div>\n\t    </div>\n\t    <div class=\"simavr_output\" v-if=\"output_type.selection == 'complex'\">\n\t\tPaceholder for full output panel\n\t    </div>\n\t</div>\n\t<div class=\"simavr_simulator\" v-if=\"running\">\n\t    <div class=\"simavr_controls\">\n\t\t<div v-bind:class=\"'simavr_button ' + (running == false ? 'simavr_disabled_button' : 'simavr_enabled_button')\" v-on:click=\"reset(false)\">reset</div>\n\t\t<div v-bind:class=\"'simavr_button ' + (running == false ? 'simavr_disabled_button' : 'simavr_enabled_button')\" v-on:click=\"step()\">step</div>\n\t\t<input class=\"simavr_mem_start\" type=\"number\" v-model=\"steps.count\" v-if=\"running == true\"></input>\n\t    </div><br />\n\t    <div id=\"simavr_pm\">\n\t\t<div class=\"simavr_title\">PM at <input class=\"simavr_mem_start\" type=\"number\" v-model=\"display_pm_start\"></input></div><br />\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_PM_display_mode('t')\">[text]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_PM_display_mode('b')\">[bin]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_PM_display_mode('d')\">[dec]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_PM_display_mode('h')\">[hex]</div>\n\t\t<div v-for=\"(i,idx) in PM.slice(display_pm_start,display_pm_start+display_pm_length)\">\n\t\t    <div v-bind:class=\"'simavr_pm '+ (display_pm_start+idx == PC ? 'simavr_active' : 'simavr_normal')\">\n\t\t\t<span class=\"simavr_label_long\">{{display_pm_start+idx}}: </span>{{ PM[display_pm_start+idx].display() }}\n\t\t    </div>\n\t\t    <br />\n\t\t</div>\n\t\t<br />\n\t    </div>\n\t    <div id=\"simavr_rf\">\n\t\t<div class=\"simavr_title\">Register file</div><br />\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RF_display_mode('b')\">[bin]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RF_display_mode('d')\">[dec]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RF_display_mode('2')\">[com]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RF_display_mode('h')\">[hex]</div>\n\t\t<br />\n\t\t\n\t\t<span v-for=\"(r,idx) in RF\"><div v-bind:class=\"'simavr_reg '+ (is_updated(idx) ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">{{idx}}: </span>{{display_rf(idx)}}</div><br v-if=\"(idx)%2 == 1\" /></span><br />\n\t    </div>\n\t    <div id=\"simavr_ram\">\n\t\t<div class=\"simavr_title\">RAM at <input class=\"simavr_mem_start\" type=\"number\" v-model=\"display_ram_start\"></input></div><br />\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RAM_display_mode('d')\">[dec]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RAM_display_mode('2')\">[com]</div>\n\t\t<div class=\"simavr_display_button\" v-on:click=\"set_RAM_display_mode('c')\">[txt]</div>\n\t\t<div v-for=\"(i,idx) in RAM.slice(display_ram_start,display_ram_start+display_ram_length)\">\n\t\t    <div v-bind:class=\"'simavr_ram '+ (is_ram_updated(display_ram_start+idx) ? 'simavr_updated' : 'simavr_normal')\">\n\t\t\t<span class=\"simavr_label_long\">{{display_ram_start+idx}}: </span>{{display_ram(display_ram_start+idx)}}\n\t\t    </div>\n\t\t    <br />\n\t\t</div>\n\t\t<br />\n\t    </div>\n\t    <div id=\"simavr_other\">\n\t\t<div class=\"simavr_title\">Other</div><br /><div class=\"simavr_display_button\" v-on:click=\"\">&nbsp;</div><br />\n\t\t<div v-bind:class=\"{simavr_reg:true, simavr_updated:is_updated('PC'), simavr_normal:!is_updated('PC')}\"><span class=\"simavr_label\">PC: </span>{{PC}}</div><br />\n\t\t<br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('Z') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">Z: </span>{{Z}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('C') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">C: </span>{{C}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('N') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">N: </span>{{N}}</div><br />\n\t\t<br />\n\t\t\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated(26)||is_updated(27) ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">X: </span>{{truncate(RF[26],8,false)+256*truncate(RF[27],8,false)}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated(28)||is_updated(29) ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">Y: </span>{{truncate(RF[28],8,false)+256*truncate(RF[29],8,false)}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated(30)||is_updated(31) ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label\">Z: </span>{{truncate(RF[30],8,false)+256*truncate(RF[31],8,false)}}</div><br />\n\t\t<br />\n\t\t\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('PIND') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label_long\">PIND: </span>{{PIND}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('DDRD') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label_long\">DDRD: </span>{{DDRD}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('PORTD') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label_long\">PORTD: </span>{{PORTD}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('SPL') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label_long\">SPL: </span>{{SPL}}</div><br />\n\t\t<div v-bind:class=\"'simavr_reg '+(is_updated('SPH') ? 'simavr_updated' : 'simavr_normal')\"><span class=\"simavr_label_long\">SPH: </span>{{SPH}}</div>\n\t    </div>\n\t</div>\n    </div>\n</template>\n<script>\n import CodeMirror from 'codemirror'\n export default {\n     name: 'cat-jsavr',\n     props: ['root','program','text','control','size','lightboard_feature','reset_feature','simid','debug_mode_feature'],\n     data () {\n\t return {\n\t     id: '',\n\t     rendered: '',\n\t     debug_log: this.do_nothing,\n\t     status: \"Ready\",\n\t     running: false,\n\t     outputs: [],\n\t     io_state: {'switch_state':[\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\"]},\n\t     steps: {'count':1},\n\t     output_type: {\"selection\":\"program\"},\n\t     symbols: {},\n\t     PM_display_mode: \"t\",\n\t     RAM_display_mode: \"d\",\n\t     RF_display_mode: \"d\",\n\t     RAM: [],\n\t     PM: [],\n\t     RF: [],\n\t     \n\t     PIND: 0,\n\t     PORTD: 0,\n\t     DDRD: 0,\n\t     SPH: 0,\n\t     SPL: 0,\n\t     \n\t     RAM_size: 65536,\n\t     PM_size: 65536,\n\t     RF_size: 32,\n\t     updated: [],\n\t     error_line: 0,\n\t     current_ram_data: [],\n\t     display_pm_start: 0,\n\t     display_ram_start: 0,\n\t     display_pm_length: 16,\n\t     display_ram_length: 16,\n\t     directives: {\n\t\t \"label\":{\"regex\":/^([a-zA-Z_][a-zA-Z0-9_]*):$/,\"process\":function(args){\n\t\t     return {\"symbol\":args[1],\n\t\t\t     \"symbol_type\":\"pm\",\n\t\t     };\n\t\t }},\n\t\t \"word\":{\"regex\":/^\\.word ([0-9,]+)$/,\"process\":function(args){\n\t\t     var rdata = args[1].split(\",\");\n\t\t     for(var i = 0; i < rdata.length; i++){\n\t\t\t rdata[i] = this.truncate(parseInt(rdata[i]),16,false);\n\t\t     }\n\t\t     return {\"symbol\":args[1],\n\t\t\t     \"symbol_type\":\"pm\",\n\t\t\t     \"pm_data\":rdata\n\t\t     };\n\t\t }},\n\t\t \"byte_ram\":{\"regex\":/^ *\\.byte\\(([a-zA-Z_][a-zA-Z0-9_]*)\\) ([-0-9, ]+) *$/,\"process\":function(args){\n\t\t     var rdata = args[2].split(\",\");\n\t\t     for(var i = 0; i < rdata.length; i++){\n\t\t\t rdata[i] = this.truncate(parseInt(rdata[i].trim()),8,false);\n\t\t     }\n\t\t     return {\"symbol\":args[1],\n\t\t\t     \"symbol_type\":\"ram\",\n\t\t\t     \"ram_data\":rdata\n\t\t     };\n\t\t }},\n\t\t \"string_ram\":{\"regex\":/^ *\\.string\\(([a-zA-Z_][a-zA-Z0-9_]*)\\) \"((?:[^\"\\\\]|\\\\.)*)\" *$/,\"process\":function(args){\n\t\t     var str = this.handle_string_escapes(args[2]);\n\t\t     var rdata = []\n\t\t     for(var i = 0; i < str.length; i++){\n\t\t\t rdata.push(this.truncate(str.charCodeAt(i),8,false));\n\t\t     }\n\t\t     rdata.push(0);\n\t\t     return {\"symbol\":args[1],\n\t\t\t     \"symbol_type\":\"ram\",\n\t\t\t     \"ram_data\":rdata\n\t\t     };\n\t\t     \n\t\t }}\n\t     },\n\t     formats: {\n\t\t \"4r8i\":{\n\t\t     \"string\":/ *r([0-9]+), *()(-?[a-zA-Z_0-9)(-]+|'..?') *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" r\" + r + \",\"+i;},\n\t\t     \"binary\":\"CCCCIIIIRRRRIIII\",\n\t\t     \"i_bits\":8,\n\t\t     \"validator\":function(c, r, s, i){return 16 <= r && r < 32 && -128 <= i && i < 256;}},\n\t\t \"5r5s\":{\n\t\t     \"string\":/ *r([0-9]+), *r([0-9]+)() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" r\" + r + \",r\"+s;},\n\t\t     \"binary\":\"CCCCCCSRRRRRSSSS\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= r && r < 32 && 0 <= s && s < 32;}},\n\t\t \"6s5r\":{\n\t\t     \"string\":/ *r([0-9]+), *([0-9]+)() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" r\" + r + \",\"+s;},\n\t\t     \"binary\":\"CCCCCSSRRRRRSSSS\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= r && r < 32 && 0 <= s && s < 64;}},\n\t\t \"5r6s\":{\n\t\t     \"string\":/ *([0-9]+), *r([0-9]+)() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" \" + r + \",r\"+s;},\n\t\t     \"binary\":\"CCCCCSSRRRRRSSSS\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= r && r < 64 && 0 <= s && s < 32;}},\n\t\t \"5r\":{\n\t\t     \"string\":/ *r([0-9]+)()() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" r\" + r;},\n\t\t     \"binary\":\"CCCCCCCRRRRRCCCC\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= r && r < 32;}},\n\t\t \"5rX\":{\n\t\t     \"string\":/ *r([0-9]+)(), *(-[XYZ]|[XYZ]|[XYZ]\\+) *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i,x){return mnemonic + \" r\" + r + \",\"+i},\n\t\t     \"binary\":\"CCCXCCCRRRRRXXXX\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= r && r < 32;}},\n\t\t \"X5r\":{\n\t\t     \"string\":/ *(-[XYZ]|[XYZ]|[XYZ]\\+), *r([0-9]+)() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i,x){return mnemonic + \" \" + r + \",r\"+s;},\n\t\t     \"binary\":\"CCCXCCCRRRRRXXXX\",\n\t\t     \"validator\":function(c, r, s, i){return 0 <= s && s < 32;}},\n\t\t \"12i\":{\n\t\t     \"string\":/ *()()(-?[a-zA-Z_0-9)(]+) *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" \" + i;},\n\t\t     \"binary\":\"CCCCIIIIIIIIIIII\",\n\t\t     \"i_bits\":12,\n\t\t     \"validator\":function(c, r, s, i){return -2048 <= i && i < 2048;}},\n\t\t \"7i\":{\n\t\t     \"string\":/ *()()(-?[a-zA-Z_0-9)(]+) *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic + \" \" + i;},\n\t\t     \"binary\":\"CCCCCCIIIIIIICCC\",\n\t\t     \"i_bits\":7,\n\t\t     \"validator\":function(c, r, s, i){return -64 <= i && i < 64;}},\n\t\t \"n\":{\n\t\t     \"string\":/ *()()() *$/,\n\t\t     \"to_string\":function(mnemonic,c,r,s,i){return mnemonic;},\n\t\t     \"binary\":\"CCCCCCCCCCCCCCCC\",\n\t\t     \"validator\":function(c, r, s, i){return true;}}\n\t     },\n\t     instructions: {\n\t\t \"ldi\":{\"format\":\"4r8i\", \"c\": 14, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     console.log('T',emu);\n\t\t     emu.RF[r] = emu.truncate(i,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"mov\":{\"format\":\"5r5s\", \"c\": 11, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.RF[r] = emu.RF[s];\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"add\":{\"format\":\"5r5s\", \"c\": 3, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] + emu.RF[s], true, true, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] + emu.RF[s],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"adc\":{\"format\":\"5r5s\", \"c\": 7, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     var oldC = emu.C;\n\t\t     emu.update_sreg(emu.RF[r] + emu.RF[s] + oldC, true, true, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] + emu.RF[s] + oldC,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"sbc\":{\"format\":\"5r5s\", \"c\": 2, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     var oldC = emu.C;\n\t\t     emu.update_sreg(emu.RF[r] - emu.RF[s] - oldC, true, true, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] - emu.RF[s] - oldC,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"sub\":{\"format\":\"5r5s\", \"c\": 6, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] - emu.RF[s], true, true, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] - emu.RF[s],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"cp\":{\"format\":\"5r5s\", \"c\": 5, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] - emu.RF[s], true, true, true);\n\t\t     emu.C = emu.truncate(emu.RF[r],8,true) < emu.truncate(emu.RF[s],8,true) ? 1 : 0; // HACK TO MATCH PRESENTATION\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"and\":{\"format\":\"5r5s\", \"c\": 8, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] & emu.RF[s], true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] & emu.RF[s],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"or\":{\"format\":\"5r5s\", \"c\": 10, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] | emu.RF[s], true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] | emu.RF[s],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"eor\":{\"format\":\"5r5s\", \"c\": 9, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] ^ emu.RF[s], true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] ^ emu.RF[s],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r, \"PC\", \"Z\", \"C\", \"N\"];}},\n\t\t \"cpi\":{\"format\":\"4r8i\", \"c\": 3, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] - i, true, true, true);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"Z\",\"C\",\"N\"];}},\n\t\t \"subi\":{\"format\":\"4r8i\", \"c\": 5, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] - i, true, true, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] - i,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"Z\",\"C\",\"N\"];}},\n\t\t \"andi\":{\"format\":\"4r8i\", \"c\": 7, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] & i, true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] & i,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"Z\",\"C\",\"N\"];}},\n\t\t \"ori\":{\"format\":\"4r8i\", \"c\": 6, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] | i, true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] | i,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"Z\",\"C\",\"N\"];}},\n\t\t \"dec\":{\"format\":\"5r\", \"c\": 1194, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] - 1, true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] - 1,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"inc\":{\"format\":\"5r\", \"c\": 1187, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(emu.RF[r] + 1, true, false, true);\n\t\t     emu.RF[r] = emu.truncate(emu.RF[r] + 1,8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"neg\":{\"format\":\"5r\", \"c\": 1185, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(-emu.RF[r], true, true, true);\n\t\t     emu.RF[r] = emu.truncate(-emu.RF[r],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"com\":{\"format\":\"5r\", \"c\": 1184, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.update_sreg(~(emu.RF[r]), true, false, true);\n\t\t     emu.RF[r] = emu.truncate(~(emu.RF[r]),8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"ld\":{\"format\":\"5rX\", \"c\": 32, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     var reg = 0;\n\t\t     if(i == \"X\" || i == \"-X\" || i == \"X+\") reg = 26;\n\t\t     if(i == \"Y\" || i == \"-Y\" || i == \"Y+\") reg = 28;\n\t\t     if(i == \"Z\" || i == \"-Z\" || i == \"Z+\") reg = 30;\n\t\t     if(i[0] == \"-\"){\n\t\t\t emu.updated.push(reg);\n\t\t\t emu.dec_ptr(reg);\n\t\t     }\n\t\t     var ptr = emu.truncate(emu.RF[reg],8,false)+256*emu.truncate(emu.RF[reg+1],8,false);\n\t\t     emu.updated = [r,\"PC\"];\n\t\t     emu.RF[r] = emu.truncate(emu.RAM[ptr],8,false);\n\t\t     if(i[1] == \"+\"){\n\t\t\t emu.updated.push(reg);\n\t\t\t emu.inc_ptr(reg);\n\t\t     }\n\t\t     emu.ram_updated = [];\n\t\t     emu.PC++;}},\n\t\t \"st\":{\"format\":\"X5r\", \"c\": 33, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     i = r;\n\t\t     r = s;\n\t\t     var reg = 0;\n\t\t     if(i == \"X\" || i == \"-X\" || i == \"X+\") reg = 26;\n\t\t     if(i == \"Y\" || i == \"-Y\" || i == \"Y+\") reg = 28;\n\t\t     if(i == \"Z\" || i == \"-Z\" || i == \"Z+\") reg = 30;\n\t\t     if(i[0] == \"-\"){\n\t\t\t emu.updated.push(reg);\n\t\t\t emu.dec_ptr(reg);\n\t\t     }\n\t\t     var ptr = emu.truncate(emu.RF[reg],8,false)+256*emu.truncate(emu.RF[reg+1],8,false);\n\t\t     emu.updated = [\"PC\"];\n\t\t     emu.ram_updated = [ptr];\n\t\t     emu.RAM[ptr] = emu.RF[r];\n\t\t     emu.PC++;\n\t\t     if(i[1] == \"+\"){\n\t\t\t emu.updated.push(reg);\n\t\t\t emu.inc_ptr(reg);\n\t\t     }\n\t\t }},\n\t\t \"rjmp\":{\"format\":\"12i\", \"c\": 12, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC = emu.truncate(emu.PC + i + 1,16,false);\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"breq\":{\"format\":\"7i\", \"c\": 481, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC = emu.truncate(emu.PC + 1 + (emu.Z == 1 ? (i <= 64 ? i : i-128) : 0),16,false);\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"brne\":{\"format\":\"7i\", \"c\": 489, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC = emu.truncate(emu.PC + 1 + (emu.Z == 0 ? (i <= 64 ? i : i-128) : 0),16,false);\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"brsh\":{\"format\":\"7i\", \"c\": 488, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC = emu.truncate(emu.PC + 1 + (emu.C == 0 ? (i <= 64 ? i : i-128) : 0),16,false);\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"brlo\":{\"format\":\"7i\", \"c\": 480, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC = emu.truncate(emu.PC + 1 + (emu.C == 1 ? (i <= 64 ? i : i-128) : 0),16,false);\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"in\":{\"format\":\"6s5r\", \"c\": 22, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.RF[r] = emu.truncate(emu.read_IO(s),8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"out\":{\"format\":\"5r6s\", \"c\": 23, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     i = s;\n\t\t     s = r;\n\t\t     r = i;\n\t\t     emu.write_IO(s,emu.RF[r]);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"asr\":{\"format\":\"5r\", \"c\": 1189, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     var C = emu.RF[r]%2 == 0 ? 0 : 1;\n\t\t     emu.RF[r] = emu.truncate(emu.truncate(emu.RF[r],8,true) >> 1,8,false);\n\t\t     emu.update_sreg(emu.RF[r], true, false, true);\n\t\t     emu.C = C;\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [r,\"PC\"];}},\n\t\t \"push\":{\"format\":\"5r\", \"c\": 1183, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     emu.RAM[SP] = emu.RF[r];\n\t\t     emu.decSP();\n\t\t     emu.PC++;\n\t\t     emu.updated = [\"PC\",\"SPH\",\"SPL\"];\n\t\t     emu.ram_updated = [SP];}},\n\t\t \"pop\":{\"format\":\"5r\", \"c\": 1167, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.incSP();\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     emu.RF[r] = emu.truncate(emu.RAM[SP],8,false);\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"SPH\",\"SPL\"];}},\n\t\t \"rcall\":{\"format\":\"12i\", \"c\": 13, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC++;\n\t\t     var PCL = emu.PC % 256;\n\t\t     var PCH = Math.floor(emu.PC / 256);\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     emu.RAM[SP] = PCH;\n\t\t     emu.decSP();\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     emu.RAM[SP] = PCL;\n\t\t     emu.decSP();\n\t\t     emu.PC = emu.truncate(emu.PC + i,16,false);\n\t\t     emu.updated = [\"PC\",\"SPH\",\"SPL\"];\n\t\t     emu.ram_updated = [SP];}},\n\t\t \"ret\":{\"format\":\"n\", \"c\": 38152, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.incSP();\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     var PCL = emu.RAM[SP];\n\t\t     emu.incSP();\n\t\t     var SP = emu.SPH * 256 + emu.SPL;\n\t\t     var PCH = emu.RAM[SP];\n\t\t     emu.PC = PCL + 256*PCH;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\",\"SPH\",\"SPL\"];}},\n\t\t \"nop\":{\"format\":\"n\", \"c\": 0, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.PC++;\n\t\t     emu.ram_updated = [];\n\t\t     emu.updated = [\"PC\"];}},\n\t\t \"halt\":{\"format\":\"n\", \"c\": 1, \"exec\":function(c, r, s, i){\n\t\t     var emu = this.parent;\n\t\t     emu.end();}}\n\t     }\n\t }\n     },\n     methods: {\n\t smul: function(str, num) {\n\t     var acc = [];\n\t     for (var i = 0; (1 << i) <= num; i++) {\n\t\t if ((1 << i) & num)\n\t\t     acc.push(str);\n\t\t str += str;\n\t     }\n\t     return acc.join(\"\");\n\t },\n\t do_nothing: function(a){},\n\t cm_setup: function(){\n\t     var sim_textarea = document.getElementById(\"simavr\"+this.simid+\"_program_area\");\n\t     this.debug_log(this.simid,sim_textarea);\n\t     if(sim_textarea == null) return;\n\t     this.editor = CodeMirror.fromTextArea(sim_textarea, {\n\t\t lineNumbers: true,\n\t\t gutters: [\"breakpoints\", \"CodeMirror-linenumbers\"]\n\t     });\n\t     if(this.size){\n\t\t if(this.size == \"auto\"){\n\t\t     this.editor.setSize(null, (this.program.split(\"\\n\").length + 2)*(this.editor.defaultTextHeight()) + 10);\n\t\t }\n\t\t else{\n\t\t     this.editor.setSize(null, this.size);\n\t\t }\n\t     }\n\t     else{\n\t\t this.editor.setSize(null, \"70%\");\n\t     }\n\t     this.editor.setOption(\"extraKeys\", {\n\t\t 'Ctrl-Enter': function(cm) {\n                     this.program_pm();\n                     this.$apply();\n\t\t }\n\t     });\n\t     this.editor.setValue(this.program);\n\t },\n\t reset_program: function(){\n\t     if(this.running) return;\n\t     if(this.text){\n\t\t this.debug_log(\"Using text\");\n\t\t this.program = this.text;\n\t     }\n\t     else if(this.original_program){\n\t\t this.program = this.original_program;\n\t     }\n\t     this.change_program(this.program);\n\t },\n\t reset: function(pm_reset){\n\t     this.io_state.switch_state = [\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\",\"OFF\"];\n\t     this.output_type.selection = \"program\";\n\t     this.display_pm_start = 0;\n\t     this.display_ram_start = 0;\n\t     this.steps = {'count':1};\n\t     this.PC = 0;\n\t     this.Z = 0;\n\t     this.C = 0;\n\t     this.N = 0;\n\t     this.PIND = 0;\n\t     this.PORTD = 0;\n\t     this.DDRD = 0;\n\t     this.SPH = 0;\n\t     this.SPL = 0;\n\t     this.updated = [];\n\t     this.ram_updated = [];\n\t     this.outputs = [];\n\t     this.mux = new this.output_mux();\n\t     for(var i = 0; i < this.RF_size; i++) this.RF[i] = 0;\n\t     for(var i = 0; i < this.RAM_size; i++) this.RAM[i] = 0;\n\t     for(var i = 0; i < this.IORF_size; i++) this.IORF[i] = 0;\n\t     var nop = this.parse(\"nop\",0);\n\t     if(pm_reset){ for(var i = 0; i < this.PM_size; i++){ nop.addr = i; this.PM[i] = nop; }}\n\t     if(!pm_reset){ for(var i = 0; i < this.current_ram_data.length; i++) this.RAM[i+1024] = this.current_ram_data[i]; }\n\t     if(this.editor) this.editor.removeLineClass(this.error_line, \"background\", \"active_line\");\n\t },\n\t change_program: function(prog){\n\t     this.program = prog;\n\t     if(this.editor) this.editor.setValue(prog);\n\t },\n\t display_ram: function(i){\n\t     if(this.RAM_display_mode == \"d\"){\n\t\t return this.RAM[i];\n\t     }\n\t     else if(this.RAM_display_mode == \"2\"){\n\t\t return this.truncate(this.RAM[i],8,true);\n\t     }\n\t     else if(this.RAM_display_mode == \"c\"){\n\t\t return String.fromCharCode(this.RAM[i])\n\t     }\n\t },\n\t display_rf: function(i){\n\t     if(this.RF_display_mode == \"d\"){\n\t\t return this.truncate(this.RF[i],8,false);\n\t     }\n\t     if(this.RF_display_mode == \"2\"){\n\t\t return this.truncate(this.RF[i],8,true);\n\t     }\n\t     else if(this.RF_display_mode == \"b\"){\n\t\t var s = this.RF[i].toString(2);\n\t\t return smul(\"0\",8-s.length)+s;\n\t     }\n\t     else if(this.RF_display_mode == \"h\"){\n\t\t var s = this.RF[i].toString(16);\n\t\t return \"0x\"+smul(\"0\",2-s.length)+s;\n\t     }\n\t },\n\t program_pm: function(){\n\t     if(this.running) return;\n\t     this.reset(true);\n\t     this.running = true;\n\t     this.program = this.editor.getValue();\n\t     var pm_data = this.preparse(this.program);\n\t     if(!pm_data){\n\t\t this.running = false;\n\t\t return;\n\t     }\n\t     var pm_addr = 0;\n\t     for(var i = 0; i < pm_data.length; i++){\n\t\t var datum = pm_data[i];\n\t\t if(datum.inst){\n\t\t     var inst = this.parse(datum.inst,pm_addr);\n\t\t     if(!inst) continue;\n\t\t     if(inst.error){\n\t\t\t this.error_on_line(datum.line, inst.error);\n\t\t\t return;\n\t\t     }\n\t\t     this.PM[pm_addr] = inst;\n\t\t     pm_addr++;\n\t\t }\n\t\t else if(datum.word){\n\t\t     var inst = this.decode(datum.word,pm_addr);\n\t\t     if(inst.error){\n\t\t\t this.error_on_line(datum.line, inst.error);\n\t\t\t return;\n\t\t     }\n\t\t     this.PM[pm_addr] = inst;\n\t\t     pm_addr++;\n\t\t }\n\t     }\n\t     this.status = \"Ready\";\n\t },\n\t error_on_line: function(linenum, err_msg){\n\t     this.running = false;\n\t     this.status = \"Error on line \" + linenum + \": \" + err_msg;\n\t     this.error_line = linenum;\n\t     if(this.editor) this.editor.addLineClass(linenum, \"background\", \"active_line\");\n\t },\n\t preparse: function(){\n\t     var lines = this.program.split(\"\\n\");\n\t     var to_program = [];\n\t     var pm_offset = 0;\n\t     var ram_offset = 1024;\n\t     for(var i = 0; i < lines.length; i++){\n\t\t var pieces = lines[i].match(/^((?:[^\";]|';'|\"(?:[^\\\\\"]+|\\\\(?:\\\\\\\\)*[nt\\\\\"])*\")*)(;.*)?$/)\n\t\t this.debug_log(\"P\",pieces);\n\t\t if(!pieces){\n\t\t     this.error_on_line(i, \"Invalid line: \"+i);\n\t\t     return;\n\t\t }\n\t\t if(!pieces[1]) continue;\n\t\t lines[i] = pieces[1].trim();\n\t\t var is_inst = true;\n\t\t for(var d in this.directives){\n\t\t     var matches = lines[i].match(this.directives[d].regex)\n\t\t     this.debug_log(\"D\",lines[i],d,matches);\n\t\t     if(matches){\n\t\t\t // process needs to return:\n\t\t\t // - What it inserts to PM (pm_data)\n\t\t\t // - What it inserts into RAM (ram_data)\n\t\t\t // - What symbol it wants to make (symbol)\n\t\t\t // - What kind of symbol it is (symbol_type == \"pm\" | \"ram\")\n\t\t\t // - Whether there was an error (error)\n\t\t\t \n\t\t\t var result = this.directives[d].process(matches);\n\n\t\t\t // Handle error\n\t\t\t if(result.error){\n\t\t\t     this.error_on_line(i, result.error);\n\t\t\t     return;\n\t\t\t }\n\n\t\t\t // Update symbol\n\t\t\t if(result.symbol && result.symbol_type){\n\t\t\t     if(result.symbol_type == \"pm\"){\n\t\t\t\t this.symbols[result.symbol] = pm_offset;\n\t\t\t     }\n\t\t\t     else if(result.symbol_type == \"ram\"){\n\t\t\t\t this.symbols[result.symbol] = ram_offset;\n\t\t\t     }\n\t\t\t }\n\t\t\t \n\t\t\t // Insert data and update offsets\n\t\t\t if(result.pm_data){\n\t\t\t     for(var j = 0; j < result.pm_data.length; j++){\n\t\t\t\t to_program.push({'word':result.pm_data[j],'line':i});\n\t\t\t     }\n\t\t\t     pm_offset += result.pm_data.length;\n\t\t\t }\n\t\t\t if(result.ram_data){\n\t\t\t     for(var j = 0; j < result.ram_data.length; j++){\n\t\t\t\t this.RAM[ram_offset + j] = result.ram_data[j];\n\t\t\t     }\n\t\t\t     this.current_ram_data = this.current_ram_data.concat(result.ram_data);\n\t\t\t     ram_offset += result.ram_data.length;\n\t\t\t }\n\t\t\t is_inst = false;\n\t\t\t break;\n\t\t     }\n\t\t }\n\t\t if(is_inst && !(/^[ \\t]*$/.test(lines[i]))){\n\t\t     to_program.push({'inst':lines[i],'line':i});\n\t\t     pm_offset++;\n\t\t }\n\t     }\n\t     return to_program;\n\t },\n\t parse: function(inst,addr){\n\t     this.debug_log(inst)\n\t     var matches = inst.match(/^[ \\t]*([a-zA-Z]+)[ \\t]*((?:[^;]|';')*)[ \\t]*$/)\n\t     if(!matches){\n\t\t return {\"error\":\"Line does not match any directive or instruction\"};\n\t     }\n\t     var mnemonic = matches[1];\n\t     var operand = matches[2];\n\t     this.debug_log(mnemonic, \"|||\", operand);\n\t     if(mnemonic in this.instructions){\n\t\t var format = this.instructions[mnemonic].format;\n\t\t var execf = this.instructions[mnemonic].exec;\n\t\t var ops = operand.match(this.formats[format].string);\n\t\t if(!ops){\n\t\t     return {\"error\":\"Operands to instruction \" + inst + \" did not parse\"};\n\t\t }\n\t\t for(var i = 0; i < 3; i++){\n\t\t     if(/^[0-9]+$/.test(ops[i])) ops[i] = parseInt(ops[i]);\n\t\t     //else if(format.sym_valid[i]) ops[i] = symbols[ops[i]];\n\t\t }\n\t\t var opcode = this.instructions[mnemonic].c;\n\t\t this.debug_log(format, execf, ops, opcode);\n\t\t var data = {\"r\":ops[1],\"s\":ops[2],\"i\":ops[3],\"c\":opcode};\n\t\t var new_inst = new this.instruction(mnemonic + \" \" + operand, mnemonic, data, execf,addr, this);\n\t\t if(new_inst.error){\n\t\t     return {\"error\":inst.error};\n\t\t }\n\t\t if(new_inst.check_valid()){\n\t\t     return new_inst;\n\t\t }\n\t\t else{\n\t\t     return {\"error\":\"Illegal operands to instruction \" + inst};\n\t\t }\n\t     }\n\t     else{\n\t\t return {\"error\":\"Invalid instruction \" + inst};\n\t     }\n\t     return null;\n\t },\n\t is_updated: function(x){\n\t     for(var i = 0; i < this.updated.length; i++){\n\t\t if(this.updated[i] == x) return true;\n\t     }\n\t     return false;\n\t },\n\t is_ram_updated: function(x){\n\t     for(var i = 0; i < this.updated.length; i++){\n\t\t if(this.ram_updated[i] == x) return true;\n\t     }\n\t     return false;\n\t },\n\t handle_string_escapes: function(s){\n\t     s = s.replace(/(([^\\\\]|)(\\\\\\\\)*)\\\\t/g,\"$1\\t\");\n\t     s = s.replace(/(([^\\\\]|)(\\\\\\\\)*)\\\\n/g,\"$1\\n\");\n\t     s = s.replace(/(([^\\\\]|)(\\\\\\\\)*)\\\\\"/g,\"$1\\\"\");\n\t     s = s.replace(/\\\\\\\\/g,\"\\\\\");\n\t     return s;\n\t },\n\n\t // X,*:  111\n\t // Y,\"\": 010\n\t // Y,+-\" 110\n\t // Z,\"\": 000\n\t // Z,+-: 100\n\t // \"\":  00\n\t // \"+\": 01\n\t // \"-\": 10\n\t encode_x: function(i){\n\t     var x = 0;\n\t     var ptr = i[0] == \"-\" ? i[1] : i[0];\n\t     var mod = i[0] == \"-\" ? \"-\" : (i[1] == \"+\" ? \"+\" : \"\");\n\t     if(ptr == \"X\") x = 7*4\n\t     if(ptr == \"Y\") x = 6*4\n\t     if(ptr == \"Z\") x = 4*4\n\t     if(ptr != \"X\" && mod == \"\") x -= 16;\n\t     if(mod == \"+\") x += 1;\n\t     if(mod == \"-\") x += 2;\n\t     return x;\n\t },\n\t decode_x: function(x){\n\t     var ptr = \"\";\n\t     var mod = \"\";\n\t     this.debug_log(\"XX\",x,x&3,(x>>2)&3)\n\t     if(((x >> 2)&3) == 3) ptr = \"X\";\n\t     if(((x >> 2)&3) == 2) ptr = \"Y\";\n\t     if(((x >> 2)&3) == 0) ptr = \"Z\";\n\t     if((x&3) == 1) mod = \"+\";\n\t     if((x&3) == 2) mod = \"-\";\n\t     this.debug_log(\"X=\",mod,ptr)\n\t     return mod == \"-\" ? mod +\"\"+ ptr : ptr +\"\"+ mod;\n\t },\n\t encode: function(format, c, r, s, i){\n\t     var fmt = this.formats[format].binary;\n\t     var inst = 0;\n\t     var x = 0;\n\t     if(format == \"5r6s\"){\n\t\t i = s;\n\t\t s = r;\n\t\t r = i;\n\t     }\n\t     else if(format == \"5rX\" || format == \"X5r\"){\n\t\t if(format == \"X5r\"){\n\t\t     i = r;\n\t\t     r = s;\n\t\t }\n\t\t this.debug_log(\"Xe\",i);\n\t\t x = this.encode_x(i);\n\t\t this.debug_log(\"Xd\",x);\n\t     }\n\t     for(var j = 15; j >= 0; j--) {\n\t\t if(fmt[j] == \"C\"){\n\t\t     inst += (c%2)<<(15-j);\n\t\t     c >>= 1;\n\t\t }\n\t\t if(fmt[j] == \"R\"){\n\t\t     inst += (r%2)<<(15-j);\n\t\t     r >>= 1;\n\t\t }\n\t\t if(fmt[j] == \"S\"){\n\t\t     inst += (s%2)<<(15-j);\n\t\t     s >>= 1;\n\t\t }\n\t\t if(fmt[j] == \"I\"){\n\t\t     inst += (i%2)<<(15-j);\n\t\t     i >>= 1;\n\t\t }\n\t\t if(fmt[j] == \"X\"){\n\t\t     inst += (x%2)<<(15-j);\n\t\t     x >>= 1;\n\t\t }\n\t     }\n\t     return inst;\n\t },\n\t decode: function(x,addr){\n\t     for(var f in this.formats){\n\t\t fmt = this.formats[f];\n\t\t var data = {\"c\":0,\"r\":0,\"s\":0,\"i\":0,\"x\":0}\n\t\t for(var j = 15; j >= 0; j--){\n\t\t     //this.debug_log(\"J\",j,fmt.binary[15-j],(x>>j)%2);\n\t\t     if(fmt.binary[15-j] == \"C\") data.c = (data.c * 2) + ((x >> j) % 2);\n\t\t     if(fmt.binary[15-j] == \"R\") data.r = (data.r * 2) + ((x >> j) % 2);\n\t\t     if(fmt.binary[15-j] == \"S\") data.s = (data.s * 2) + ((x >> j) % 2);\n\t\t     if(fmt.binary[15-j] == \"I\") data.i = (data.i * 2) + ((x >> j) % 2);\n\t\t     if(fmt.binary[15-j] == \"X\") data.x = (data.x * 2) + ((x >> j) % 2);\n\t\t }\n\t\t if(f == \"4r8i\") data.r += 16;\n\t\t if(f == \"12i\") data.i = this.truncate(data.i,12,true);\n\t\t if(f == \"7i\") data.i = this.truncate(data.i,7,true);\n\t\t if(f == \"5rX\") data.i = this.decode_x(data.x);\n\t\t if(f == \"X5r\"){\n\t\t     data.s = data.r;\n\t\t     data.r = this.decode_x(data.x);\n\t\t }\n\t\t if(f == \"5r6s\"){\n\t\t     var temp = data.r;\n\t\t     data.r = data.s;\n\t\t     data.s = temp;\n\t\t }\n\t\t for(var mnemonic in this.instructions){\n\t\t     inst = this.instructions[mnemonic];\n\t\t     if(inst.format == f && inst.c == data.c){\n\t\t\t return new this.instruction(x,mnemonic,data,inst.exec,addr,this);\n\t\t     }\n\t\t }\n\t     }\n\t     return {\"error\":\"Could not decode instruction: \" + x};\n\t },\n\t label: function(name, addr){\n\t     this.label = true;\n\t     this.name = name;\n\t     this.addr = addr;\n\t },\n\t output_mux: function(){\n\t     this.SEL_ADDR = 0;\n\t     this.SEL_LEN = 255;\n\t     this.LCD_OUT = 1;\n\t     this.LB_OUT = 2;\n\t     this.target = 0;\n\t     this.len = 0;\n\t     this.state = 0;\n\t     this.input = function(val){\n\t\t if(this.state == this.SEL_ADDR) {\n\t\t     this.target = val;\n\t\t     this.state = this.SEL_LEN;\n\t\t }\n\t\t else if(this.state == this.SEL_LEN){\n\t\t     this.len = val;\n\t\t     this.state = this.target;\n\t\t     this.target = 0;\n\t\t }\n\t\t else if(this.len > 0){\n\t\t     if(this.state-1 < this.output_devs.length)\n\t\t\t this.output_devs.input(val);\n\t\t     this.len--;\n\t\t }\n\t\t else{\n\t\t     this.state = this.SEL_ADDR;\n\t\t }\n\t     }\n\t },\n\t lcd: function(){\n\t     this.input = function(val){\n\t\t \n\t     }\n\t },\n\t set_PM_display_mode: function(m){\n\t     this.PM_display_mode = m;\n\t },\n\t set_RAM_display_mode: function(m){\n\t     this.RAM_display_mode = m;\n\t },\n\t set_RF_display_mode: function(m){\n\t     this.RF_display_mode = m;\n\t },\n\t instruction: function(text, mnemonic, data, exec, addr, parent){\n\t     console.log(this);\n\t     this.parent = parent;\n\t     this.label = false;\n\t     this.addr = addr;\n\t     this.text = text;\n\t     this.c = data.c;\n\t     this.r = data.r;\n\t     this.s = data.s;\n\t     this.i = data.i;\n\t     this.exec = exec;\n\t     this.mnemonic = mnemonic;\n\t     console.log(this.text, this.c, this.r, this.s, this.i, this.mnemonic);\n\t     this.format = this.parent.instructions[this.mnemonic].format;\n\t     if(this.i.match){\n\t\t var matches = this.i.match(/(lo|hi)8\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)/);\n\t\t if(matches){\n\t\t     if(matches[2] in this.parent.symbols){\n\t\t\t if(matches[1] == \"lo\") this.i = this.parent.truncate(this.parent.symbols[matches[2]],8,false);\n\t\t\t if(matches[1] == \"hi\") this.i = this.parent.truncate(this.parent.symbols[matches[2]]>>8,8,false);\n\t\t     }\n\t\t     else{\n\t\t\t this.error = \"Symbol not found \" + matches[2];\n\t\t     }\n\t\t }\n\t\t else if(this.i in this.parent.symbols){\n\t\t     this.i = this.parent.symbols[this.i];\n\t\t     var fmt = this.parent.formats[this.format];\n\t\t     //this.parent.debug_log(this.parent.symbols,fmt.i_bits);\n\t\t     if(fmt.i_bits){\n\t\t\t this.i = this.parent.truncate(this.i - this.addr - 1,fmt.i_bits,true);\n\t\t     }\n\t\t }\n\t\t else if(/'[^'\\\\]'/.test(this.i)){\n\t\t     this.i = this.i.charCodeAt(1);\n\t\t }\n\t\t else if(this.i == \"'\\\\''\"){\n\t\t     this.i = this.i.charCodeAt(2);\n\t\t }\n\t\t else if(this.i == \"'\\\\\\\\'\"){\n\t\t     this.i = this.i.charCodeAt(2);\n\t\t }\n\t\t else if(this.i == \"'\\\\n'\"){\n\t\t     this.i = 10;\n\t\t }\n\t\t else if(this.i == \"'\\\\t'\"){\n\t\t     this.i = 9;\n\t\t }\n\t\t else if(/^[XYZ]$|^[XYZ]\\+$|^-[XYZ]$/.test(this.i)){\n\t\t     this.i = this.i;\n\t\t }\n\t\t else this.i = parseInt(this.i);\n\t     }\n\t     this.encoding = this.parent.encode(this.format, this.c, this.r, this.s, this.i < 0 ? this.parent.truncate(this.i,this.parent.formats[this.format].i_bits,false) : this.i);\n\t     //this.debug_log(this.text, this.c, this.r, this.s, this.i, this.mnemonic);\n\t     var self = this;\n\t     this.display = function(){\n\t\t if(this.parent.PM_display_mode == \"t\"){\n\t\t     return this.parent.formats[self.format].to_string(self.mnemonic,self.c,self.r,self.s,self.i);\n\t\t }\n\t\t else if(this.parent.PM_display_mode == \"d\"){\n\t\t     return self.encoding;\n\t\t }\n\t\t else if(this.parent.PM_display_mode == \"h\"){\n\t\t     var s = self.encoding.toString(16);\n\t\t     return \"0x\"+this.parent.smul(\"0\",4 - s.length)+s;\n\t\t }\n\t\t else if(this.parent.PM_display_mode == \"b\"){\n\t\t     var s = self.encoding.toString(2);\n\t\t     return this.parent.smul(\"0\",16 - s.length) + s;\n\t\t }\n\t     }\n\t     this.check_valid = function(){\n\t\t return this.parent.formats[self.format].validator(self.c, self.r, self.s, self.i);\n\t     }\n\t     this.run = function(){\n\t\t self.exec(self.c, self.r, self.s, self.i);\n\t     }\n\t },\n\t step: function(){\n\t     if(!this.running) return;\n\t     this.debug_log(this.steps.count);\n\t     for(var k = 0; k < this.steps.count; k++){\n\t\t var i = this.PM[this.PC];\n\t\t this.debug_log(\"i\",i);\n\t\t i.run();\n\t\t if(this.PC < this.display_pm_start || this.PC >= this.display_pm_start + this.display_pm_length){\n\t\t     this.display_pm_start = Math.max(0, this.PC - this.display_ram_length/2);\n\t\t }\n\t\t if(this.ram_updated.length > 0){\n\t\t     this.display_ram_start = Math.max(0, Math.min.apply(Math, this.ram_updated) - this.display_ram_length/2);\n\t\t }\n\t     }\n\t },\n\t raise_error: function(s){\n\t     this.status = \"Error: \" + s;\n\t },\n\t truncate: function(num, bits, twos_complement){\n\t     var mod = 1<<bits;\n\t     num = ((num % mod)+mod)%mod;\n\t     return twos_complement ? (num >= 1<<(bits - 1) ? num - (1<<bits) : num) : num;\n\t },\n\t update_sreg: function(result, z, c, n){\n\t     this.debug_log(\"SREG for\",result);\n\t     if(z) this.Z = this.truncate(result,8,false) == 0 ? 1 : 0;\n\t     if(c) this.C = result >= 256 || result < 0 ? 1 : 0;\n\t     if(n) this.N = this.truncate(result,8,true) <0 ? 1 : 0;\n\t },\n\t read_IO: function(s){\n\t     if(s == 16) return this.PIND & (~(this.DDRD));\n\t     else if(s == 17) return this.DDRD;\n\t     else if(s == 61) return this.SPL;\n\t     else if(s == 62) return this.SPH;\n\t     return 0;\n\t },\n\t write_IO: function(s,val){\n\t     if(s == 18){\n\t\t this.PORTD = this.DDRD & val;\n\t\t this.output();\n\t     }\n\t     else if(s == 17) this.DDRD = this.truncate(val,8,false);\n\t     else if(s == 61) this.SPL = this.truncate(val,8,false);\n\t     else if(s == 62) this.SPH = this.truncate(val,8,false);\n\t     if(this.output_type.selection == \"simple\"){\n\t\t this.PIND = 0;\n\t\t for(var i = 0; i < 8; i++)\n\t\t     this.PIND |= (this.io_state.switch_state[i] == \"ON\" ? 1 << i : 0)\n\t\t this.PIND &= ~this.DDRD;\n\t     }\n\t },\n\t inc_ptr: function(reg){\n\t     if(this.RF[reg] == -1 || this.RF[reg] == 255){\n\t\t this.RF[reg] = 0\n\t\t this.RF[reg+1] = this.truncate(this.RF[reg+1]+1,8,false);\n\t     }\n\t     else this.RF[reg]++;\n\t     if(this.RF[reg] == 128){\n\t\t this.RF[reg] = -128;\n\t     }\n\t },\n\t dec_ptr: function(reg){\n\t     this.RF[reg]--;\n\t     if(this.RF[reg] == -1){\n\t\t this.RF[reg+1] = this.truncate(this.RF[reg+1]-1,8,false);\n\t     }\n\t     if(this.RF[reg] < -128){\n\t\t this.RF[reg] = 127;\n\t     }\n\t },\n\t incSP: function(){\n\t     this.SPL++;\n\t     if(this.SPL == 256){\n\t\t this.SPL = 0;\n\t\t this.SPH = this.truncate(this.SPH+1,8,false);\n\t     }\n\t },\n\t decSP: function(){\n\t     this.SPL--;\n\t     if(this.SPL == -1){\n\t\t this.SPL = 255;\n\t\t this.SPH = this.truncate(this.SPH-1,8,false);\n\t     }\n\t },\n\t io_switch: function(i){\n\t     if(this.io_state.switch_state[i] == \"ON\"){\n\t\t this.io_state.switch_state[i] = \"OFF\";\n\t\t this.PIND &= ~(1<<i);\n\t     }\n\t     else if(this.io_state.switch_state[i] == \"OFF\"){\n\t\t this.io_state.switch_state[i] = \"ON\";\n\t\t this.PIND |= 1<<i;\n\t     }\n\t     this.PIND = this.PIND & ~this.DDRD;\n\t },\n\t output: function(){\n\t     var out_val = this.PORTD;\n\t     this.outputs.push(out_val);\n\t     //this.outputs.push(String.fromCharCode(out_val));\n\t },\n\t initialize: function(){\n\t     this.reset_program();\n\t     this.cm_setup();\n\t },\n\t end: function(){\n\t     if(!this.running) return;\n\t     this.running = false;\n\t     setTimeout(this.cm_setup, 0);\n\t }\n\n     },\n     created: function(){\n\t console.log(\"init\");\n\t this.$store.dispatch(\"RESET_PLUGIN_DATA\",\"math\");\n\t //Guppy.init({\"path\":\"/node_modules/guppy-js\",\"symbols\":\"/node_modules/guppy-js/sym/symbols.json\"});\n     }, \n     mounted: function(){\n\t console.log(\"Hello JSAVR\");\n\t console.log(this.instructions);\n\t this.program = this.root.innerHTML.trim();\n\t this.reset(true);\n\t this.original_program = this.program;\n\t this.initialize();\n\n\t this.debug_log = this.debug_mode_feature == 'yes' ? console.log.bind(console) : this.do_nothing;\n\t if(this.control){\n\t     this.control.set_program = function(new_prog){\n\t\t this.change_program(new_prog);\n\t     }\n\t     this.control.get_program = function(){\n\t\t if(this.editor) this.program = this.editor.getValue();\n\t\t return this.program;\n\t     }\n\t     this.control.get_PM = function(addr){\n\t\t return this.PM[addr].encoding;\n\t     }\n\t     this.control.get_RF = function(){\n\t\t return this.RF;\n\t     }\n\t     this.control.get_RAM = function(addr){\n\t\t return this.RAM[addr];\n\t     }\n\t     this.control.get_other = function(){\n\t\t return {\n\t\t     \"PC\":this.PC,\n\t\t     \"Z\":this.Z,\n\t\t     \"C\":this.C,\n\t\t     \"N\":this.N,\n\t\t     \"DDRD\":this.DDRD,\n\t\t     \"PIND\":this.PIND,\n\t\t     \"PORTD\":this.PORTD,\n\t\t     \"SPL\":this.SPL,\n\t\t     \"SPH\":this.SPH\n\t\t }\n\t     }\n\t }\n\t /* \n\t  * \t \n\t  * \t var index = 0;\n\t  * \t var doc_id = node+\"-\"+index;\n\t  * \t var content = this.root.innerHTML.trim()\n\t  * \t console.log(\"R\",this.root,content);\n\t  * \t //var res = Guppy.Doc.render(content, \"text\");\n\t  * \t var res = {doc:content};\n\t  * \t var doc_data = {};\n\t  * \t //doc_data[index] = res.doc.get_vars().concat(res.doc.get_symbols());\n\t  * \t doc_data[index] = [\"x\"];\n\t  * \t //res.container.setAttribute(\"id\",\"category-math-container-\"+doc_id);\n\t  * \t //var rendered_content = (new XMLSerializer()).serializeToString(res.container);\n\t  * \n\t  * \t \n\t  * \t // Put this doc ID in the index for each var and symbol in the document\n\t  * \t for(var i = 0; i < this.docs[node][index].length; i++) {\n\t  * \t     var v = this.docs[node][index][i];\n\t  * \t     if (!this.index[v]) this.index[v] = [];\n\t  * \t     if (this.index[v].indexOf(doc_id) < 0) this.index[v].push(doc_id);\n\t  * \t }\n\t  * \n\t  * \t // Calculate the snippet that will be associated with this expression when it appears in listings\n\t  * \t var snippet = \"\";\n\t  * \t if(this.root.previousSibling){\n\t  * \t     snippet += this.root.previousSibling.textContent.split(\" \").slice(-4).join(\" \");\n\t  * \t }\n\t  * \t snippet += \" [formula] \"\n\t  * \n\t  * \t if(this.root.nextSibling) {\n\t  * \t     snippet += this.root.nextSibling.textContent.split(\" \").slice(0,4).join(\" \");\n\t  * \t }\n\t  * \t snippet = \"...\" + snippet + \"...\";\n\t  * \t console.log(\"parprev\",this.root.parentNode.previousSibling);\n\t  * \t console.log(\"parnext\",this.root.parentNode.nextSibling);\n\t  * \t this.snippets[doc_id] = snippet;\n\t  * \n\t  * \t // Finally, set up component attributes\n\t  * \t this.syms = this.docs[node][index];\n\t  * \t this.rendered = rendered_content;\n\t  * \t this.display_syms = false;\n\t  * \t this.id = doc_id;\n\t  * \t this.query = \"\";\n\t  * \t this.node = node;*/\n     }\n }\n</script>\n<style scoped>\n .simavr{\n     display:inline-block;\n     width:73em;\n     /* min-height:40em; */\n     font-size:10pt;\n }\n #simavr_rf{\n     float:left;\n     width:16em;\n     border:1px solid #aaa;\n     text-align:center;\n }\n\n #simavr_pm{\n     float:left;\n     width:13em;\n     border:1px solid #aaa;\n     text-align:center;\n }\n\n #simavr_ram{\n     float:left;\n     width:10em;\n     border:1px solid #aaa;\n     text-align:center;\n }\n\n #simavr_other{\n     float:left;\n     width:10em;\n     border:1px solid #aaa;\n     text-align:center;\n }\n\n .simavr_title{\n     width:100%;\n     text-align:center;\n     display:inline-block;\n     font-size:12pt;\n     margin:auto;\n     padding-bottom:5px;\n     line-height:2.5em;\n }\n\n .simavr_status{\n     display:inline-block;\n     padding:5px;\n     border-left:1px solid #aaa;\n     /* border-radius:5px; */\n     margin:5px;\n     width:45%;\n     font-size:9pt;\n     float:right;    \n }\n\n .active_line{\n     background-color:#f66;\n }\n .simavr_label{\n     font-size:10pt;\n     color:#333;\n     display:inline-block;\n     width:2em;\n }\n .simavr_label_long{\n     font-size:10pt;\n     color:#333;\n     display:inline-block;\n     margin-right:0.5ex;\n     min-width:2em;\n }\n\n .simavr_reg{\n     text-align:left;\n     display:inline-block;\n     padding:4px;\n     /*margin:0 2px 2px 0;*/\n     width:7em;\n }\n .simavr_pm{\n     text-align:left;\n     display:inline-block;\n     padding:4px;\n     /*margin:0 2px 2px 0;*/\n     width:12em;\n }\n\n .simavr_mem_start{\n     padding:4px;\n     width:4em;\n     margin:4px;\n }\n\n .simavr_ram{\n     text-align:left;\n     display:inline-block;\n     padding:4px;\n     /*margin:0 2px 2px 0;*/\n     width:7em;\n }\n\n .simavr_controls{\n     display:inline-block;\n     width:90%;\n     height:50px;\n     border: 2px solid #ccc;\n     margin:auto;\n     margin-bottom:5px;\n }\n\n .simavr_programming{\n     display:inline-block;\n     float:left;\n     width:70%;\n }\n\n .simavr_output_container{\n     display:inline-block;\n     float:left;\n     width:25%;\n }\n\n .simavr_simulator{\n     display:inline-block;\n     float:left;\n     width:75%;\n }\n\n .simavr_output{\n     display:inline-block;\n     padding:5px;\n     width:90%;\n     border:1px solid #aaa;\n     overflow-x:scroll;\n     overflow-y:scroll;\n }\n\n .simavr_program{\n     width:90%;\n }\n\n .simavr_normal{\n     background-color:#c66;\n }\n\n .simavr_updated{\n     background-color:#6c6;\n }\n\n .simavr_active{\n     background-color:#cc6;\n }\n\n .simavr_display_button{\n     display:inline-block;\n     padding:2px;\n }\n\n .simavr_enabled_button{\n     background-color:#66a;\n }\n\n .simavr_disabled_button{\n     background-color:#aaa;\n }\n\n .simavr_display_button:hover{\n     display:inline-block;\n     cursor:pointer;\n     color:#f33;\n }\n .simavr_button{\n     display:inline-block;\n     padding:8px;\n     border-radius:5px;\n     height:25px;\n     color:white;\n     margin:5px;\n     cursor:pointer;\n }\n\n .simavr_button:hover{\n     display:inline-block;\n     cursor:pointer;\n     color:#f33;\n }\n\n .simavr_io_num{\n     width:3em;\n     border:3px solid black;\n     background-color:#363;\n     color:#ff4;\n     font-size:17pt;\n     padding:5px;\n }\n\n .simavr_io_switch{\n     display:inline-block;\n     width:3em;\n     border:3px solid black;\n     font-size:17pt;\n     padding:5px;\n     cursor:pointer;\n }\n\n .simavr_io_switch_on{\n     background-color:#3f3;\n }\n\n .simavr_io_switch_off{\n     background-color:#f33;\n }\n</style>\n"]}, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__$h = "data-v-01dd48c1";
    /* module identifier */
    const __vue_module_identifier__$h = undefined;
    /* functional template */
    const __vue_is_functional_template__$h = false;
    /* style inject SSR */
    

    
    var JSAVRPlugin = normalizeComponent_1(
      { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
      __vue_inject_styles__$h,
      __vue_script__$g,
      __vue_scope_id__$h,
      __vue_is_functional_template__$h,
      __vue_module_identifier__$h,
      browser,
      undefined
    );

  /* parser generated by jison 0.4.18 */
  /*
    Returns a Parser object of the following structure:

    Parser: {
      yy: {}
    }

    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),

      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),

          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },

          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }


    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }


    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var query$1 = (function(){
  var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,5],$V2=[1,11],$V3=[1,6],$V4=[1,7],$V5=[1,8],$V6=[1,9],$V7=[1,10],$V8=[1,13],$V9=[1,14],$Va=[1,16],$Vb=[1,17],$Vc=[5,12,22,23],$Vd=[5,9,10,12,22,23],$Ve=[5,9,10,12,22,23,26];
  var parser = {trace: function trace () { },
  yy: {},
  symbols_: {"error":2,"query":3,"q":4,"EOF":5,"name":6,"HAS":7,"IS":8,":":9,"OF":10,"(":11,")":12,".":13,"BEFORE":14,"DATE":15,"AFTER":16,"=":17,"!":18,"[":19,"NUM":20,"]":21,",":22,"/":23,"words":24,"*":25,"STR":26,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",7:"HAS",8:"IS",9:":",10:"OF",11:"(",12:")",13:".",14:"BEFORE",15:"DATE",16:"AFTER",17:"=",18:"!",19:"[",20:"NUM",21:"]",22:",",23:"/",25:"*",26:"STR"},
  productions_: [0,[3,2],[4,1],[4,2],[4,2],[4,4],[4,4],[4,6],[4,6],[4,4],[4,3],[4,3],[4,2],[4,2],[4,4],[4,6],[4,3],[4,3],[4,3],[6,1],[6,1],[24,2],[24,1]],
  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
  /* this == yyval */

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1:
   return $$[$0-1]; 
  case 2:
  this.$ = ["name",$$[$0]];
  break;
  case 3:
  this.$ = ["edge",{"name":$$[$0],"dir":"has"}];
  break;
  case 4:
  this.$ = ["edge",{"name":$$[$0],"dir":"is"}];
  break;
  case 5:
  this.$ = ["edge",{"name":$$[$0-2],"dir":"has","query":["name",$$[$0]]}];
  break;
  case 6:
  this.$ = ["edge",{"name":$$[$0-3],"dir":"is","query":["name",$$[$0]]}];
  break;
  case 7:
  this.$ = ["edge",{"name":$$[$0-4],"dir":"has","query":$$[$0-1]}];
  break;
  case 8:
  this.$ = ["edge",{"name":$$[$0-5],"dir":"is","query":$$[$0-1]}];
  break;
  case 9:
  this.$ = ["propeq",[$$[$0-2],$$[$0]]];
  break;
  case 10:
  this.$ = ["before",$$[$0]];
  break;
  case 11:
  this.$ = ["after",$$[$0]];
  break;
  case 12:
  this.$ = ["exactly",$$[$0]];
  break;
  case 13:
  this.$ = ["not",[["name",$$[$0]]]];
  break;
  case 14:
  this.$ = ["not",[$$[$0-1]]];
  break;
  case 15:
  this.$ = ["nbhd",[$$[$0-4],parseInt($$[$0-1])]];
  break;
  case 16:
  this.$ = $$[$0-1];
  break;
  case 17:
  this.$ = ["and",[$$[$0-2], $$[$0]]];
  break;
  case 18:
  this.$ = ["or",[$$[$0-2], $$[$0]]];
  break;
  case 19:
  this.$ = $$[$0];
  break;
  case 20:
  this.$ = "*";
  break;
  case 21:
  this.$ = $$[$0-1] +" "+ $$[$0];
  break;
  case 22:
  this.$ = $$[$0];
  break;
  }
  },
  table: [{3:1,4:2,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},{1:[3]},{5:[1,15],22:$Va,23:$Vb},o($Vc,[2,2],{10:[1,18]}),{6:19,24:12,25:$V8,26:$V9},{6:20,24:12,25:$V8,26:$V9},{6:21,24:12,25:$V8,26:$V9},{9:[1,22]},{9:[1,23]},{6:24,24:12,25:$V8,26:$V9},{6:25,11:[1,26],24:12,25:$V8,26:$V9},{4:27,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},o($Vd,[2,19],{26:[1,28]}),o($Vd,[2,20]),o($Ve,[2,22]),{1:[2,1]},{4:29,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},{4:30,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},{9:[1,31]},o($Vc,[2,3],{9:[1,32]}),o($Vc,[2,4]),{9:[1,33]},{15:[1,34]},{15:[1,35]},o($Vc,[2,12]),o($Vc,[2,13]),{4:36,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},{12:[1,37],22:$Va,23:$Vb},o($Ve,[2,21]),o($Vc,[2,17]),o([5,12,23],[2,18],{22:$Va}),{6:38,11:[1,39],24:12,25:$V8,26:$V9},{6:40,11:[1,41],24:12,25:$V8,26:$V9},{6:42,24:12,25:$V8,26:$V9},o($Vc,[2,10]),o($Vc,[2,11]),{12:[1,43],22:$Va,23:$Vb},o($Vc,[2,16],{19:[1,44]}),o($Vc,[2,6]),{4:45,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},o($Vc,[2,5]),{4:46,6:3,7:$V0,8:$V1,11:$V2,13:$V3,14:$V4,16:$V5,17:$V6,18:$V7,24:12,25:$V8,26:$V9},o($Vc,[2,9]),o($Vc,[2,14]),{20:[1,47]},{12:[1,48],22:$Va,23:$Vb},{12:[1,49],22:$Va,23:$Vb},{21:[1,50]},o($Vc,[2,8]),o($Vc,[2,7]),o($Vc,[2,15])],
  defaultActions: {15:[2,1]},
  parseError: function parseError (str, hash) {
      if (hash.recoverable) {
          this.trace(str);
      } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
      }
  },
  parse: function parse(input) {
      var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
              sharedState.yy[k] = this.yy[k];
          }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
      } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
      }
      
          var lex = function () {
              var token;
              token = lexer.lex() || EOF;
              if (typeof token !== 'number') {
                  token = self.symbols_[token] || token;
              }
              return token;
          };
      var symbol, preErrorSymbol, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == 'undefined') {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
                      if (typeof action === 'undefined' || !action.length || !action[0]) {
                  var errStr = '';
                  expected = [];
                  for (p in table[state]) {
                      if (this.terminals_[p] && p > TERROR) {
                          expected.push('\'' + this.terminals_[p] + '\'');
                      }
                  }
                  if (lexer.showPosition) {
                      errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                  } else {
                      errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                      text: lexer.match,
                      token: this.terminals_[symbol] || symbol,
                      line: lexer.yylineno,
                      loc: yyloc,
                      expected: expected
                  });
              }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                  yyleng = lexer.yyleng;
                  yytext = lexer.yytext;
                  yylineno = lexer.yylineno;
                  yyloc = lexer.yylloc;
              } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                  yyval._$.range = [
                      lstack[lstack.length - (len || 1)].range[0],
                      lstack[lstack.length - 1].range[1]
                  ];
              }
              r = this.performAction.apply(yyval, [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
              ].concat(args));
              if (typeof r !== 'undefined') {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }};
  /* generated by jison-lex 0.3.4 */
  var lexer = (function(){
  var lexer = ({

  EOF:1,

  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },

  // resets the lexer, sets new input
  setInput:function (input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
          };
          if (this.options.ranges) {
              this.yylloc.range = [0,0];
          }
          this.offset = 0;
          return this;
      },

  // consumes and returns one char from the input
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) {
              this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
      },

  // unshifts one char (or a string) into the input
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
              this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;

          this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ?
                  (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                   + oldLines[oldLines.length - lines.length].length - lines[0].length :
                this.yylloc.first_column - len
          };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
      },

  // When called from action, caches matched text and appends it on next action
  more:function () {
          this._more = true;
          return this;
      },

  // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
  reject:function () {
          if (this.options.backtrack_lexer) {
              this._backtrack = true;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });

          }
          return this;
      },

  // retain first n characters of the match
  less:function (n) {
          this.unput(this.match.slice(n));
      },

  // displays already matched input, i.e. for error messages
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },

  // displays upcoming input, i.e. for error messages
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },

  // displays the character position where the lexing error occurred, i.e. for error messages
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
      },

  // test the lexed token: return FALSE when not a match, otherwise return token
  test_match:function(match, indexed_rule) {
          var token,
              lines,
              backup;

          if (this.options.backtrack_lexer) {
              // save context
              backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
              };
              if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
              }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno += lines.length;
          }
          this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ?
                           lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                           this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
              this.done = false;
          }
          if (token) {
              return token;
          } else if (this._backtrack) {
              // recover context
              for (var k in backup) {
                  this[k] = backup[k];
              }
              return false; // rule action called reject() implying the next rule should be tested instead.
          }
          return false;
      },

  // return next match in input
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) {
              this.done = true;
          }

          var token,
              match,
              tempMatch,
              index;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (this.options.backtrack_lexer) {
                      token = this.test_match(tempMatch, rules[i]);
                      if (token !== false) {
                          return token;
                      } else if (this._backtrack) {
                          match = false;
                          continue; // rule action called reject() implying a rule MISmatch.
                      } else {
                          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                          return false;
                      }
                  } else if (!this.options.flex) {
                      break;
                  }
              }
          }
          if (match) {
              token = this.test_match(match, rules[index]);
              if (token !== false) {
                  return token;
              }
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
              });
          }
      },

  // return next match that has a token
  lex:function lex () {
          var r = this.next();
          if (r) {
              return r;
          } else {
              return this.lex();
          }
      },

  // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
  begin:function begin (condition) {
          this.conditionStack.push(condition);
      },

  // pop the previously active lexer condition state off the condition stack
  popState:function popState () {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
              return this.conditionStack.pop();
          } else {
              return this.conditionStack[0];
          }
      },

  // produce the lexer rule set which is active for the currently active lexer condition state
  _currentRules:function _currentRules () {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
              return this.conditions["INITIAL"].rules;
          }
      },

  // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
  topState:function topState (n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
              return this.conditionStack[n];
          } else {
              return "INITIAL";
          }
      },

  // alias for begin(condition)
  pushState:function pushState (condition) {
          this.begin(condition);
      },

  // return the number of states currently on the stack
  stateStackSize:function stateStackSize() {
          return this.conditionStack.length;
      },
  options: {},
  performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
  switch($avoiding_name_collisions) {
  case 0:/* skip whitespace */
  break;
  case 1:return 18
  case 2:return 17
  case 3:return '-'
  case 4:return 25
  case 5:return 23
  case 6:return ';'
  case 7:return 9
  case 8:return 22
  case 9:return 13
  case 10:return 11
  case 11:return 12
  case 12:return 19
  case 13:return 21
  case 14:return 14
  case 15:return 16
  case 16:return 7
  case 17:return 8
  case 18:return 10
  case 19:return 'C'
  case 20:return 15
  case 21:return 20
  case 22:return 26
  case 23:return 5
  case 24:return 'INVALID'
  }
  },
  rules: [/^(?:\s+)/,/^(?:!)/,/^(?:=)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:;)/,/^(?::)/,/^(?:,)/,/^(?:\.)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:before\b)/,/^(?:after\b)/,/^(?:has\b)/,/^(?:is\b)/,/^(?:of\b)/,/^(?:c\b)/,/^(?:[0-9]{4}-[0-9]{2}-[0-9]{2})/,/^(?:[0-9][0-9]*)/,/^(?:(?!has)(?!of)(?!is)(?!before)(?!after)[^*;/,:.()! ]+)/,/^(?:$)/,/^(?:.)/],
  conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],"inclusive":true}}
  });
  return lexer;
  })();
  parser.lexer = lexer;
  function Parser () {
    this.yy = {};
  }
  Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();

  var intersect_lists = function(l1,l2){
      var ans = [];
      var l1_dict = {};
      for(var i = 0; i < l1.length; i++){
  	l1_dict[l1[i]] = true;
      }
      for(var j = 0; j < l2.length; j++){
  	if(l1_dict[l2[j]]) {
  	    ans.push(l2[j]);
  	}
      }
      return ans;
  };

  var union_lists = function(l1,l2){
      var result = [].concat(l1).concat(l2);
      var ans_dict = {};
      var ans = [];
      for(var i = 0; i < result.length; i++) {
  	ans_dict[result[i]] = true;
      }
      for(var x in ans_dict) {
  	ans.push(x);
      }
      return ans;
  };

  // removes everything in l2 from l1
  var remove_all = function(l1,l2){
      var result = [];
      for(var i = 0; i < l1.length; i++){
  	var found = false;
  	for(var j = 0; j < l2.length; j++){
  	    if(l1[i] == l2[j]){
  		found = true;
  		break;
  	    }
  	}
  	if(!found) result.push(l1[i]);
      }
      return result;
  };

  var date_from_string = function(d) {
      var arr = d.split("-");
      if(arr.length != 3) return null;
      return new Date(parseInt(arr[0]), parseInt(arr[1])-1, parseInt(arr[2]));
  };

  var neighbourhood = function(nodeset, steps, nodes, frontier) {
      if(steps <= 0) {
  	for(var n in frontier) {
  	    nodeset[n] = true;
  	}
  	return nodeset;
      }
      if(!frontier) {
  	frontier = nodeset;
  	nodeset = {};
      }
      // Check if the frontier is empty
      var no_new = true;
      for(var n in frontier) {
  	no_new = false;
  	break;
      }
      if(no_new) {
  	return nodeset;
      }
      var new_frontier = {};
      var new_nodeset = {};
      for(var n in nodeset) {
  	new_nodeset[n] = true;
      }
      for(var n in frontier) {
  	new_nodeset[n] = true;
      }
      for(var n in frontier) {
  	if(!(n in nodes)) continue;
  	for(var label in nodes[n].edges.has) {
  	    for(var edge of nodes[n].edges.has[label]) {
  		var target = edge.target;
  		if(!(target in new_nodeset)) {
  		    // if the target is not in the set we've visited or that we're visiting, we'll visit it on the next round
  		    new_frontier[target] = true;
  		}
  	    }
  	}
  	for(var label in nodes[n].edges.is) {
  	    for(var edge of nodes[n].edges.is[label]) {
  		var target = edge.target;
  		if(!(target in new_nodeset)) {
  		    // if the target is not in the set we've visited or that we're visiting, we'll visit it on the next round
  		    new_frontier[target] = true;
  		}
  	    }
  	}
      }
      return neighbourhood(new_nodeset, steps-1, nodes, new_frontier);
  };

  var search = function(q, nodes){
      console.log("Q",q);
      var result = [];
      if(!q || q.length == 0){
  	for(var n in nodes){
  	    result.push(n);
  	}
      }
      else if(q[0] == "and"){
  	result = search(q[1][0],nodes);
  	for(var i = 1; i < q[1].length; i++){
  	    console.log("q",q[1][i]);
  	    var nodeset = {};
  	    for(var n of result) {
  		if(n in nodes) {
  		    nodeset[n] = nodes[n];
  		}
  	    }
  	    console.log("NS",nodeset);
  	    res = search(q[1][i],nodeset);
  	    result = intersect_lists(result,res);
  	    console.log("AND RES",q[1][i],result);
  	}
      }
      else if(q[0] == "or"){
  	for(var i = 0; i < q[1].length; i++){
  	    var res = search(q[1][i],nodes);
  	    result = union_lists(result,res);
  	}
      }
      else if(q[0] == "not"){
  	result = Object.keys(nodes);
  	for(var i = 0; i < q[1].length; i++){
  	    var res = search(q[1][i],nodes);
  	    result = remove_all(result,res);
  	}
      }
      else if(q[0] == "edge"){
  	var edge = q[1];
  	var res = search(edge.query,nodes);
  	for(var i = 0; i < res.length; i++){
  	    var node_id = res[i];
  	    for(var n in nodes){
  		if(edge.name == "*"){
  		    var found = false;
  		    for(var label in nodes[n].edges[edge.dir]){
  			for(var e of nodes[n].edges[edge.dir][label]) {
  			    if(e.target == node_id) {
  				found = true;
  				result = union_lists(result,[n]);
  				break;
  			    }
  			    if(found) break;
  			}
  		    }
  		}
  		else if(edge.name in nodes[n].edges[edge.dir]) {
  		    for(var e of nodes[n].edges[edge.dir][edge.name]) {
  			if(e.target == node_id) {
  			    result = union_lists(result,[n]);
  			    break;
  			}
  		    }
  		    result = union_lists(result,[n]);
  		}
  	    }
  	}
      }
      else if(q[0] == "nbhd"){
  	var subquery = q[1][0];
  	var steps = q[1][1];
  	var res = search(subquery,nodes);
  	var nodeset = {};
  	for(var n of res) {
  	    nodeset[n] = true;
  	}
  	var ans_dict = neighbourhood(nodeset, steps, nodes);
  	for(var n in ans_dict) {
  	    result.push(n);
  	}
      }
      else if(q[0] == "name"){
  	var name = q[1].toLowerCase();
  	for(var n in nodes){
  	    if(name == "*" || nodes[n].name.toLowerCase().indexOf(name) >= 0){
  		result.push(n);
  	    }
  	}
      }
      else if(q[0] == "exactly"){
  	var name = q[1].toLowerCase();
  	for(var n in nodes){
  	    if(nodes[n].name.toLowerCase() == name){
  		result.push(n);
  	    }
  	}
      }
      else if(q[0] == "prop"){
  	var prop_name = q[1][0].toLowerCase();
  	var prop_val = q[1][1].toLowerCase();
  	for(var n in nodes){
  	    if(nodes[n][prop_name] && nodes[n][prop_name].toLowerCase().indexOf(prop_val) >= 0){
  		result.push(n);
  	    }
  	}
      }
      else if(q[0] == "before"){
  	var cutoff_date = date_from_string(q[1]);
  	for(var n in nodes){
  	    if(!(nodes[n].date)) continue;
  	    var d = date_from_string(nodes[n].date);
  	    if(d && d < cutoff_date){
  		result.push(n);
  	    }
  	}
      }
      else if(q[0] == "after"){
  	var cutoff_date = date_from_string(q[1]);
  	for(var n in nodes){
  	    if(!(nodes[n].date)) continue;
  	    var d = date_from_string(nodes[n].date);
  	    if(d && d > cutoff_date){
  		result.push(n);
  	    }
  	}
      }
      else {
  	console.log("Unrecognised query type:",q[0]);
      }
      return result;
  };

  Vue$1.config.productionTip = true;

  Vue$1.component('graphIndex', GraphIndex);
  Vue$1.component('nodeIndex', NodeIndex);
  Vue$1.component('labelIndex', LabelIndex);
  Vue$1.component('nodeFilter', NodeFilter);
  Vue$1.component('historyDisplay', HistoryDisplay);
  Vue$1.component('edgeDisplay', EdgeDisplay);

  Vue$1.category_plugins = {
      'cat-slideshow': Vue$1.component('catSlideshow', SlideshowPlugin),
      'cat-loc': Vue$1.component('catLoc', LocPlugin),
      'cat-video': Vue$1.component('catVideo', VideoPlugin),
      'cat-query': Vue$1.component('catQuery', QueryPlugin),
      'cat-link': Vue$1.component('catLink', LinkPlugin),
      'cat-jsavr': Vue$1.component('catJsavr', JSAVRPlugin),
  //    'cat-math': Vue.component('catMath', MathPlugin)
  };

  Vue$1.category_search_plugin = Vue$1.component('search', SearchDisplay);

  Vue$1.category_query = new query$1.Parser();
  Vue$1.category_search = search;

  Vue$1.run_plugins = function(comp){
      for(var p in Vue$1.category_plugins) {
  	var plugin = Vue$1.category_plugins[p];
  	var l = comp.$el.getElementsByTagName(p);
  	while(l.length > 0) {
  	    var node = l[0];
  	    console.log("PL",p,node);
  	    new plugin({
  		el: node,
  		propsData: {'root': node},
  		parent: comp
  	    });
  	}
      }
  };
  window.onload = function() {
   
  new Vue$1({
      router,
      store,
      created: function() {
  	this.$store.dispatch('refresh_metadata');
      },
      render: function (h) { return h(App) }
  }).$mount('#cafeapp');

  };

}());
